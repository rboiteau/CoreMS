<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.molecular_id.factory.molecularSQL API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.molecular_id.factory.molecularSQL</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys
sys.path.append(&#34;.&#34;)
import os

from sqlalchemy import create_engine, ForeignKey, Column, Integer, String, Float, SMALLINT
from sqlalchemy.orm import backref, column_property, relationship
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.sql.schema import UniqueConstraint
from sqlalchemy import exc

from sqlalchemy.ext.declarative import declarative_base, declared_attr
from sqlalchemy.ext.hybrid import hybrid_property, hybrid_method
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.orm.session import sessionmaker
from sqlalchemy.sql.operators import exists
from sqlalchemy import event, and_
from sqlalchemy import func

from corems.encapsulation.constant import Atoms, Labels
import json
from corems.encapsulation.factory.processingSetting import MolecularFormulaSearchSettings
from sqlalchemy.orm.scoping import scoped_session
from corems import chunks
import tqdm

Base = declarative_base()

class HeteroAtoms(Base):
   
    __tablename__ = &#39;heteroAtoms&#39;
    
    id = Column(Integer, primary_key=True,
                         unique = True,
                         nullable = False)

    name = Column(String, unique=True,  nullable=False)
    
    halogensCount = Column(Integer, unique=False,  nullable=False) 

    carbonHydrogen = relationship(&#39;CarbonHydrogen&#39;, secondary = &#39;molecularformula&#39;)
    
    def __repr__(self):
        return &#39;&lt;HeteroAtoms Model {} class {}&gt;&#39;.format(self.id, self.name)      
    
    @hybrid_property
    def halogens_count(cls):
        return cls.halogensCount.cast(Float)

    def to_dict(self):
        
        return json.loads(self.name)
        

class CarbonHydrogen(Base):
   
    __tablename__ = &#39;carbonHydrogen&#39;
    __table_args__ = ( UniqueConstraint(&#39;C&#39;, &#39;H&#39;, name=&#39;unique_c_h&#39;), )

    id = Column(Integer, primary_key=True,
                        unique=True,
                        nullable=False)

    C = Column(Integer, nullable=False)
    
    H = Column(Integer,  nullable=False)
    
    heteroAtoms = relationship(&#34;HeteroAtoms&#34;,
                        secondary=&#34;molecularformula&#34;,
                       )

    def __repr__(self):
        return &#39;&lt;CarbonHydrogen Model {} C{} H{}&gt;&#39;.format(self.id, self.C, self.H)                     

    @property
    def mass(self):
        return (self.C * Atoms.atomic_masses.get(&#39;C&#39;)) + (self.H * Atoms.atomic_masses.get(&#39;H&#39;))

    @hybrid_property
    def c(cls):
        return cls.C.cast(Float)

    @hybrid_property
    def h(cls):
        return cls.H.cast(Float)

    @hybrid_property
    def dbe(cls):
        return cls.C.cast(Float) - (cls.H.cast(Float) / 2) + 1
        return float(cls.C) - float(cls.H/2) + 1

#264888.88 ms
class MolecularFormulaLink(Base):
    
    __tablename__ = &#39;molecularformula&#39;
    __table_args__ = ( UniqueConstraint(&#39;heteroAtoms_id&#39;, &#39;carbonHydrogen_id&#39;, name=&#39;unique_molform&#39;), )
    
    #id = Column(Integer, primary_key=True,
    #                    unique=True,
    #                    nullable=False)

    heteroAtoms_id = Column(
        Integer, 
        ForeignKey(&#39;heteroAtoms.id&#39;), 
        primary_key=True)

    carbonHydrogen_id = Column(
        Integer, 
        ForeignKey(&#39;carbonHydrogen.id&#39;), 
        primary_key=True)
    
    mass = Column(Float)
    
    DBE = Column(Float)
    
    carbonHydrogen = relationship(CarbonHydrogen, backref=backref(&#34;heteroAtoms_assoc&#34;))
    
    heteroAtoms = relationship(HeteroAtoms, backref=backref(&#34;carbonHydrogen_assoc&#34;))
    
    C = association_proxy(&#39;carbonHydrogen&#39;, &#39;C&#39;)

    H = association_proxy(&#39;carbonHydrogen&#39;, &#39;H&#39;)

    classe = association_proxy(&#39;heteroAtoms&#39;, &#39;name&#39;)

    @property
    def formula_dict(self):
        
        carbon = {&#39;C&#39;: self.C, &#39;H&#39;: self.H}
        classe = json.loads(self.classe)
        if self.classe == &#39;{&#34;HC&#34;: &#34;&#34;}&#39;:
            return {**carbon}
        else:
            return {**carbon, **classe}

    @property
    def formula_string(self):
        class_dict = self.formula_dict 
        class_str = &#39; &#39;.join([atom + str(class_dict[atom]) for atom in class_dict.keys()])
        return class_str.strip()

    @property
    def classe_string(self):
        class_dict = json.loads(self.classe)
        class_str = &#39; &#39;.join([atom + str(class_dict[atom]) for atom in class_dict.keys()])
        return class_str.strip()

    @hybrid_method
    def adduct_mass(self, ion_charge, adduct_atom):
        return (self.mass + (Atoms.atomic_masses.get(adduct_atom)) + (ion_charge * -1 * Atoms.electron_mass))/ abs(ion_charge)

    @hybrid_method
    def protonated_mass(self, ion_charge):
        return (self.mass + (ion_charge * Atoms.atomic_masses.get(&#34;H&#34;)) + (ion_charge * -1 * Atoms.electron_mass))/abs(ion_charge)
    
    @hybrid_method
    def radical_mass(self, ion_charge):
        return (self.mass + (ion_charge * -1 * Atoms.electron_mass))/ abs(ion_charge)

    def __repr__(self):
        
        return &#39;&lt;MolecularFormulaLink Model {}&gt;&#39;.format(self.formula_string)       


class MolForm_SQL:
    
    def __init__(self, url=None, echo=False):
        
        self.engine = self.init_engine(url)
        
        self.add_engine_pidguard(self.engine)
        
        session_factory = sessionmaker(bind=self.engine)
        
        Session = scoped_session(session_factory)
        
        self.session = session_factory()
        
        Base.metadata.create_all(self.engine)

        self.session.commit()
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        # make sure the dbconnection gets closed
        
        self.commit()
        self.session.close()
        self.engine.dispose()

    def initiate_database(self, url, database_name):  #CREATION
        
        engine = sqlalchemy.create_engine(database_url)
        conn = engine.connect()
        conn.execute(&#34;commit&#34;)
        conn.execute(&#34;create database &#34;+database_name)
        conn.close()


    def commit(self):
        
        try:
            self.session.commit()  
        except SQLAlchemyError as e:
            self.session.rollback()
            print(str(e))

    def init_engine(self, url):
        
        if not url or url == &#39;None&#39; or url == &#39;False&#39;:
            directory = os.getcwd()
            
            if not os.path.isdir(directory+&#39;/db&#39;):  os.mkdir(directory+&#39;/db&#39;)
            
            url = &#39;sqlite:///{DB}/db/molformulas.sqlite&#39;.format(DB=directory)

        if url[0:6] == &#39;sqlite&#39;:
            self.type = &#39;sqlite&#39;
        else:
            self.type = &#39;normal&#39;
            
        if url[0:6] == &#39;sqlite&#39;:
            engine = create_engine(url, echo = False)
            self.chunks_count = 50
        
        elif url[0:10] == &#39;postgresql&#39; or url[0:8] == &#39;postgres&#39;:
            #postgresql
            self.chunks_count = 50000
            engine = create_engine(url, echo = False, isolation_level=&#34;AUTOCOMMIT&#34;)
        
        return engine# poolclass=NullPool

    def __enter__(self):
        
        return self
    
    def get_dict_by_classes(self, classes, ion_type, nominal_mzs, ion_charge, molecular_search_settings, adducts=None):
                                    
        &#39;&#39;&#39;Known issue, when using SQLite:
         if the number of classes and nominal_m/zs are higher than 999 the query will fail
         Solution: use postgres or split query&#39;&#39;&#39; 
        def query_normal(class_list, len_adduct):
            
            base_query = self.session.query(MolecularFormulaLink, CarbonHydrogen, HeteroAtoms)\
                                .filter(MolecularFormulaLink.carbonHydrogen_id == CarbonHydrogen.id)\
                                .filter(MolecularFormulaLink.heteroAtoms_id == HeteroAtoms.id)
            
            return base_query.filter(
                and_(
                    HeteroAtoms.name.in_(class_list), 
                    and_(
                        MolecularFormulaLink.DBE &gt;= molecular_search_settings.min_dbe, 
                        MolecularFormulaLink.DBE &lt;= molecular_search_settings.max_dbe, 
                        and_(
                            ((CarbonHydrogen.h + HeteroAtoms.halogens_count - len_adduct) / CarbonHydrogen.c) &gt;= molecular_search_settings.min_hc_filter,
                            ((CarbonHydrogen.h + HeteroAtoms.halogens_count - len_adduct) / CarbonHydrogen.c) &lt;= molecular_search_settings.max_hc_filter,
                            CarbonHydrogen.C &gt;= molecular_search_settings.usedAtoms.get(&#34;C&#34;)[0],
                            CarbonHydrogen.c &lt;= molecular_search_settings.usedAtoms.get(&#34;C&#34;)[1],
                            CarbonHydrogen.h &gt;= molecular_search_settings.usedAtoms.get(&#34;H&#34;)[0],
                            CarbonHydrogen.h &lt;= molecular_search_settings.usedAtoms.get(&#34;H&#34;)[1],
                        )
                    )
                )
            )

        def add_dict_formula(formulas, ion_type, ion_charge, adduct_atom=None):
            &#34;organize data by heteroatom classes&#34;
            dict_res = {}

            def nominal_mass_by_ion_type(formula_obj):
                
                if ion_type == Labels.protonated_de_ion:
                
                    return int(formula_obj.protonated_mass(ion_charge))
                
                elif ion_type == Labels.radical_ion:
                    
                    return int(formula_obj.radical_mass(ion_charge))

                elif ion_type == Labels.adduct_ion and adduct_atom:
                    
                    return int(formula_obj.adduct_mass(ion_charge, adduct_atom))
            
            for formula_obj, ch_obj, classe_obj  in tqdm.tqdm(formulas, desc=&#34;Loading molecular formula database&#34;):
                
                nominal_mz = nominal_mass_by_ion_type(formula_obj)
                
                if self.type != &#39;normal&#39;:
                    if not nominal_mz in nominal_mzs:
                        continue
                classe = classe_obj.name

                #classe_str = formula.classe_string
                
                #pbar.set_description_str(desc=&#34;Loading molecular formula database for class %s &#34; % classe_str)
                
                formula_dict = formula_obj.formula_dict

                if formula_dict.get(&#34;O&#34;):
                    
                    if formula_dict.get(&#34;O&#34;)/formula_dict.get(&#34;C&#34;) &gt;= molecular_search_settings.min_oc_filter:
                        #print(formula_dict.get(&#34;O&#34;)/formula_dict.get(&#34;C&#34;))
                        continue

                    #if formula_dict.get(&#34;P&#34;):

                    #    if  not (formula_dict.get(&#34;O&#34;) -2)/ formula_dict.get(&#34;P&#34;) &gt;= molecular_search_settings.min_op_filter:
                            
                    #        continue
        
                if classe in dict_res.keys():
                    
                    if nominal_mz in dict_res[classe].keys():
                        
                        dict_res.get(classe).get(nominal_mz).append(formula_obj)
                    
                    else:

                        dict_res.get(classe)[nominal_mz] = [formula_obj ]  
            
                else:
                    
                    dict_res[classe] = {nominal_mz: [formula_obj] }     
            
            return dict_res
        
        
        len_adducts = 0
        if ion_type == Labels.adduct_ion:
            len_adducts = 1
        
        query = query_normal(classes, len_adducts)

        if ion_type == Labels.protonated_de_ion:
            if self.type == &#39;normal&#39;:
                query = query.filter(and_(
                                MolecularFormulaLink.protonated_mass(ion_charge).cast(Integer).in_(nominal_mzs)
                                ))
            return add_dict_formula(query, ion_type, ion_charge)
        
        if ion_type == Labels.radical_ion:
            if self.type == &#39;normal&#39;:
                query = query.filter(MolecularFormulaLink.radical_mass(ion_charge).cast(Integer).in_(nominal_mzs))    
            return add_dict_formula(query, ion_type, ion_charge)
        
        if ion_type == Labels.adduct_ion:
            dict_res = {}
            if adducts: 
                for atom in adducts:
                    if self.type == &#39;normal&#39;:
                        query = query.filter(MolecularFormulaLink.adduct_mass(ion_charge, atom).cast(Integer).in_(nominal_mzs))    
                    dict_res[atom] = add_dict_formula(query, ion_type, ion_charge, adduct_atom=atom)
                return dict_res
        # dump all objs to memory
        self.session.expunge_all()
        
    def check_entry(self,classe, ion_type, molecular_search_settings):
        #  get all classes, ion_type, ion charge as str add to a dict or list
        #  then check if class in database
        has_class = self.session.query(exists().where(
            (MolecularFormulaLink.classe == classe)))
        
        return has_class
    
    def get_all_classes(self):
        
        query = self.session.query(MolecularFormulaLink.classe.distinct().label(&#34;classe&#34;))
        
        return query.all()  
    
    def get_all(self,):
        
        mol_formulas = self.session.query(MolecularFormulaLink).all()
        
        return mol_formulas

    def delete_entry(self, row):
        
        try:
            self.session.delete(row)  
            self.session.commit()  
        
        except SQLAlchemyError as e:
            self.session.rollback()
            print(str(e))

    def purge(self, cls):
        &#39;&#39;&#39;Carefull, this will delete the entire database table&#39;&#39;&#39;
        self.session.query(cls).delete()
        self.session.commit()  

    def clear_data(self):
        &#39;&#39;&#39;clear tables&#39;&#39;&#39;
        meta = Base.metadata
        for table in reversed(meta.sorted_tables):
            print (&#39;Clear table %s&#39; % table)
            self.session.execute(table.delete())
        self.session.commit()

    def close(self, commit=True):
        # make sure the dbconnection gets closed
        
        if commit: self.commit()
        self.session.close()
        self.engine.dispose()    
   
    def add_engine_pidguard(self, engine):
        import os, warnings
        &#34;&#34;&#34;Add multiprocessing guards.

        Forces a connection to be reconnected if it is detected
        as having been shared to a sub-process.

        &#34;&#34;&#34;

        @event.listens_for(engine, &#34;connect&#34;)
        def connect(dbapi_connection, connection_record):
            connection_record.info[&#39;pid&#39;] = os.getpid()

        @event.listens_for(engine, &#34;checkout&#34;)
        def checkout(dbapi_connection, connection_record, connection_proxy):
            pid = os.getpid()
            if connection_record.info[&#39;pid&#39;] != pid:
                # substitute log.debug() or similar here as desired
                warnings.warn(
                    &#34;Parent process %(orig)s forked (%(newproc)s) with an open &#34;
                    &#34;database connection, &#34;
                    &#34;which is being discarded and recreated.&#34; %
                    {&#34;newproc&#34;: pid, &#34;orig&#34;: connection_record.info[&#39;pid&#39;]})
                connection_record.connection = connection_proxy.connection = None
                raise exc.DisconnectionError(
                    &#34;Connection record belongs to pid %s, &#34;
                    &#34;attempting to check out in pid %s&#34; %
                    (connection_record.info[&#39;pid&#39;], pid)
                )    

if __name__ == &#34;__main__&#34;:
    
    sql = MolForm_SQL(url=&#39;sqlite:///&#39;)
    
    dict_data = {&#34;name&#34;: &#39;{&#34;O&#34;: 12}&#39;}
    dict_data2 = {&#34;name&#34;: &#39;{&#34;O&#34;: 13}&#39;}
    hetero_obj = HeteroAtoms(**dict_data)
    hetero_obj2 = HeteroAtoms(**dict_data2)
    sql.session.add(hetero_obj)
    sql.session.add(hetero_obj2)

    print(sql.session.query(HeteroAtoms).all())
    #molecular_search_settings = MolecularFormulaSearchSettings()
    #sql = MolForm_SQL()
    #query = sql.session.query(MolecularFormulaLink).filter_by(classe = &#39;{&#34;O&#34;: 12}&#39;).filter(MolecularFormulaLink.adduct_mass(+2, &#34;Na&#34;) &lt; 250)
    #query = sql.get_by_classe(&#39;{&#34;O&#34;: 12}&#39;, molecular_search_settings).filter(MolecularFormulaLink.adduct_mass(+2, &#34;Na&#34;) &lt; 250)
    #classes = [&#39;{&#34;O&#34;: 12}&#39;]*1
    #for i, classe in enumerate(classes):
        #query = sql.get_by_classe(classe, molecular_search_settings)
        #query = sql.session.query(MolecularFormulaLink).filter_by(classe = &#39;{&#34;O&#34;: 12}&#39;).filter(MolecularFormulaLink.adduct_mass(+2, &#34;Na&#34;) &lt; 250)
        #for i in query.filter(MolecularFormulaLink.mass &lt; 250):
            
        #    print(i.radical_mass(-1), i.protonated_mass(-1), i.adduct_mass(+2, &#34;Na&#34;), i.mass, i.formula_dict, i.formula_string)
    #
 </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="corems.molecular_id.factory.molecularSQL.and_"><code class="name flex">
<span>def <span class="ident">and_</span></span>(<span>*clauses)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a conjunction of expressions joined by <code>AND</code>.</p>
<p>E.g.::</p>
<pre><code>from sqlalchemy import and_

stmt = select([users_table]).where(
                and_(
                    users_table.c.name == 'wendy',
                    users_table.c.enrolled == True
                )
            )
</code></pre>
<p>The :func:<code>.<a title="corems.molecular_id.factory.molecularSQL.and_" href="#corems.molecular_id.factory.molecularSQL.and_">and_()</a></code> conjunction is also available using the
Python <code>&amp;</code> operator (though note that compound expressions
need to be parenthesized in order to function with Python
operator precedence behavior)::</p>
<pre><code>stmt = select([users_table]).where(
                (users_table.c.name == 'wendy') &amp;
                (users_table.c.enrolled == True)
            )
</code></pre>
<p>The :func:<code>.<a title="corems.molecular_id.factory.molecularSQL.and_" href="#corems.molecular_id.factory.molecularSQL.and_">and_()</a></code> operation is also implicit in some cases;
the :meth:<code>.Select.where</code> method for example can be invoked multiple
times against a statement, which will have the effect of each
clause being combined using :func:<code>.<a title="corems.molecular_id.factory.molecularSQL.and_" href="#corems.molecular_id.factory.molecularSQL.and_">and_()</a></code>::</p>
<pre><code>stmt = select([users_table]).                        where(users_table.c.name == 'wendy').                        where(users_table.c.enrolled == True)
</code></pre>
<div class="admonition seealso">
<p class="admonition-title">Seealso</p>
<p>:func:<code>.or_</code></p>
</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="corems.molecular_id.factory.molecularSQL.CarbonHydrogen"><code class="flex name class">
<span>class <span class="ident">CarbonHydrogen</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The most base type</p>
<p>A simple constructor that allows initialization from kwargs.</p>
<p>Sets attributes on the constructed instance using the names and
values in <code>kwargs</code>.</p>
<p>Only keys that are present as
attributes of the instance's class are allowed. These could be,
for example, any mapped columns or relationships.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CarbonHydrogen(Base):
   
    __tablename__ = &#39;carbonHydrogen&#39;
    __table_args__ = ( UniqueConstraint(&#39;C&#39;, &#39;H&#39;, name=&#39;unique_c_h&#39;), )

    id = Column(Integer, primary_key=True,
                        unique=True,
                        nullable=False)

    C = Column(Integer, nullable=False)
    
    H = Column(Integer,  nullable=False)
    
    heteroAtoms = relationship(&#34;HeteroAtoms&#34;,
                        secondary=&#34;molecularformula&#34;,
                       )

    def __repr__(self):
        return &#39;&lt;CarbonHydrogen Model {} C{} H{}&gt;&#39;.format(self.id, self.C, self.H)                     

    @property
    def mass(self):
        return (self.C * Atoms.atomic_masses.get(&#39;C&#39;)) + (self.H * Atoms.atomic_masses.get(&#39;H&#39;))

    @hybrid_property
    def c(cls):
        return cls.C.cast(Float)

    @hybrid_property
    def h(cls):
        return cls.H.cast(Float)

    @hybrid_property
    def dbe(cls):
        return cls.C.cast(Float) - (cls.H.cast(Float) / 2) + 1
        return float(cls.C) - float(cls.H/2) + 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sqlalchemy.ext.declarative.api.Base</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.C"><code class="name">var <span class="ident">C</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.H"><code class="name">var <span class="ident">H</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.heteroAtoms"><code class="name">var <span class="ident">heteroAtoms</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.mass"><code class="name">var <span class="ident">mass</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mass(self):
    return (self.C * Atoms.atomic_masses.get(&#39;C&#39;)) + (self.H * Atoms.atomic_masses.get(&#39;H&#39;))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.c"><code class="name flex">
<span>def <span class="ident">c</span></span>(<span>cls)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@hybrid_property
def c(cls):
    return cls.C.cast(Float)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.dbe"><code class="name flex">
<span>def <span class="ident">dbe</span></span>(<span>cls)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@hybrid_property
def dbe(cls):
    return cls.C.cast(Float) - (cls.H.cast(Float) / 2) + 1
    return float(cls.C) - float(cls.H/2) + 1</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>cls)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@hybrid_property
def h(cls):
    return cls.H.cast(Float)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.HeteroAtoms"><code class="flex name class">
<span>class <span class="ident">HeteroAtoms</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The most base type</p>
<p>A simple constructor that allows initialization from kwargs.</p>
<p>Sets attributes on the constructed instance using the names and
values in <code>kwargs</code>.</p>
<p>Only keys that are present as
attributes of the instance's class are allowed. These could be,
for example, any mapped columns or relationships.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeteroAtoms(Base):
   
    __tablename__ = &#39;heteroAtoms&#39;
    
    id = Column(Integer, primary_key=True,
                         unique = True,
                         nullable = False)

    name = Column(String, unique=True,  nullable=False)
    
    halogensCount = Column(Integer, unique=False,  nullable=False) 

    carbonHydrogen = relationship(&#39;CarbonHydrogen&#39;, secondary = &#39;molecularformula&#39;)
    
    def __repr__(self):
        return &#39;&lt;HeteroAtoms Model {} class {}&gt;&#39;.format(self.id, self.name)      
    
    @hybrid_property
    def halogens_count(cls):
        return cls.halogensCount.cast(Float)

    def to_dict(self):
        
        return json.loads(self.name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sqlalchemy.ext.declarative.api.Base</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="corems.molecular_id.factory.molecularSQL.HeteroAtoms.carbonHydrogen"><code class="name">var <span class="ident">carbonHydrogen</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.HeteroAtoms.halogensCount"><code class="name">var <span class="ident">halogensCount</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.HeteroAtoms.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.HeteroAtoms.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="corems.molecular_id.factory.molecularSQL.HeteroAtoms.halogens_count"><code class="name flex">
<span>def <span class="ident">halogens_count</span></span>(<span>cls)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@hybrid_property
def halogens_count(cls):
    return cls.halogensCount.cast(Float)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.HeteroAtoms.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self):
    
    return json.loads(self.name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolForm_SQL"><code class="flex name class">
<span>class <span class="ident">MolForm_SQL</span></span>
<span>(</span><span>url=None, echo=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MolForm_SQL:
    
    def __init__(self, url=None, echo=False):
        
        self.engine = self.init_engine(url)
        
        self.add_engine_pidguard(self.engine)
        
        session_factory = sessionmaker(bind=self.engine)
        
        Session = scoped_session(session_factory)
        
        self.session = session_factory()
        
        Base.metadata.create_all(self.engine)

        self.session.commit()
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        # make sure the dbconnection gets closed
        
        self.commit()
        self.session.close()
        self.engine.dispose()

    def initiate_database(self, url, database_name):  #CREATION
        
        engine = sqlalchemy.create_engine(database_url)
        conn = engine.connect()
        conn.execute(&#34;commit&#34;)
        conn.execute(&#34;create database &#34;+database_name)
        conn.close()


    def commit(self):
        
        try:
            self.session.commit()  
        except SQLAlchemyError as e:
            self.session.rollback()
            print(str(e))

    def init_engine(self, url):
        
        if not url or url == &#39;None&#39; or url == &#39;False&#39;:
            directory = os.getcwd()
            
            if not os.path.isdir(directory+&#39;/db&#39;):  os.mkdir(directory+&#39;/db&#39;)
            
            url = &#39;sqlite:///{DB}/db/molformulas.sqlite&#39;.format(DB=directory)

        if url[0:6] == &#39;sqlite&#39;:
            self.type = &#39;sqlite&#39;
        else:
            self.type = &#39;normal&#39;
            
        if url[0:6] == &#39;sqlite&#39;:
            engine = create_engine(url, echo = False)
            self.chunks_count = 50
        
        elif url[0:10] == &#39;postgresql&#39; or url[0:8] == &#39;postgres&#39;:
            #postgresql
            self.chunks_count = 50000
            engine = create_engine(url, echo = False, isolation_level=&#34;AUTOCOMMIT&#34;)
        
        return engine# poolclass=NullPool

    def __enter__(self):
        
        return self
    
    def get_dict_by_classes(self, classes, ion_type, nominal_mzs, ion_charge, molecular_search_settings, adducts=None):
                                    
        &#39;&#39;&#39;Known issue, when using SQLite:
         if the number of classes and nominal_m/zs are higher than 999 the query will fail
         Solution: use postgres or split query&#39;&#39;&#39; 
        def query_normal(class_list, len_adduct):
            
            base_query = self.session.query(MolecularFormulaLink, CarbonHydrogen, HeteroAtoms)\
                                .filter(MolecularFormulaLink.carbonHydrogen_id == CarbonHydrogen.id)\
                                .filter(MolecularFormulaLink.heteroAtoms_id == HeteroAtoms.id)
            
            return base_query.filter(
                and_(
                    HeteroAtoms.name.in_(class_list), 
                    and_(
                        MolecularFormulaLink.DBE &gt;= molecular_search_settings.min_dbe, 
                        MolecularFormulaLink.DBE &lt;= molecular_search_settings.max_dbe, 
                        and_(
                            ((CarbonHydrogen.h + HeteroAtoms.halogens_count - len_adduct) / CarbonHydrogen.c) &gt;= molecular_search_settings.min_hc_filter,
                            ((CarbonHydrogen.h + HeteroAtoms.halogens_count - len_adduct) / CarbonHydrogen.c) &lt;= molecular_search_settings.max_hc_filter,
                            CarbonHydrogen.C &gt;= molecular_search_settings.usedAtoms.get(&#34;C&#34;)[0],
                            CarbonHydrogen.c &lt;= molecular_search_settings.usedAtoms.get(&#34;C&#34;)[1],
                            CarbonHydrogen.h &gt;= molecular_search_settings.usedAtoms.get(&#34;H&#34;)[0],
                            CarbonHydrogen.h &lt;= molecular_search_settings.usedAtoms.get(&#34;H&#34;)[1],
                        )
                    )
                )
            )

        def add_dict_formula(formulas, ion_type, ion_charge, adduct_atom=None):
            &#34;organize data by heteroatom classes&#34;
            dict_res = {}

            def nominal_mass_by_ion_type(formula_obj):
                
                if ion_type == Labels.protonated_de_ion:
                
                    return int(formula_obj.protonated_mass(ion_charge))
                
                elif ion_type == Labels.radical_ion:
                    
                    return int(formula_obj.radical_mass(ion_charge))

                elif ion_type == Labels.adduct_ion and adduct_atom:
                    
                    return int(formula_obj.adduct_mass(ion_charge, adduct_atom))
            
            for formula_obj, ch_obj, classe_obj  in tqdm.tqdm(formulas, desc=&#34;Loading molecular formula database&#34;):
                
                nominal_mz = nominal_mass_by_ion_type(formula_obj)
                
                if self.type != &#39;normal&#39;:
                    if not nominal_mz in nominal_mzs:
                        continue
                classe = classe_obj.name

                #classe_str = formula.classe_string
                
                #pbar.set_description_str(desc=&#34;Loading molecular formula database for class %s &#34; % classe_str)
                
                formula_dict = formula_obj.formula_dict

                if formula_dict.get(&#34;O&#34;):
                    
                    if formula_dict.get(&#34;O&#34;)/formula_dict.get(&#34;C&#34;) &gt;= molecular_search_settings.min_oc_filter:
                        #print(formula_dict.get(&#34;O&#34;)/formula_dict.get(&#34;C&#34;))
                        continue

                    #if formula_dict.get(&#34;P&#34;):

                    #    if  not (formula_dict.get(&#34;O&#34;) -2)/ formula_dict.get(&#34;P&#34;) &gt;= molecular_search_settings.min_op_filter:
                            
                    #        continue
        
                if classe in dict_res.keys():
                    
                    if nominal_mz in dict_res[classe].keys():
                        
                        dict_res.get(classe).get(nominal_mz).append(formula_obj)
                    
                    else:

                        dict_res.get(classe)[nominal_mz] = [formula_obj ]  
            
                else:
                    
                    dict_res[classe] = {nominal_mz: [formula_obj] }     
            
            return dict_res
        
        
        len_adducts = 0
        if ion_type == Labels.adduct_ion:
            len_adducts = 1
        
        query = query_normal(classes, len_adducts)

        if ion_type == Labels.protonated_de_ion:
            if self.type == &#39;normal&#39;:
                query = query.filter(and_(
                                MolecularFormulaLink.protonated_mass(ion_charge).cast(Integer).in_(nominal_mzs)
                                ))
            return add_dict_formula(query, ion_type, ion_charge)
        
        if ion_type == Labels.radical_ion:
            if self.type == &#39;normal&#39;:
                query = query.filter(MolecularFormulaLink.radical_mass(ion_charge).cast(Integer).in_(nominal_mzs))    
            return add_dict_formula(query, ion_type, ion_charge)
        
        if ion_type == Labels.adduct_ion:
            dict_res = {}
            if adducts: 
                for atom in adducts:
                    if self.type == &#39;normal&#39;:
                        query = query.filter(MolecularFormulaLink.adduct_mass(ion_charge, atom).cast(Integer).in_(nominal_mzs))    
                    dict_res[atom] = add_dict_formula(query, ion_type, ion_charge, adduct_atom=atom)
                return dict_res
        # dump all objs to memory
        self.session.expunge_all()
        
    def check_entry(self,classe, ion_type, molecular_search_settings):
        #  get all classes, ion_type, ion charge as str add to a dict or list
        #  then check if class in database
        has_class = self.session.query(exists().where(
            (MolecularFormulaLink.classe == classe)))
        
        return has_class
    
    def get_all_classes(self):
        
        query = self.session.query(MolecularFormulaLink.classe.distinct().label(&#34;classe&#34;))
        
        return query.all()  
    
    def get_all(self,):
        
        mol_formulas = self.session.query(MolecularFormulaLink).all()
        
        return mol_formulas

    def delete_entry(self, row):
        
        try:
            self.session.delete(row)  
            self.session.commit()  
        
        except SQLAlchemyError as e:
            self.session.rollback()
            print(str(e))

    def purge(self, cls):
        &#39;&#39;&#39;Carefull, this will delete the entire database table&#39;&#39;&#39;
        self.session.query(cls).delete()
        self.session.commit()  

    def clear_data(self):
        &#39;&#39;&#39;clear tables&#39;&#39;&#39;
        meta = Base.metadata
        for table in reversed(meta.sorted_tables):
            print (&#39;Clear table %s&#39; % table)
            self.session.execute(table.delete())
        self.session.commit()

    def close(self, commit=True):
        # make sure the dbconnection gets closed
        
        if commit: self.commit()
        self.session.close()
        self.engine.dispose()    
   
    def add_engine_pidguard(self, engine):
        import os, warnings
        &#34;&#34;&#34;Add multiprocessing guards.

        Forces a connection to be reconnected if it is detected
        as having been shared to a sub-process.

        &#34;&#34;&#34;

        @event.listens_for(engine, &#34;connect&#34;)
        def connect(dbapi_connection, connection_record):
            connection_record.info[&#39;pid&#39;] = os.getpid()

        @event.listens_for(engine, &#34;checkout&#34;)
        def checkout(dbapi_connection, connection_record, connection_proxy):
            pid = os.getpid()
            if connection_record.info[&#39;pid&#39;] != pid:
                # substitute log.debug() or similar here as desired
                warnings.warn(
                    &#34;Parent process %(orig)s forked (%(newproc)s) with an open &#34;
                    &#34;database connection, &#34;
                    &#34;which is being discarded and recreated.&#34; %
                    {&#34;newproc&#34;: pid, &#34;orig&#34;: connection_record.info[&#39;pid&#39;]})
                connection_record.connection = connection_proxy.connection = None
                raise exc.DisconnectionError(
                    &#34;Connection record belongs to pid %s, &#34;
                    &#34;attempting to check out in pid %s&#34; %
                    (connection_record.info[&#39;pid&#39;], pid)
                )    </code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="corems.molecular_id.factory.molecularSQL.MolForm_SQL.add_engine_pidguard"><code class="name flex">
<span>def <span class="ident">add_engine_pidguard</span></span>(<span>self, engine)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_engine_pidguard(self, engine):
    import os, warnings
    &#34;&#34;&#34;Add multiprocessing guards.

    Forces a connection to be reconnected if it is detected
    as having been shared to a sub-process.

    &#34;&#34;&#34;

    @event.listens_for(engine, &#34;connect&#34;)
    def connect(dbapi_connection, connection_record):
        connection_record.info[&#39;pid&#39;] = os.getpid()

    @event.listens_for(engine, &#34;checkout&#34;)
    def checkout(dbapi_connection, connection_record, connection_proxy):
        pid = os.getpid()
        if connection_record.info[&#39;pid&#39;] != pid:
            # substitute log.debug() or similar here as desired
            warnings.warn(
                &#34;Parent process %(orig)s forked (%(newproc)s) with an open &#34;
                &#34;database connection, &#34;
                &#34;which is being discarded and recreated.&#34; %
                {&#34;newproc&#34;: pid, &#34;orig&#34;: connection_record.info[&#39;pid&#39;]})
            connection_record.connection = connection_proxy.connection = None
            raise exc.DisconnectionError(
                &#34;Connection record belongs to pid %s, &#34;
                &#34;attempting to check out in pid %s&#34; %
                (connection_record.info[&#39;pid&#39;], pid)
            )    </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolForm_SQL.check_entry"><code class="name flex">
<span>def <span class="ident">check_entry</span></span>(<span>self, classe, ion_type, molecular_search_settings)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_entry(self,classe, ion_type, molecular_search_settings):
    #  get all classes, ion_type, ion charge as str add to a dict or list
    #  then check if class in database
    has_class = self.session.query(exists().where(
        (MolecularFormulaLink.classe == classe)))
    
    return has_class</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolForm_SQL.clear_data"><code class="name flex">
<span>def <span class="ident">clear_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>clear tables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_data(self):
    &#39;&#39;&#39;clear tables&#39;&#39;&#39;
    meta = Base.metadata
    for table in reversed(meta.sorted_tables):
        print (&#39;Clear table %s&#39; % table)
        self.session.execute(table.delete())
    self.session.commit()</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolForm_SQL.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, commit=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self, commit=True):
    # make sure the dbconnection gets closed
    
    if commit: self.commit()
    self.session.close()
    self.engine.dispose()    </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolForm_SQL.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit(self):
    
    try:
        self.session.commit()  
    except SQLAlchemyError as e:
        self.session.rollback()
        print(str(e))</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolForm_SQL.delete_entry"><code class="name flex">
<span>def <span class="ident">delete_entry</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_entry(self, row):
    
    try:
        self.session.delete(row)  
        self.session.commit()  
    
    except SQLAlchemyError as e:
        self.session.rollback()
        print(str(e))</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolForm_SQL.get_all"><code class="name flex">
<span>def <span class="ident">get_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all(self,):
    
    mol_formulas = self.session.query(MolecularFormulaLink).all()
    
    return mol_formulas</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolForm_SQL.get_all_classes"><code class="name flex">
<span>def <span class="ident">get_all_classes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_classes(self):
    
    query = self.session.query(MolecularFormulaLink.classe.distinct().label(&#34;classe&#34;))
    
    return query.all()  </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolForm_SQL.get_dict_by_classes"><code class="name flex">
<span>def <span class="ident">get_dict_by_classes</span></span>(<span>self, classes, ion_type, nominal_mzs, ion_charge, molecular_search_settings, adducts=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Known issue, when using SQLite:
if the number of classes and nominal_m/zs are higher than 999 the query will fail
Solution: use postgres or split query</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dict_by_classes(self, classes, ion_type, nominal_mzs, ion_charge, molecular_search_settings, adducts=None):
                                
    &#39;&#39;&#39;Known issue, when using SQLite:
     if the number of classes and nominal_m/zs are higher than 999 the query will fail
     Solution: use postgres or split query&#39;&#39;&#39; 
    def query_normal(class_list, len_adduct):
        
        base_query = self.session.query(MolecularFormulaLink, CarbonHydrogen, HeteroAtoms)\
                            .filter(MolecularFormulaLink.carbonHydrogen_id == CarbonHydrogen.id)\
                            .filter(MolecularFormulaLink.heteroAtoms_id == HeteroAtoms.id)
        
        return base_query.filter(
            and_(
                HeteroAtoms.name.in_(class_list), 
                and_(
                    MolecularFormulaLink.DBE &gt;= molecular_search_settings.min_dbe, 
                    MolecularFormulaLink.DBE &lt;= molecular_search_settings.max_dbe, 
                    and_(
                        ((CarbonHydrogen.h + HeteroAtoms.halogens_count - len_adduct) / CarbonHydrogen.c) &gt;= molecular_search_settings.min_hc_filter,
                        ((CarbonHydrogen.h + HeteroAtoms.halogens_count - len_adduct) / CarbonHydrogen.c) &lt;= molecular_search_settings.max_hc_filter,
                        CarbonHydrogen.C &gt;= molecular_search_settings.usedAtoms.get(&#34;C&#34;)[0],
                        CarbonHydrogen.c &lt;= molecular_search_settings.usedAtoms.get(&#34;C&#34;)[1],
                        CarbonHydrogen.h &gt;= molecular_search_settings.usedAtoms.get(&#34;H&#34;)[0],
                        CarbonHydrogen.h &lt;= molecular_search_settings.usedAtoms.get(&#34;H&#34;)[1],
                    )
                )
            )
        )

    def add_dict_formula(formulas, ion_type, ion_charge, adduct_atom=None):
        &#34;organize data by heteroatom classes&#34;
        dict_res = {}

        def nominal_mass_by_ion_type(formula_obj):
            
            if ion_type == Labels.protonated_de_ion:
            
                return int(formula_obj.protonated_mass(ion_charge))
            
            elif ion_type == Labels.radical_ion:
                
                return int(formula_obj.radical_mass(ion_charge))

            elif ion_type == Labels.adduct_ion and adduct_atom:
                
                return int(formula_obj.adduct_mass(ion_charge, adduct_atom))
        
        for formula_obj, ch_obj, classe_obj  in tqdm.tqdm(formulas, desc=&#34;Loading molecular formula database&#34;):
            
            nominal_mz = nominal_mass_by_ion_type(formula_obj)
            
            if self.type != &#39;normal&#39;:
                if not nominal_mz in nominal_mzs:
                    continue
            classe = classe_obj.name

            #classe_str = formula.classe_string
            
            #pbar.set_description_str(desc=&#34;Loading molecular formula database for class %s &#34; % classe_str)
            
            formula_dict = formula_obj.formula_dict

            if formula_dict.get(&#34;O&#34;):
                
                if formula_dict.get(&#34;O&#34;)/formula_dict.get(&#34;C&#34;) &gt;= molecular_search_settings.min_oc_filter:
                    #print(formula_dict.get(&#34;O&#34;)/formula_dict.get(&#34;C&#34;))
                    continue

                #if formula_dict.get(&#34;P&#34;):

                #    if  not (formula_dict.get(&#34;O&#34;) -2)/ formula_dict.get(&#34;P&#34;) &gt;= molecular_search_settings.min_op_filter:
                        
                #        continue
    
            if classe in dict_res.keys():
                
                if nominal_mz in dict_res[classe].keys():
                    
                    dict_res.get(classe).get(nominal_mz).append(formula_obj)
                
                else:

                    dict_res.get(classe)[nominal_mz] = [formula_obj ]  
        
            else:
                
                dict_res[classe] = {nominal_mz: [formula_obj] }     
        
        return dict_res
    
    
    len_adducts = 0
    if ion_type == Labels.adduct_ion:
        len_adducts = 1
    
    query = query_normal(classes, len_adducts)

    if ion_type == Labels.protonated_de_ion:
        if self.type == &#39;normal&#39;:
            query = query.filter(and_(
                            MolecularFormulaLink.protonated_mass(ion_charge).cast(Integer).in_(nominal_mzs)
                            ))
        return add_dict_formula(query, ion_type, ion_charge)
    
    if ion_type == Labels.radical_ion:
        if self.type == &#39;normal&#39;:
            query = query.filter(MolecularFormulaLink.radical_mass(ion_charge).cast(Integer).in_(nominal_mzs))    
        return add_dict_formula(query, ion_type, ion_charge)
    
    if ion_type == Labels.adduct_ion:
        dict_res = {}
        if adducts: 
            for atom in adducts:
                if self.type == &#39;normal&#39;:
                    query = query.filter(MolecularFormulaLink.adduct_mass(ion_charge, atom).cast(Integer).in_(nominal_mzs))    
                dict_res[atom] = add_dict_formula(query, ion_type, ion_charge, adduct_atom=atom)
            return dict_res
    # dump all objs to memory
    self.session.expunge_all()</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolForm_SQL.init_engine"><code class="name flex">
<span>def <span class="ident">init_engine</span></span>(<span>self, url)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_engine(self, url):
    
    if not url or url == &#39;None&#39; or url == &#39;False&#39;:
        directory = os.getcwd()
        
        if not os.path.isdir(directory+&#39;/db&#39;):  os.mkdir(directory+&#39;/db&#39;)
        
        url = &#39;sqlite:///{DB}/db/molformulas.sqlite&#39;.format(DB=directory)

    if url[0:6] == &#39;sqlite&#39;:
        self.type = &#39;sqlite&#39;
    else:
        self.type = &#39;normal&#39;
        
    if url[0:6] == &#39;sqlite&#39;:
        engine = create_engine(url, echo = False)
        self.chunks_count = 50
    
    elif url[0:10] == &#39;postgresql&#39; or url[0:8] == &#39;postgres&#39;:
        #postgresql
        self.chunks_count = 50000
        engine = create_engine(url, echo = False, isolation_level=&#34;AUTOCOMMIT&#34;)
    
    return engine# poolclass=NullPool</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolForm_SQL.initiate_database"><code class="name flex">
<span>def <span class="ident">initiate_database</span></span>(<span>self, url, database_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initiate_database(self, url, database_name):  #CREATION
    
    engine = sqlalchemy.create_engine(database_url)
    conn = engine.connect()
    conn.execute(&#34;commit&#34;)
    conn.execute(&#34;create database &#34;+database_name)
    conn.close()</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolForm_SQL.purge"><code class="name flex">
<span>def <span class="ident">purge</span></span>(<span>self, cls)</span>
</code></dt>
<dd>
<div class="desc"><p>Carefull, this will delete the entire database table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def purge(self, cls):
    &#39;&#39;&#39;Carefull, this will delete the entire database table&#39;&#39;&#39;
    self.session.query(cls).delete()
    self.session.commit()  </code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink"><code class="flex name class">
<span>class <span class="ident">MolecularFormulaLink</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The most base type</p>
<p>A simple constructor that allows initialization from kwargs.</p>
<p>Sets attributes on the constructed instance using the names and
values in <code>kwargs</code>.</p>
<p>Only keys that are present as
attributes of the instance's class are allowed. These could be,
for example, any mapped columns or relationships.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MolecularFormulaLink(Base):
    
    __tablename__ = &#39;molecularformula&#39;
    __table_args__ = ( UniqueConstraint(&#39;heteroAtoms_id&#39;, &#39;carbonHydrogen_id&#39;, name=&#39;unique_molform&#39;), )
    
    #id = Column(Integer, primary_key=True,
    #                    unique=True,
    #                    nullable=False)

    heteroAtoms_id = Column(
        Integer, 
        ForeignKey(&#39;heteroAtoms.id&#39;), 
        primary_key=True)

    carbonHydrogen_id = Column(
        Integer, 
        ForeignKey(&#39;carbonHydrogen.id&#39;), 
        primary_key=True)
    
    mass = Column(Float)
    
    DBE = Column(Float)
    
    carbonHydrogen = relationship(CarbonHydrogen, backref=backref(&#34;heteroAtoms_assoc&#34;))
    
    heteroAtoms = relationship(HeteroAtoms, backref=backref(&#34;carbonHydrogen_assoc&#34;))
    
    C = association_proxy(&#39;carbonHydrogen&#39;, &#39;C&#39;)

    H = association_proxy(&#39;carbonHydrogen&#39;, &#39;H&#39;)

    classe = association_proxy(&#39;heteroAtoms&#39;, &#39;name&#39;)

    @property
    def formula_dict(self):
        
        carbon = {&#39;C&#39;: self.C, &#39;H&#39;: self.H}
        classe = json.loads(self.classe)
        if self.classe == &#39;{&#34;HC&#34;: &#34;&#34;}&#39;:
            return {**carbon}
        else:
            return {**carbon, **classe}

    @property
    def formula_string(self):
        class_dict = self.formula_dict 
        class_str = &#39; &#39;.join([atom + str(class_dict[atom]) for atom in class_dict.keys()])
        return class_str.strip()

    @property
    def classe_string(self):
        class_dict = json.loads(self.classe)
        class_str = &#39; &#39;.join([atom + str(class_dict[atom]) for atom in class_dict.keys()])
        return class_str.strip()

    @hybrid_method
    def adduct_mass(self, ion_charge, adduct_atom):
        return (self.mass + (Atoms.atomic_masses.get(adduct_atom)) + (ion_charge * -1 * Atoms.electron_mass))/ abs(ion_charge)

    @hybrid_method
    def protonated_mass(self, ion_charge):
        return (self.mass + (ion_charge * Atoms.atomic_masses.get(&#34;H&#34;)) + (ion_charge * -1 * Atoms.electron_mass))/abs(ion_charge)
    
    @hybrid_method
    def radical_mass(self, ion_charge):
        return (self.mass + (ion_charge * -1 * Atoms.electron_mass))/ abs(ion_charge)

    def __repr__(self):
        
        return &#39;&lt;MolecularFormulaLink Model {}&gt;&#39;.format(self.formula_string)       </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sqlalchemy.ext.declarative.api.Base</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.C"><code class="name">var <span class="ident">C</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.H"><code class="name">var <span class="ident">H</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.classe"><code class="name">var <span class="ident">classe</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.adduct_mass"><code class="name flex">
<span>def <span class="ident">adduct_mass</span></span>(<span>ion_charge, adduct_atom)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@hybrid_method
def adduct_mass(self, ion_charge, adduct_atom):
    return (self.mass + (Atoms.atomic_masses.get(adduct_atom)) + (ion_charge * -1 * Atoms.electron_mass))/ abs(ion_charge)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.protonated_mass"><code class="name flex">
<span>def <span class="ident">protonated_mass</span></span>(<span>ion_charge)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@hybrid_method
def protonated_mass(self, ion_charge):
    return (self.mass + (ion_charge * Atoms.atomic_masses.get(&#34;H&#34;)) + (ion_charge * -1 * Atoms.electron_mass))/abs(ion_charge)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.radical_mass"><code class="name flex">
<span>def <span class="ident">radical_mass</span></span>(<span>ion_charge)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@hybrid_method
def radical_mass(self, ion_charge):
    return (self.mass + (ion_charge * -1 * Atoms.electron_mass))/ abs(ion_charge)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.DBE"><code class="name">var <span class="ident">DBE</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.carbonHydrogen"><code class="name">var <span class="ident">carbonHydrogen</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.carbonHydrogen_id"><code class="name">var <span class="ident">carbonHydrogen_id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.classe_string"><code class="name">var <span class="ident">classe_string</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def classe_string(self):
    class_dict = json.loads(self.classe)
    class_str = &#39; &#39;.join([atom + str(class_dict[atom]) for atom in class_dict.keys()])
    return class_str.strip()</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.formula_dict"><code class="name">var <span class="ident">formula_dict</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def formula_dict(self):
    
    carbon = {&#39;C&#39;: self.C, &#39;H&#39;: self.H}
    classe = json.loads(self.classe)
    if self.classe == &#39;{&#34;HC&#34;: &#34;&#34;}&#39;:
        return {**carbon}
    else:
        return {**carbon, **classe}</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.formula_string"><code class="name">var <span class="ident">formula_string</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def formula_string(self):
    class_dict = self.formula_dict 
    class_str = &#39; &#39;.join([atom + str(class_dict[atom]) for atom in class_dict.keys()])
    return class_str.strip()</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.heteroAtoms"><code class="name">var <span class="ident">heteroAtoms</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.heteroAtoms_id"><code class="name">var <span class="ident">heteroAtoms_id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.mass"><code class="name">var <span class="ident">mass</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.molecular_id.factory" href="index.html">corems.molecular_id.factory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="corems.molecular_id.factory.molecularSQL.and_" href="#corems.molecular_id.factory.molecularSQL.and_">and_</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="corems.molecular_id.factory.molecularSQL.CarbonHydrogen" href="#corems.molecular_id.factory.molecularSQL.CarbonHydrogen">CarbonHydrogen</a></code></h4>
<ul class="two-column">
<li><code><a title="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.C" href="#corems.molecular_id.factory.molecularSQL.CarbonHydrogen.C">C</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.H" href="#corems.molecular_id.factory.molecularSQL.CarbonHydrogen.H">H</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.c" href="#corems.molecular_id.factory.molecularSQL.CarbonHydrogen.c">c</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.dbe" href="#corems.molecular_id.factory.molecularSQL.CarbonHydrogen.dbe">dbe</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.h" href="#corems.molecular_id.factory.molecularSQL.CarbonHydrogen.h">h</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.heteroAtoms" href="#corems.molecular_id.factory.molecularSQL.CarbonHydrogen.heteroAtoms">heteroAtoms</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.id" href="#corems.molecular_id.factory.molecularSQL.CarbonHydrogen.id">id</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.CarbonHydrogen.mass" href="#corems.molecular_id.factory.molecularSQL.CarbonHydrogen.mass">mass</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="corems.molecular_id.factory.molecularSQL.HeteroAtoms" href="#corems.molecular_id.factory.molecularSQL.HeteroAtoms">HeteroAtoms</a></code></h4>
<ul class="two-column">
<li><code><a title="corems.molecular_id.factory.molecularSQL.HeteroAtoms.carbonHydrogen" href="#corems.molecular_id.factory.molecularSQL.HeteroAtoms.carbonHydrogen">carbonHydrogen</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.HeteroAtoms.halogensCount" href="#corems.molecular_id.factory.molecularSQL.HeteroAtoms.halogensCount">halogensCount</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.HeteroAtoms.halogens_count" href="#corems.molecular_id.factory.molecularSQL.HeteroAtoms.halogens_count">halogens_count</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.HeteroAtoms.id" href="#corems.molecular_id.factory.molecularSQL.HeteroAtoms.id">id</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.HeteroAtoms.name" href="#corems.molecular_id.factory.molecularSQL.HeteroAtoms.name">name</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.HeteroAtoms.to_dict" href="#corems.molecular_id.factory.molecularSQL.HeteroAtoms.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="corems.molecular_id.factory.molecularSQL.MolForm_SQL" href="#corems.molecular_id.factory.molecularSQL.MolForm_SQL">MolForm_SQL</a></code></h4>
<ul class="two-column">
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolForm_SQL.add_engine_pidguard" href="#corems.molecular_id.factory.molecularSQL.MolForm_SQL.add_engine_pidguard">add_engine_pidguard</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolForm_SQL.check_entry" href="#corems.molecular_id.factory.molecularSQL.MolForm_SQL.check_entry">check_entry</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolForm_SQL.clear_data" href="#corems.molecular_id.factory.molecularSQL.MolForm_SQL.clear_data">clear_data</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolForm_SQL.close" href="#corems.molecular_id.factory.molecularSQL.MolForm_SQL.close">close</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolForm_SQL.commit" href="#corems.molecular_id.factory.molecularSQL.MolForm_SQL.commit">commit</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolForm_SQL.delete_entry" href="#corems.molecular_id.factory.molecularSQL.MolForm_SQL.delete_entry">delete_entry</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolForm_SQL.get_all" href="#corems.molecular_id.factory.molecularSQL.MolForm_SQL.get_all">get_all</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolForm_SQL.get_all_classes" href="#corems.molecular_id.factory.molecularSQL.MolForm_SQL.get_all_classes">get_all_classes</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolForm_SQL.get_dict_by_classes" href="#corems.molecular_id.factory.molecularSQL.MolForm_SQL.get_dict_by_classes">get_dict_by_classes</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolForm_SQL.init_engine" href="#corems.molecular_id.factory.molecularSQL.MolForm_SQL.init_engine">init_engine</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolForm_SQL.initiate_database" href="#corems.molecular_id.factory.molecularSQL.MolForm_SQL.initiate_database">initiate_database</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolForm_SQL.purge" href="#corems.molecular_id.factory.molecularSQL.MolForm_SQL.purge">purge</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink">MolecularFormulaLink</a></code></h4>
<ul class="two-column">
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.C" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.C">C</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.DBE" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.DBE">DBE</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.H" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.H">H</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.adduct_mass" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.adduct_mass">adduct_mass</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.carbonHydrogen" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.carbonHydrogen">carbonHydrogen</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.carbonHydrogen_id" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.carbonHydrogen_id">carbonHydrogen_id</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.classe" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.classe">classe</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.classe_string" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.classe_string">classe_string</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.formula_dict" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.formula_dict">formula_dict</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.formula_string" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.formula_string">formula_string</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.heteroAtoms" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.heteroAtoms">heteroAtoms</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.heteroAtoms_id" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.heteroAtoms_id">heteroAtoms_id</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.mass" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.mass">mass</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.protonated_mass" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.protonated_mass">protonated_mass</a></code></li>
<li><code><a title="corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.radical_mass" href="#corems.molecular_id.factory.molecularSQL.MolecularFormulaLink.radical_mass">radical_mass</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>