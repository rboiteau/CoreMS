<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.molecular_id.search.findOxygenPeaks API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.molecular_id.search.findOxygenPeaks</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__author__ = &#34;Yuri E. Corilo&#34;
__date__ = &#34;Jul 31, 2019&#34;

from copy import deepcopy
from threading import Thread
from numpy import average, std
from corems.molecular_id.calc.ClusterFilter import ClusteringFilter
from corems.molecular_id.search.molecularFormulaSearch import SearchMolecularFormulas
from corems.molecular_id.factory.molecularSQL import MolForm_SQL 
from tqdm import tqdm

class FindOxygenPeaks(Thread):
    
    &#39;&#39;&#39;
        Class to walk 14Da units over oxygen space for negative ion mass spectrum of natural organic matter
        Returns a list of MSPeak class containing the possible Molecular Formula class objects.  
        
        Parameters
        ----------
        mass_spectrum_obj : MassSpec class
            This is where we store MassSpec class obj,   
        
        lookupTableSettings:  MolecularLookupTableSettings class
            This is where we store MolecularLookupTableSettings class obj
        
        min_O , max_O : int
            minium and maximum of Oxygen to allow the software to look for
            it will override the settings at lookupTableSettings.usedAtoms
            default min = 1, max = 30

        Attributes
        ----------
        mass_spectrum_obj : MassSpec class
            This is where we store MassSpec class obj,   
        lookupTableSettings:  MolecularLookupTableSettings class
            This is where we store MolecularLookupTableSettings class obj
        
        Methods
        ----------
            run()    
                will be called when the instantiated class method start is called
            get_list_found_peaks()
                returns a list of MSpeaks classes cotaining all the MolecularFormula candidates inside the MSPeak
                for more details of the structure see MSPeak class and MolecularFormula class    
            set_mass_spec_indexes_by_found_peaks()
                set the mass spectrum to interate over only the selected indexes
    &#39;&#39;&#39;
    def __init__(self, mass_spectrum_obj, sql_db=False, min_O = 1, max_O = 22) :
        
        Thread.__init__(self)
        
        self.mass_spectrum_obj = mass_spectrum_obj
        self.min_0 = min_O
        self.max_O = max_O
        
        if not sql_db:
            
            self.sql_db = MolForm_SQL(mass_spectrum_obj.molecular_search_settings.url_database)
        else:

            self.sql_db = sql_db    
    
    def run(self):
        
        #save initial settings min peaks per class filter 
        initial_min_peak_bool = deepcopy(self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter)

        #deactivate the usage of min peaks per class filter
        self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter = False

        #save initial settings for Ox 
        initial_ox = deepcopy(self.mass_spectrum_obj.molecular_search_settings.usedAtoms[&#39;O&#39;])

        #resets the used atoms to look only for oxygen organic compounds
        self.mass_spectrum_obj.molecular_search_settings.usedAtoms[&#39;O&#39;] =  (self.min_0, self.max_O)
        
        self.list_found_mspeaks = []

        kdm_base = self.mass_spectrum_obj.mspeaks_settings.kendrick_base
        
        self.mass_spectrum_obj.change_kendrick_base_all_mspeaks(kdm_base)
        
        # needs to be wrapped inside the mass_spec class
        ClusteringFilter().filter_kendrick(self.mass_spectrum_obj)
        
        print(&#34;Start most abundant mass spectral peak search&#34;) 
        molecular_formula_obj_reference = self.find_most_abundant_formula(self.mass_spectrum_obj)
        
        print(&#34;Select most abundant peak with molecular formula =  %s with a m/z error of %s ppm&#34; % (molecular_formula_obj_reference.string, molecular_formula_obj_reference.mz_error))
        
        print(&#34;Started mass spectral peak series search&#34;)

        self.list_found_mspeaks = self.find_series_mspeaks(self.mass_spectrum_obj,
                                                           molecular_formula_obj_reference, 
                                                           deltamz=14)
        
        # reset indexes after done with operation that includes a filter (i.e. ClusteringFilter().filter_kendrick())
        
        self.mass_spectrum_obj.molecular_search_settings.usedAtoms[&#39;O&#39;] =  initial_ox
        
        self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter = initial_min_peak_bool
        
        self.mass_spectrum_obj.reset_indexes()

        self.mass_spectrum_obj.filter_by_noise_threshold()
        
        print(&#34;Done with mass spectral peak series search&#34;)

        self.sql_db.close()

    def find_most_abundant_formula(self, mass_spectrum_obj):
        &#39;&#39;&#39;
        find most abundant using kendrick 
        
        Returns
        ----------
        MolecularFormula class obj
            most abundant MolecularFormula with the lowest mass error
        &#39;&#39;&#39;
        #need to find a better way to cut off outliners
        #import matplotlib.pyplot as plt
        #plt.hist(mass_spectrum_obj.abundance, bins=100)
        #plt.show()
        
        abundances =  mass_spectrum_obj.abundance
        abun_mean = average(abundances, axis=0)
        abun_std = std(abundances, axis=0)
        
        upper_limit = abun_mean + 7* abun_std
        
        print(&#34;Maximum abundance limit  = %s and max abundance kendrick cluster = %s&#34;  % (upper_limit, max(mass_spectrum_obj, key=lambda m: m.abundance).abundance))
        
        mspeak_most_abundant = max(mass_spectrum_obj, key=lambda m: m.abundance if m.abundance &lt;= upper_limit else 0)

        print(&#34;Searching molecular formulas&#34;)

        SearchMolecularFormulas(mass_spectrum_obj, self.sql_db).run_worker_ms_peaks([mspeak_most_abundant])
        
        print(&#34;Finished searching molecular formulas&#34;)

        if mspeak_most_abundant:

            return mspeak_most_abundant.best_molecular_formula_candidate
        
        else:
        
            raise Exception(&#34;Could not find a possible molecular formula match for the most abundant peak of m/z %.5f&#34;%mspeak_most_abundant.mz_exp )
        
        #return the first option
        #return mspeak_most_abundant[0]

    def find_most_abundant_formula_test(self, mass_spectrum_obj, settings):
        
        #this function is intended for test only. 
        # Have to sort by Kendrick to be able to select the most abundant series 
        #then select the most abundant peak inside the series
        #or have the user select the reference mspeak on the gui

        mspeak_most_abundant = mass_spectrum_obj.most_abundant_mspeak

        SearchMolecularFormulas(mass_spectrum_obj, self.sql_db).run_worker_ms_peaks([mspeak_most_abundant])
        
        if mspeak_most_abundant:

            return mspeak_most_abundant.best_molecular_formula_candidate 
            
        else:
            raise Exception(&#34;Could not find a possible molecular formula match for the most abundant peak of m/z %.5f&#34;%mspeak_most_abundant.mz_exp )
        #return the first option
        #return mspeak_most_abundant[0]
    
    def find_series_mspeaks(self, mass_spectrum_obj, molecular_formula_obj_reference, deltamz=14):

        abundances =  mass_spectrum_obj.abundance
        abun_mean = average(abundances, axis=0)
        abun_std = std(abundances, axis=0)
        upper_limit = abun_mean + 7* abun_std
       
        list_most_abundant_peaks = list()

        min_mz = mass_spectrum_obj.min_mz_exp
        
        max_mz = mass_spectrum_obj.max_mz_exp
        
        initial_nominal_mass = molecular_formula_obj_reference.mz_nominal_calc
        
        mass = initial_nominal_mass
        
        nominal_masses = []
        while mass &lt;= max_mz:
            #print &#34;shit 1&#34;, mass, min_mz
            mass += (deltamz) 
            nominal_masses.append(mass)
        
        mass = initial_nominal_mass    
        while mass &gt;= min_mz:
            #print &#34;shit 1&#34;, mass, min_mz
            mass -= (deltamz) 
            nominal_masses.append(mass)
        
        nominal_masses = sorted(nominal_masses)
        
        for nominal_mass in nominal_masses:
            
            first_index, last_index = mass_spectrum_obj.get_nominal_mz_first_last_indexes(nominal_mass)
            
            ms_peaks = mass_spectrum_obj[first_index:last_index]
            
            if ms_peaks:   
                &#39;&#39;&#39;    
                print (nominal_mass, first_index, 
                    last_index, 
                    mass_spectrum_obj[first_index].mz_exp,
                    mass_spectrum_obj[last_index].mz_exp
                    )
                &#39;&#39;&#39;
                
                mspeak_most_abundant = max(ms_peaks, key=lambda m: m.abundance if m.abundance &lt;= upper_limit else 0)

                #mspeak_most_abundant = max(ms_peaks, key=lambda m: m.abundance)
                
                list_most_abundant_peaks.append(mspeak_most_abundant)
        
        print(&#39;Start molecular formula search&#39;)
        SearchMolecularFormulas(mass_spectrum_obj, self.sql_db).run_worker_ms_peaks(list_most_abundant_peaks)
        print(&#39;Done molecular formula search&#39;)
        return [mspeak for mspeak in list_most_abundant_peaks if mspeak]            
                
    
    def get_list_found_peaks(self):
        
        return sorted(self.list_found_mspeaks, key=lambda mp: mp.mz_exp)

    def set_mass_spec_indexes_by_found_peaks(self):
        
        &#39;&#39;&#39;
        Warning!!!!
        set the mass spectrum to interate over only the selected indexes
        don not forget to call mass_spectrum_obj.reset_indexes after the job is done
        &#39;&#39;&#39;
        
        indexes = [msp.index for msp in self.list_found_mspeaks]
        self.mass_spectrum_obj.set_indexes(indexes)
        
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks"><code class="flex name class">
<span>class <span class="ident">FindOxygenPeaks</span></span>
<span>(</span><span>mass_spectrum_obj, sql_db=False, min_O=1, max_O=22)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to walk 14Da units over oxygen space for negative ion mass spectrum of natural organic matter
Returns a list of MSPeak class containing the possible Molecular Formula class objects.
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mass_spectrum_obj</code></strong> :&ensp;<code>MassSpec class</code></dt>
<dd>This is where we store MassSpec class obj,</dd>
<dt><strong><code>lookupTableSettings</code></strong> :&ensp;<code> MolecularLookupTableSettings class</code></dt>
<dd>This is where we store MolecularLookupTableSettings class obj</dd>
</dl>
<p>min_O , max_O : int
minium and maximum of Oxygen to allow the software to look for
it will override the settings at lookupTableSettings.usedAtoms
default min = 1, max = 30</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>mass_spectrum_obj</code></strong> :&ensp;<code>MassSpec class</code></dt>
<dd>This is where we store MassSpec class obj,</dd>
<dt><strong><code>lookupTableSettings</code></strong> :&ensp;<code> MolecularLookupTableSettings class</code></dt>
<dd>This is where we store MolecularLookupTableSettings class obj</dd>
</dl>
<h2 id="methods">Methods</h2>
<pre><code>run()    
    will be called when the instantiated class method start is called
get_list_found_peaks()
    returns a list of MSpeaks classes cotaining all the MolecularFormula candidates inside the MSPeak
    for more details of the structure see MSPeak class and MolecularFormula class    
set_mass_spec_indexes_by_found_peaks()
    set the mass spectrum to interate over only the selected indexes
</code></pre>
<p>This constructor should always be called with keyword arguments. Arguments are:</p>
<p><em>group</em> should be None; reserved for future extension when a ThreadGroup
class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the run()
method. Defaults to None, meaning nothing is called.</p>
<p><em>name</em> is the thread name. By default, a unique name is constructed of
the form "Thread-N" where N is a small decimal number.</p>
<p><em>args</em> is the argument tuple for the target invocation. Defaults to ().</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target
invocation. Defaults to {}.</p>
<p>If a subclass overrides the constructor, it must make sure to invoke
the base class constructor (Thread.<strong>init</strong>()) before doing anything
else to the thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FindOxygenPeaks(Thread):
    
    &#39;&#39;&#39;
        Class to walk 14Da units over oxygen space for negative ion mass spectrum of natural organic matter
        Returns a list of MSPeak class containing the possible Molecular Formula class objects.  
        
        Parameters
        ----------
        mass_spectrum_obj : MassSpec class
            This is where we store MassSpec class obj,   
        
        lookupTableSettings:  MolecularLookupTableSettings class
            This is where we store MolecularLookupTableSettings class obj
        
        min_O , max_O : int
            minium and maximum of Oxygen to allow the software to look for
            it will override the settings at lookupTableSettings.usedAtoms
            default min = 1, max = 30

        Attributes
        ----------
        mass_spectrum_obj : MassSpec class
            This is where we store MassSpec class obj,   
        lookupTableSettings:  MolecularLookupTableSettings class
            This is where we store MolecularLookupTableSettings class obj
        
        Methods
        ----------
            run()    
                will be called when the instantiated class method start is called
            get_list_found_peaks()
                returns a list of MSpeaks classes cotaining all the MolecularFormula candidates inside the MSPeak
                for more details of the structure see MSPeak class and MolecularFormula class    
            set_mass_spec_indexes_by_found_peaks()
                set the mass spectrum to interate over only the selected indexes
    &#39;&#39;&#39;
    def __init__(self, mass_spectrum_obj, sql_db=False, min_O = 1, max_O = 22) :
        
        Thread.__init__(self)
        
        self.mass_spectrum_obj = mass_spectrum_obj
        self.min_0 = min_O
        self.max_O = max_O
        
        if not sql_db:
            
            self.sql_db = MolForm_SQL(mass_spectrum_obj.molecular_search_settings.url_database)
        else:

            self.sql_db = sql_db    
    
    def run(self):
        
        #save initial settings min peaks per class filter 
        initial_min_peak_bool = deepcopy(self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter)

        #deactivate the usage of min peaks per class filter
        self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter = False

        #save initial settings for Ox 
        initial_ox = deepcopy(self.mass_spectrum_obj.molecular_search_settings.usedAtoms[&#39;O&#39;])

        #resets the used atoms to look only for oxygen organic compounds
        self.mass_spectrum_obj.molecular_search_settings.usedAtoms[&#39;O&#39;] =  (self.min_0, self.max_O)
        
        self.list_found_mspeaks = []

        kdm_base = self.mass_spectrum_obj.mspeaks_settings.kendrick_base
        
        self.mass_spectrum_obj.change_kendrick_base_all_mspeaks(kdm_base)
        
        # needs to be wrapped inside the mass_spec class
        ClusteringFilter().filter_kendrick(self.mass_spectrum_obj)
        
        print(&#34;Start most abundant mass spectral peak search&#34;) 
        molecular_formula_obj_reference = self.find_most_abundant_formula(self.mass_spectrum_obj)
        
        print(&#34;Select most abundant peak with molecular formula =  %s with a m/z error of %s ppm&#34; % (molecular_formula_obj_reference.string, molecular_formula_obj_reference.mz_error))
        
        print(&#34;Started mass spectral peak series search&#34;)

        self.list_found_mspeaks = self.find_series_mspeaks(self.mass_spectrum_obj,
                                                           molecular_formula_obj_reference, 
                                                           deltamz=14)
        
        # reset indexes after done with operation that includes a filter (i.e. ClusteringFilter().filter_kendrick())
        
        self.mass_spectrum_obj.molecular_search_settings.usedAtoms[&#39;O&#39;] =  initial_ox
        
        self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter = initial_min_peak_bool
        
        self.mass_spectrum_obj.reset_indexes()

        self.mass_spectrum_obj.filter_by_noise_threshold()
        
        print(&#34;Done with mass spectral peak series search&#34;)

        self.sql_db.close()

    def find_most_abundant_formula(self, mass_spectrum_obj):
        &#39;&#39;&#39;
        find most abundant using kendrick 
        
        Returns
        ----------
        MolecularFormula class obj
            most abundant MolecularFormula with the lowest mass error
        &#39;&#39;&#39;
        #need to find a better way to cut off outliners
        #import matplotlib.pyplot as plt
        #plt.hist(mass_spectrum_obj.abundance, bins=100)
        #plt.show()
        
        abundances =  mass_spectrum_obj.abundance
        abun_mean = average(abundances, axis=0)
        abun_std = std(abundances, axis=0)
        
        upper_limit = abun_mean + 7* abun_std
        
        print(&#34;Maximum abundance limit  = %s and max abundance kendrick cluster = %s&#34;  % (upper_limit, max(mass_spectrum_obj, key=lambda m: m.abundance).abundance))
        
        mspeak_most_abundant = max(mass_spectrum_obj, key=lambda m: m.abundance if m.abundance &lt;= upper_limit else 0)

        print(&#34;Searching molecular formulas&#34;)

        SearchMolecularFormulas(mass_spectrum_obj, self.sql_db).run_worker_ms_peaks([mspeak_most_abundant])
        
        print(&#34;Finished searching molecular formulas&#34;)

        if mspeak_most_abundant:

            return mspeak_most_abundant.best_molecular_formula_candidate
        
        else:
        
            raise Exception(&#34;Could not find a possible molecular formula match for the most abundant peak of m/z %.5f&#34;%mspeak_most_abundant.mz_exp )
        
        #return the first option
        #return mspeak_most_abundant[0]

    def find_most_abundant_formula_test(self, mass_spectrum_obj, settings):
        
        #this function is intended for test only. 
        # Have to sort by Kendrick to be able to select the most abundant series 
        #then select the most abundant peak inside the series
        #or have the user select the reference mspeak on the gui

        mspeak_most_abundant = mass_spectrum_obj.most_abundant_mspeak

        SearchMolecularFormulas(mass_spectrum_obj, self.sql_db).run_worker_ms_peaks([mspeak_most_abundant])
        
        if mspeak_most_abundant:

            return mspeak_most_abundant.best_molecular_formula_candidate 
            
        else:
            raise Exception(&#34;Could not find a possible molecular formula match for the most abundant peak of m/z %.5f&#34;%mspeak_most_abundant.mz_exp )
        #return the first option
        #return mspeak_most_abundant[0]
    
    def find_series_mspeaks(self, mass_spectrum_obj, molecular_formula_obj_reference, deltamz=14):

        abundances =  mass_spectrum_obj.abundance
        abun_mean = average(abundances, axis=0)
        abun_std = std(abundances, axis=0)
        upper_limit = abun_mean + 7* abun_std
       
        list_most_abundant_peaks = list()

        min_mz = mass_spectrum_obj.min_mz_exp
        
        max_mz = mass_spectrum_obj.max_mz_exp
        
        initial_nominal_mass = molecular_formula_obj_reference.mz_nominal_calc
        
        mass = initial_nominal_mass
        
        nominal_masses = []
        while mass &lt;= max_mz:
            #print &#34;shit 1&#34;, mass, min_mz
            mass += (deltamz) 
            nominal_masses.append(mass)
        
        mass = initial_nominal_mass    
        while mass &gt;= min_mz:
            #print &#34;shit 1&#34;, mass, min_mz
            mass -= (deltamz) 
            nominal_masses.append(mass)
        
        nominal_masses = sorted(nominal_masses)
        
        for nominal_mass in nominal_masses:
            
            first_index, last_index = mass_spectrum_obj.get_nominal_mz_first_last_indexes(nominal_mass)
            
            ms_peaks = mass_spectrum_obj[first_index:last_index]
            
            if ms_peaks:   
                &#39;&#39;&#39;    
                print (nominal_mass, first_index, 
                    last_index, 
                    mass_spectrum_obj[first_index].mz_exp,
                    mass_spectrum_obj[last_index].mz_exp
                    )
                &#39;&#39;&#39;
                
                mspeak_most_abundant = max(ms_peaks, key=lambda m: m.abundance if m.abundance &lt;= upper_limit else 0)

                #mspeak_most_abundant = max(ms_peaks, key=lambda m: m.abundance)
                
                list_most_abundant_peaks.append(mspeak_most_abundant)
        
        print(&#39;Start molecular formula search&#39;)
        SearchMolecularFormulas(mass_spectrum_obj, self.sql_db).run_worker_ms_peaks(list_most_abundant_peaks)
        print(&#39;Done molecular formula search&#39;)
        return [mspeak for mspeak in list_most_abundant_peaks if mspeak]            
                
    
    def get_list_found_peaks(self):
        
        return sorted(self.list_found_mspeaks, key=lambda mp: mp.mz_exp)

    def set_mass_spec_indexes_by_found_peaks(self):
        
        &#39;&#39;&#39;
        Warning!!!!
        set the mass spectrum to interate over only the selected indexes
        don not forget to call mass_spectrum_obj.reset_indexes after the job is done
        &#39;&#39;&#39;
        
        indexes = [msp.index for msp in self.list_found_mspeaks]
        self.mass_spectrum_obj.set_indexes(indexes)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.find_most_abundant_formula"><code class="name flex">
<span>def <span class="ident">find_most_abundant_formula</span></span>(<span>self, mass_spectrum_obj)</span>
</code></dt>
<dd>
<div class="desc"><p>find most abundant using kendrick </p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>MolecularFormula class obj</code></dt>
<dd>most abundant MolecularFormula with the lowest mass error</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_most_abundant_formula(self, mass_spectrum_obj):
    &#39;&#39;&#39;
    find most abundant using kendrick 
    
    Returns
    ----------
    MolecularFormula class obj
        most abundant MolecularFormula with the lowest mass error
    &#39;&#39;&#39;
    #need to find a better way to cut off outliners
    #import matplotlib.pyplot as plt
    #plt.hist(mass_spectrum_obj.abundance, bins=100)
    #plt.show()
    
    abundances =  mass_spectrum_obj.abundance
    abun_mean = average(abundances, axis=0)
    abun_std = std(abundances, axis=0)
    
    upper_limit = abun_mean + 7* abun_std
    
    print(&#34;Maximum abundance limit  = %s and max abundance kendrick cluster = %s&#34;  % (upper_limit, max(mass_spectrum_obj, key=lambda m: m.abundance).abundance))
    
    mspeak_most_abundant = max(mass_spectrum_obj, key=lambda m: m.abundance if m.abundance &lt;= upper_limit else 0)

    print(&#34;Searching molecular formulas&#34;)

    SearchMolecularFormulas(mass_spectrum_obj, self.sql_db).run_worker_ms_peaks([mspeak_most_abundant])
    
    print(&#34;Finished searching molecular formulas&#34;)

    if mspeak_most_abundant:

        return mspeak_most_abundant.best_molecular_formula_candidate
    
    else:
    
        raise Exception(&#34;Could not find a possible molecular formula match for the most abundant peak of m/z %.5f&#34;%mspeak_most_abundant.mz_exp )</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.find_most_abundant_formula_test"><code class="name flex">
<span>def <span class="ident">find_most_abundant_formula_test</span></span>(<span>self, mass_spectrum_obj, settings)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_most_abundant_formula_test(self, mass_spectrum_obj, settings):
    
    #this function is intended for test only. 
    # Have to sort by Kendrick to be able to select the most abundant series 
    #then select the most abundant peak inside the series
    #or have the user select the reference mspeak on the gui

    mspeak_most_abundant = mass_spectrum_obj.most_abundant_mspeak

    SearchMolecularFormulas(mass_spectrum_obj, self.sql_db).run_worker_ms_peaks([mspeak_most_abundant])
    
    if mspeak_most_abundant:

        return mspeak_most_abundant.best_molecular_formula_candidate 
        
    else:
        raise Exception(&#34;Could not find a possible molecular formula match for the most abundant peak of m/z %.5f&#34;%mspeak_most_abundant.mz_exp )</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.find_series_mspeaks"><code class="name flex">
<span>def <span class="ident">find_series_mspeaks</span></span>(<span>self, mass_spectrum_obj, molecular_formula_obj_reference, deltamz=14)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_series_mspeaks(self, mass_spectrum_obj, molecular_formula_obj_reference, deltamz=14):

    abundances =  mass_spectrum_obj.abundance
    abun_mean = average(abundances, axis=0)
    abun_std = std(abundances, axis=0)
    upper_limit = abun_mean + 7* abun_std
   
    list_most_abundant_peaks = list()

    min_mz = mass_spectrum_obj.min_mz_exp
    
    max_mz = mass_spectrum_obj.max_mz_exp
    
    initial_nominal_mass = molecular_formula_obj_reference.mz_nominal_calc
    
    mass = initial_nominal_mass
    
    nominal_masses = []
    while mass &lt;= max_mz:
        #print &#34;shit 1&#34;, mass, min_mz
        mass += (deltamz) 
        nominal_masses.append(mass)
    
    mass = initial_nominal_mass    
    while mass &gt;= min_mz:
        #print &#34;shit 1&#34;, mass, min_mz
        mass -= (deltamz) 
        nominal_masses.append(mass)
    
    nominal_masses = sorted(nominal_masses)
    
    for nominal_mass in nominal_masses:
        
        first_index, last_index = mass_spectrum_obj.get_nominal_mz_first_last_indexes(nominal_mass)
        
        ms_peaks = mass_spectrum_obj[first_index:last_index]
        
        if ms_peaks:   
            &#39;&#39;&#39;    
            print (nominal_mass, first_index, 
                last_index, 
                mass_spectrum_obj[first_index].mz_exp,
                mass_spectrum_obj[last_index].mz_exp
                )
            &#39;&#39;&#39;
            
            mspeak_most_abundant = max(ms_peaks, key=lambda m: m.abundance if m.abundance &lt;= upper_limit else 0)

            #mspeak_most_abundant = max(ms_peaks, key=lambda m: m.abundance)
            
            list_most_abundant_peaks.append(mspeak_most_abundant)
    
    print(&#39;Start molecular formula search&#39;)
    SearchMolecularFormulas(mass_spectrum_obj, self.sql_db).run_worker_ms_peaks(list_most_abundant_peaks)
    print(&#39;Done molecular formula search&#39;)
    return [mspeak for mspeak in list_most_abundant_peaks if mspeak]            </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.get_list_found_peaks"><code class="name flex">
<span>def <span class="ident">get_list_found_peaks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list_found_peaks(self):
    
    return sorted(self.list_found_mspeaks, key=lambda mp: mp.mz_exp)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method representing the thread's activity.</p>
<p>You may override this method in a subclass. The standard run() method
invokes the callable object passed to the object's constructor as the
target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    
    #save initial settings min peaks per class filter 
    initial_min_peak_bool = deepcopy(self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter)

    #deactivate the usage of min peaks per class filter
    self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter = False

    #save initial settings for Ox 
    initial_ox = deepcopy(self.mass_spectrum_obj.molecular_search_settings.usedAtoms[&#39;O&#39;])

    #resets the used atoms to look only for oxygen organic compounds
    self.mass_spectrum_obj.molecular_search_settings.usedAtoms[&#39;O&#39;] =  (self.min_0, self.max_O)
    
    self.list_found_mspeaks = []

    kdm_base = self.mass_spectrum_obj.mspeaks_settings.kendrick_base
    
    self.mass_spectrum_obj.change_kendrick_base_all_mspeaks(kdm_base)
    
    # needs to be wrapped inside the mass_spec class
    ClusteringFilter().filter_kendrick(self.mass_spectrum_obj)
    
    print(&#34;Start most abundant mass spectral peak search&#34;) 
    molecular_formula_obj_reference = self.find_most_abundant_formula(self.mass_spectrum_obj)
    
    print(&#34;Select most abundant peak with molecular formula =  %s with a m/z error of %s ppm&#34; % (molecular_formula_obj_reference.string, molecular_formula_obj_reference.mz_error))
    
    print(&#34;Started mass spectral peak series search&#34;)

    self.list_found_mspeaks = self.find_series_mspeaks(self.mass_spectrum_obj,
                                                       molecular_formula_obj_reference, 
                                                       deltamz=14)
    
    # reset indexes after done with operation that includes a filter (i.e. ClusteringFilter().filter_kendrick())
    
    self.mass_spectrum_obj.molecular_search_settings.usedAtoms[&#39;O&#39;] =  initial_ox
    
    self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter = initial_min_peak_bool
    
    self.mass_spectrum_obj.reset_indexes()

    self.mass_spectrum_obj.filter_by_noise_threshold()
    
    print(&#34;Done with mass spectral peak series search&#34;)

    self.sql_db.close()</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.set_mass_spec_indexes_by_found_peaks"><code class="name flex">
<span>def <span class="ident">set_mass_spec_indexes_by_found_peaks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Warning!!!!
set the mass spectrum to interate over only the selected indexes
don not forget to call mass_spectrum_obj.reset_indexes after the job is done</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_mass_spec_indexes_by_found_peaks(self):
    
    &#39;&#39;&#39;
    Warning!!!!
    set the mass spectrum to interate over only the selected indexes
    don not forget to call mass_spectrum_obj.reset_indexes after the job is done
    &#39;&#39;&#39;
    
    indexes = [msp.index for msp in self.list_found_mspeaks]
    self.mass_spectrum_obj.set_indexes(indexes)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.molecular_id.search" href="index.html">corems.molecular_id.search</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks" href="#corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks">FindOxygenPeaks</a></code></h4>
<ul class="">
<li><code><a title="corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.find_most_abundant_formula" href="#corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.find_most_abundant_formula">find_most_abundant_formula</a></code></li>
<li><code><a title="corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.find_most_abundant_formula_test" href="#corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.find_most_abundant_formula_test">find_most_abundant_formula_test</a></code></li>
<li><code><a title="corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.find_series_mspeaks" href="#corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.find_series_mspeaks">find_series_mspeaks</a></code></li>
<li><code><a title="corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.get_list_found_peaks" href="#corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.get_list_found_peaks">get_list_found_peaks</a></code></li>
<li><code><a title="corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.run" href="#corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.run">run</a></code></li>
<li><code><a title="corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.set_mass_spec_indexes_by_found_peaks" href="#corems.molecular_id.search.findOxygenPeaks.FindOxygenPeaks.set_mass_spec_indexes_by_found_peaks">set_mass_spec_indexes_by_found_peaks</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>