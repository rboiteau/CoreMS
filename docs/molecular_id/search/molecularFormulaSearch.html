<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.molecular_id.search.molecularFormulaSearch API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.molecular_id.search.molecularFormulaSearch</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__author__ = &#34;Yuri E. Corilo&#34;
__date__ = &#34;Jul 29, 2019&#34;

import multiprocessing

import tqdm
from sqlalchemy.types import Binary
from sqlalchemy.sql.sqltypes import Integer


from corems import chunks, timeit
from corems.encapsulation.constant import Atoms, Labels
from corems.molecular_formula.factory.MolecularFormulaFactory import MolecularFormula
from corems.molecular_id.factory.molecularSQL import MolForm_SQL, MolecularFormulaLink
from corems.molecular_id.calc.ClusterFilter import ClusteringFilter
from corems.molecular_id.calc.MolecularFilter import MolecularFormulaSearchFilters
from corems.molecular_id.factory.MolecularLookupTable import MolecularCombinations
import cProfile


last_error = 0
last_dif = 0
closest_error = 0
error_average = 0
nbValues = 0

class SearchMolecularFormulas:

    &#39;&#39;&#39;
    runworker()
    &#39;&#39;&#39;
    def __init__(self, mass_spectrum_obj, sql_db=None, first_hit=False, find_isotopologues=True):

        self.first_hit = first_hit

        self.find_isotopologues = find_isotopologues

        self.mass_spectrum_obj = mass_spectrum_obj

        if not sql_db:

            self.sql_db = MolForm_SQL(url=mass_spectrum_obj.molecular_search_settings.url_database)

        else:

            self.sql_db = sql_db

    def __enter__(self):

        return self

    def __exit__(self, exc_type, exc_val, exc_tb):

        self.sql_db.close()

        return False

    def run_search(self, mspeaks, query, min_abundance, ion_type, ion_charge, adduct_atom=None):

        def get_formulas(nominal_overlay=0.1):

            nominal_mz = ms_peak.nominal_mz_exp

            defect_mass = ms_peak.mz_exp - nominal_mz
            nominal_masses = [nominal_mz]

            if (defect_mass) &gt;= 1 - nominal_overlay:
                nominal_masses.append(nominal_mz + 1)
            elif (defect_mass) &lt;= nominal_overlay:
                nominal_masses.append(nominal_mz - 1)

            list_formulas_candidates = []

            for nominal_mass in nominal_masses:
                if nominal_mass in query.keys():
                    list_formulas_candidates.extend(query.get(nominal_mass))

            return list_formulas_candidates

        all_assigned_indexes = list()

        # molecular_search_settings = self.mass_spectrum_obj.molecular_search_settings

        search_molfrom = SearchMolecularFormulaWorker(find_isotopologues=self.find_isotopologues)

        for ms_peak in mspeaks:

            # already assigned a molecular formula
            if self.first_hit:

                if ms_peak.is_assigned:
                    continue

            ms_peak_indexes = search_molfrom.find_formulas(get_formulas(), min_abundance, self.mass_spectrum_obj, ms_peak, ion_type, ion_charge, adduct_atom)    

            all_assigned_indexes.extend(ms_peak_indexes)

        # all_assigned_indexes = MolecularFormulaSearchFilters().filter_isotopologue(all_assigned_indexes, self.mass_spectrum_obj)

        # all_assigned_indexes = MolecularFormulaSearchFilters().filter_kendrick(all_assigned_indexes, self.mass_spectrum_obj)

        # MolecularFormulaSearchFilters().check_min_peaks(all_assigned_indexes, self.mass_spectrum_obj)
        # filter per min peaks per mono isotopic class

    def run_worker_mass_spectrum(self):

        self.run_molecular_formula(self.mass_spectrum_obj.sort_by_abundance())    

    def run_worker_ms_peaks(self, ms_peaks):

        self.run_molecular_formula(ms_peaks)           

    @staticmethod
    def database_to_dict(classe_str_list, nominal_mzs, mf_search_settings, ion_charge):

        sql_db = MolForm_SQL(url=mf_search_settings.url_database)

        dict_res = {}

        if mf_search_settings.isProtonated:
            dict_res[Labels.protonated_de_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.protonated_de_ion, nominal_mzs, ion_charge, mf_search_settings)    

        if mf_search_settings.isRadical:
            dict_res[Labels.radical_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.radical_ion, nominal_mzs, ion_charge,  mf_search_settings)    

        if mf_search_settings.isAdduct:

            adduct_list = mf_search_settings.adduct_atoms_neg if ion_charge &lt; 0 else mf_search_settings.adduct_atoms_pos
            dict_res[Labels.adduct_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.adduct_ion, nominal_mzs, ion_charge, mf_search_settings, adducts=adduct_list)    

        return dict_res

    @timeit       
    def run_molecular_formula(self, ms_peaks):

        # number_of_process = multiprocessing.cpu_count()

        &#39;&#39;&#39;loading this on a shared memory would be better than having to serialize it for every process
            waiting for python 3.8 release&#39;&#39;&#39;

        # ion charge for all the ion in the mass spectrum
        # under the current structure is possible to search for individual m/z but it takes longer than allow all the m/z to be search against
        ion_charge = self.mass_spectrum_obj.polarity

        # use to limit the calculation of possible isotopologues
        min_abundance = self.mass_spectrum_obj.min_abundance

        # only query the database for formulas with the nominal m/z matching the mass spectrum data
        # default m/z overlay is m/z 0.3 unit
        # needs to improve to bin by mass defect instead, faster db creation and faster search execution time 
        nominal_mzs = self.mass_spectrum_obj.nominal_mz

        # reset average error, only relevant is average mass error method is being used
        SearchMolecularFormulaWorker(find_isotopologues=self.find_isotopologues).reset_error(self.mass_spectrum_obj)

        # check database for all possible molecular formula combinations based on the setting passed to self.mass_spectrum_obj.molecular_search_settings
        classes = MolecularCombinations(self.sql_db).runworker(self.mass_spectrum_obj.molecular_search_settings)

        # split the database load to not blowout the memory
        # TODO add to the settings

        def run():

            for classe_chunk in chunks(classes, 300): 

                classes_str_list = [class_tuple[0] for class_tuple in classe_chunk]

                # load the molecular formula objs binned by ion type and heteroatoms classes, {ion type:{classe:[list_formula]}}
                # for adduct ion type a third key is added {atoms:{ion type:{classe:[list_formula]}}} 
                dict_res = self.database_to_dict(classes_str_list, nominal_mzs, self.mass_spectrum_obj.molecular_search_settings, ion_charge)

                pbar = tqdm.tqdm(classe_chunk)

                for classe_tuple in pbar:

                    # class string is a json serialized dict
                    classe_str = classe_tuple[0]
                    classe_dict = classe_tuple[1]

                    if self.mass_spectrum_obj.molecular_search_settings.isProtonated:

                        ion_type = Labels.protonated_de_ion

                        pbar.set_description_str(desc=&#34;Started molecular formula search for class %s, (de)protonated &#34; % classe_str, refresh=True)

                        candidate_formulas = dict_res.get(ion_type).get(classe_str)

                        if candidate_formulas:

                            self.run_search(ms_peaks, candidate_formulas,
                                            min_abundance, ion_type, ion_charge)

                    if self.mass_spectrum_obj.molecular_search_settings.isRadical:

                        pbar.set_description_str(desc=&#34;Started molecular formula search for class %s, radical &#34; % classe_str, refresh=True)

                        ion_type = Labels.radical_ion

                        candidate_formulas = dict_res.get(ion_type).get(classe_str)

                        if candidate_formulas:

                            self.run_search(ms_peaks, candidate_formulas,
                                            min_abundance, ion_type, ion_charge)
                    # looks for adduct, used_atom_valences should be 0 
                    # this code does not support H exchance by halogen atoms
                    if self.mass_spectrum_obj.molecular_search_settings.isAdduct:

                        pbar.set_description_str(desc=&#34;Started molecular formula search for class %s, adduct &#34; % classe_str, refresh=True)

                        ion_type = Labels.adduct_ion
                        dict_atoms_formulas =  dict_res.get(ion_type)

                        for adduct_atom, dict_by_class in dict_atoms_formulas.items():

                            candidate_formulas = dict_by_class.get(classe_str)

                            if candidate_formulas:
                                self.run_search(ms_peaks, candidate_formulas,
                                                min_abundance, ion_type, ion_charge, adduct_atom=adduct_atom)

        run()
        self.sql_db.close()

    def search_mol_formulas(self, possible_formulas_list, find_isotopologues=True):

        SearchMolecularFormulaWorker(find_isotopologues=find_isotopologues).reset_error(self.mass_spectrum_obj)

        initial_min_peak_bool = self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter
        initial_runtime_kendrick_filter = self.mass_spectrum_obj.molecular_search_settings.use_runtime_kendrick_filter

        self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter = False
        self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter = False
        self.mass_spectrum_obj.molecular_search_settings.use_runtime_kendrick_filter = False

        possible_formulas_dict_nm = {}

        for mf in possible_formulas_list:

            nm = int(mf.mass)

            if nm in possible_formulas_dict_nm.keys():

                possible_formulas_dict_nm[nm].append(mf)

            else:
                possible_formulas_dict_nm[nm] = [mf]

        min_abundance = self.mass_spectrum_obj.min_abundance
        ion_type = &#39;unknown&#39;
        self.run_search(self.mass_spectrum_obj, possible_formulas_dict_nm, min_abundance, ion_type, self.mass_spectrum_obj.polarity )          

        self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter = initial_min_peak_bool
        self.mass_spectrum_obj.molecular_search_settings.use_runtime_kendrick_filter = initial_runtime_kendrick_filter

        mspeaks = [mspeak for mspeak in self.mass_spectrum_obj if mspeak.is_assigned]

        self.sql_db.close()

        return mspeaks


class SearchMolecularFormulaWorker:

    # TODO add reset error function
    # needs this warper to pass the class to multiprocessing

    def __init__(self, find_isotopologues=True):
        self.find_isotopologues = find_isotopologues

    def __call__(self, args):

        return self.find_formulas(*args)  # ,args[1]

    def reset_error(self, mass_spectrum_obj):
        global last_error, last_dif, closest_error, error_average, nbValues  
        last_error, last_dif, closest_error, nbValues  = 0.0, 0.0, 0.0, 0.0

        error_average = 0

    def set_last_error(self, error, mass_spectrum_obj):

        # set the changes to the global variables, not internal ones
        global last_error, last_dif, closest_error, error_average, nbValues

        if mass_spectrum_obj.molecular_search_settings.error_method == &#39;distance&#39;:

            dif = error - last_error
            if dif &lt; last_dif:
                last_dif = dif
                closest_error = error
                mass_spectrum_obj.molecular_search_settings.min_ppm_error = closest_error - mass_spectrum_obj.molecular_search_settings.mz_error_range
                mass_spectrum_obj.molecular_search_settings.max_ppm_error = closest_error + mass_spectrum_obj.molecular_search_settings.mz_error_range

        elif mass_spectrum_obj.molecular_search_settings.error_method == &#39;lowest&#39;:

            if error &lt; last_error:
                mass_spectrum_obj.molecular_search_settings.min_ppm_error = error - mass_spectrum_obj.molecular_search_settings.mz_error_range
                mass_spectrum_obj.molecular_search_settings.max_ppm_error = error + mass_spectrum_obj.molecular_search_settings.mz_error_range
                last_error = error


        elif mass_spectrum_obj.molecular_search_settings.error_method == &#39;symmetrical&#39;:

            mass_spectrum_obj.molecular_search_settings.min_ppm_error = mass_spectrum_obj.molecular_search_settings.mz_error_average - mass_spectrum_obj.molecular_search_settings.mz_error_range
            mass_spectrum_obj.molecular_search_settings.max_ppm_error = mass_spectrum_obj.molecular_search_settings.mz_error_average + mass_spectrum_obj.molecular_search_settings.mz_error_range

        elif mass_spectrum_obj.molecular_search_settings.error_method == &#39;average&#39;:

            nbValues += 1
            error_average = error_average + ((error - error_average) / nbValues)
            mass_spectrum_obj.molecular_search_settings.min_ppm_error = error_average - mass_spectrum_obj.molecular_search_settings.mz_error_range
            mass_spectrum_obj.molecular_search_settings.max_ppm_error = error_average + mass_spectrum_obj.molecular_search_settings.mz_error_range    

        else:
            # using set mass_spectrum_obj.molecular_search_settings.min_ppm_error  and max_ppm_error range
            pass

        &#39;&#39;&#39;returns the error based on the selected method at mass_spectrum_obj.molecular_search_settings.method
        &#39;&#39;&#39;
    @staticmethod
    def calc_error(mz_exp, mz_calc, method=&#39;ppm&#39;):

        &#39;&#39;&#39;method should be ppm or ppb&#39;&#39;&#39;

        if method == &#39;ppm&#39;:
            multi_factor = 1000000

        elif method == &#39;ppb&#39;:
            multi_factor = 1000000

        elif method == &#39;perc&#39;:
            multi_factor = 100

        else:
            raise Exception(&#34;method needs to be ppm or ppb, you have entered %s&#34; % method)

        if mz_exp:

            return ((mz_calc - mz_exp) / mz_calc) * multi_factor

        else:

            raise Exception(&#34;Please set mz_calc first&#34;)

    def find_formulas(self, formulas, min_abundance,
                      mass_spectrum_obj, ms_peak, ion_type, ion_charge, adduct_atom=None):
        &#39;&#39;&#39;
        # uses the closest error the next search (this is not ideal, it needs to use confidence
        # metric to choose the right candidate then propagate the error using the error from the best candidate
        # it needs to add s/n to the equation
        # it need optimization to define the mz_error_range within a m/z unit since it is directly 
        # proportional with the mass, and inversely proportional to the rp. 
        # It&#39;s not linear, i.e., sigma ∝ mass 
        # the idea it to correlate sigma to resolving power, signal to noise and sample complexity per mz unit
        # method=&#39;distance&#39;
        &#39;&#39;&#39;

        mspeak_assigned_index = list()

        min_ppm_error = mass_spectrum_obj.molecular_search_settings.min_ppm_error 
        max_ppm_error = mass_spectrum_obj.molecular_search_settings.max_ppm_error

        min_abun_error = mass_spectrum_obj.molecular_search_settings.min_abun_error
        max_abun_error = mass_spectrum_obj.molecular_search_settings.max_abun_error

        # f = open(&#34;abundance_error.txt&#34;, &#34;a+&#34;)    
        ms_peak_mz_exp, ms_peak_abundance = ms_peak.mz_exp, ms_peak.abundance
        # min_error = min([pmf.mz_error for pmf in possible_formulas])

        def mass_by_ion_type(possible_formula_obj):

            if ion_type == Labels.protonated_de_ion:

                return possible_formula_obj.protonated_mass(ion_charge)

            elif ion_type == Labels.radical_ion:

                return possible_formula_obj.radical_mass(ion_charge)

            elif ion_type == Labels.adduct_ion and adduct_atom:

                return possible_formula.adduct_mass(ion_charge, adduct_atom)

            else:

                return possible_formula.mass

        for possible_formula in formulas:

            if possible_formula:

                error = self.calc_error(ms_peak_mz_exp, mass_by_ion_type(possible_formula))

                # error = possible_formula.mz_error

                if min_ppm_error &lt;= error &lt;= max_ppm_error:

                    # update the error

                    self.set_last_error(error, mass_spectrum_obj)

                    # add molecular formula match to ms_peak

                    # get molecular formula dict from sql obj
                    # formula_dict = pickle.loads(possible_formula.mol_formula)
                    formula_dict = possible_formula.formula_dict
                    # create the molecular formula obj to be stored
                    molecular_formula = MolecularFormula(formula_dict, ion_charge, ion_type=ion_type, adduct_atom=adduct_atom)

                    # add the molecular formula obj to the mspeak obj
                    # add the mspeak obj and it&#39;s index for tracking next assignment step

                    if self.find_isotopologues:

                        # calculates isotopologues
                        isotopologues = molecular_formula.isotopologues(min_abundance, ms_peak_abundance, mass_spectrum_obj.dynamic_range)

                        # search for isotopologues
                        for isotopologue_formula in isotopologues:

                            molecular_formula.expected_isotopologues.append(isotopologue_formula)
                            # move this outside to improve preformace
                            # we need to increase the search space to -+1 m_z 
                            first_index, last_index = mass_spectrum_obj.get_nominal_mz_first_last_indexes(isotopologue_formula.mz_nominal_calc)

                            for ms_peak_iso in mass_spectrum_obj[first_index:last_index]:

                                error = self.calc_error(ms_peak_iso.mz_exp, isotopologue_formula.mz_calc)

                                if min_ppm_error &lt;= error &lt;= max_ppm_error:

                                    # need to define error distribution for abundance measurements

                                    # if mass_spectrum_obj.is_centroid:

                                    abundance_error = self.calc_error(isotopologue_formula.abundance_calc, ms_peak_iso.abundance,method=&#39;perc&#39;)            

                                    # area_error = self.calc_error(ms_peak.area, ms_peak_iso.area, method=&#39;perc&#39;)

                                    # margin of error was set empirically/ needs statistical calculation
                                    #  of margin of error for the measurement of the abundances
                                    if min_abun_error &lt;= abundance_error &lt;= max_abun_error:

                                        # update the error

                                        self.set_last_error(error, mass_spectrum_obj)

                                        # isotopologue_formula.mz_error = error

                                        # isotopologue_formula.area_error = area_error

                                        # isotopologue_formula.abundance_error = abundance_error

                                        isotopologue_formula.mspeak_index_mono_isotopic = ms_peak.index

                                        mono_isotopic_formula_index = len(ms_peak)

                                        isotopologue_formula.mspeak_index_mono_isotopic = ms_peak.index

                                        isotopologue_formula.mono_isotopic_formula_index = mono_isotopic_formula_index

                                        # add mspeaks isotopologue index to the mono isotopic MolecularFormula obj and the respective formula position  

                                        # add molecular formula match to ms_peak
                                        x = ms_peak_iso.add_molecular_formula(isotopologue_formula)

                                        molecular_formula.mspeak_mf_isotopologues_indexes.append((ms_peak_iso.index, x))
                                        # add mspeaks mono isotopic index to the isotopologue MolecularFormula obj

                    y = ms_peak.add_molecular_formula(molecular_formula)            

                    mspeak_assigned_index.append((ms_peak.index, y))

        return mspeak_assigned_index</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulaWorker"><code class="flex name class">
<span>class <span class="ident">SearchMolecularFormulaWorker</span></span>
<span>(</span><span>find_isotopologues=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SearchMolecularFormulaWorker:

    # TODO add reset error function
    # needs this warper to pass the class to multiprocessing

    def __init__(self, find_isotopologues=True):
        self.find_isotopologues = find_isotopologues

    def __call__(self, args):

        return self.find_formulas(*args)  # ,args[1]

    def reset_error(self, mass_spectrum_obj):
        global last_error, last_dif, closest_error, error_average, nbValues  
        last_error, last_dif, closest_error, nbValues  = 0.0, 0.0, 0.0, 0.0

        error_average = 0

    def set_last_error(self, error, mass_spectrum_obj):

        # set the changes to the global variables, not internal ones
        global last_error, last_dif, closest_error, error_average, nbValues

        if mass_spectrum_obj.molecular_search_settings.error_method == &#39;distance&#39;:

            dif = error - last_error
            if dif &lt; last_dif:
                last_dif = dif
                closest_error = error
                mass_spectrum_obj.molecular_search_settings.min_ppm_error = closest_error - mass_spectrum_obj.molecular_search_settings.mz_error_range
                mass_spectrum_obj.molecular_search_settings.max_ppm_error = closest_error + mass_spectrum_obj.molecular_search_settings.mz_error_range

        elif mass_spectrum_obj.molecular_search_settings.error_method == &#39;lowest&#39;:

            if error &lt; last_error:
                mass_spectrum_obj.molecular_search_settings.min_ppm_error = error - mass_spectrum_obj.molecular_search_settings.mz_error_range
                mass_spectrum_obj.molecular_search_settings.max_ppm_error = error + mass_spectrum_obj.molecular_search_settings.mz_error_range
                last_error = error


        elif mass_spectrum_obj.molecular_search_settings.error_method == &#39;symmetrical&#39;:

            mass_spectrum_obj.molecular_search_settings.min_ppm_error = mass_spectrum_obj.molecular_search_settings.mz_error_average - mass_spectrum_obj.molecular_search_settings.mz_error_range
            mass_spectrum_obj.molecular_search_settings.max_ppm_error = mass_spectrum_obj.molecular_search_settings.mz_error_average + mass_spectrum_obj.molecular_search_settings.mz_error_range

        elif mass_spectrum_obj.molecular_search_settings.error_method == &#39;average&#39;:

            nbValues += 1
            error_average = error_average + ((error - error_average) / nbValues)
            mass_spectrum_obj.molecular_search_settings.min_ppm_error = error_average - mass_spectrum_obj.molecular_search_settings.mz_error_range
            mass_spectrum_obj.molecular_search_settings.max_ppm_error = error_average + mass_spectrum_obj.molecular_search_settings.mz_error_range    

        else:
            # using set mass_spectrum_obj.molecular_search_settings.min_ppm_error  and max_ppm_error range
            pass

        &#39;&#39;&#39;returns the error based on the selected method at mass_spectrum_obj.molecular_search_settings.method
        &#39;&#39;&#39;
    @staticmethod
    def calc_error(mz_exp, mz_calc, method=&#39;ppm&#39;):

        &#39;&#39;&#39;method should be ppm or ppb&#39;&#39;&#39;

        if method == &#39;ppm&#39;:
            multi_factor = 1000000

        elif method == &#39;ppb&#39;:
            multi_factor = 1000000

        elif method == &#39;perc&#39;:
            multi_factor = 100

        else:
            raise Exception(&#34;method needs to be ppm or ppb, you have entered %s&#34; % method)

        if mz_exp:

            return ((mz_calc - mz_exp) / mz_calc) * multi_factor

        else:

            raise Exception(&#34;Please set mz_calc first&#34;)

    def find_formulas(self, formulas, min_abundance,
                      mass_spectrum_obj, ms_peak, ion_type, ion_charge, adduct_atom=None):
        &#39;&#39;&#39;
        # uses the closest error the next search (this is not ideal, it needs to use confidence
        # metric to choose the right candidate then propagate the error using the error from the best candidate
        # it needs to add s/n to the equation
        # it need optimization to define the mz_error_range within a m/z unit since it is directly 
        # proportional with the mass, and inversely proportional to the rp. 
        # It&#39;s not linear, i.e., sigma ∝ mass 
        # the idea it to correlate sigma to resolving power, signal to noise and sample complexity per mz unit
        # method=&#39;distance&#39;
        &#39;&#39;&#39;

        mspeak_assigned_index = list()

        min_ppm_error = mass_spectrum_obj.molecular_search_settings.min_ppm_error 
        max_ppm_error = mass_spectrum_obj.molecular_search_settings.max_ppm_error

        min_abun_error = mass_spectrum_obj.molecular_search_settings.min_abun_error
        max_abun_error = mass_spectrum_obj.molecular_search_settings.max_abun_error

        # f = open(&#34;abundance_error.txt&#34;, &#34;a+&#34;)    
        ms_peak_mz_exp, ms_peak_abundance = ms_peak.mz_exp, ms_peak.abundance
        # min_error = min([pmf.mz_error for pmf in possible_formulas])

        def mass_by_ion_type(possible_formula_obj):

            if ion_type == Labels.protonated_de_ion:

                return possible_formula_obj.protonated_mass(ion_charge)

            elif ion_type == Labels.radical_ion:

                return possible_formula_obj.radical_mass(ion_charge)

            elif ion_type == Labels.adduct_ion and adduct_atom:

                return possible_formula.adduct_mass(ion_charge, adduct_atom)

            else:

                return possible_formula.mass

        for possible_formula in formulas:

            if possible_formula:

                error = self.calc_error(ms_peak_mz_exp, mass_by_ion_type(possible_formula))

                # error = possible_formula.mz_error

                if min_ppm_error &lt;= error &lt;= max_ppm_error:

                    # update the error

                    self.set_last_error(error, mass_spectrum_obj)

                    # add molecular formula match to ms_peak

                    # get molecular formula dict from sql obj
                    # formula_dict = pickle.loads(possible_formula.mol_formula)
                    formula_dict = possible_formula.formula_dict
                    # create the molecular formula obj to be stored
                    molecular_formula = MolecularFormula(formula_dict, ion_charge, ion_type=ion_type, adduct_atom=adduct_atom)

                    # add the molecular formula obj to the mspeak obj
                    # add the mspeak obj and it&#39;s index for tracking next assignment step

                    if self.find_isotopologues:

                        # calculates isotopologues
                        isotopologues = molecular_formula.isotopologues(min_abundance, ms_peak_abundance, mass_spectrum_obj.dynamic_range)

                        # search for isotopologues
                        for isotopologue_formula in isotopologues:

                            molecular_formula.expected_isotopologues.append(isotopologue_formula)
                            # move this outside to improve preformace
                            # we need to increase the search space to -+1 m_z 
                            first_index, last_index = mass_spectrum_obj.get_nominal_mz_first_last_indexes(isotopologue_formula.mz_nominal_calc)

                            for ms_peak_iso in mass_spectrum_obj[first_index:last_index]:

                                error = self.calc_error(ms_peak_iso.mz_exp, isotopologue_formula.mz_calc)

                                if min_ppm_error &lt;= error &lt;= max_ppm_error:

                                    # need to define error distribution for abundance measurements

                                    # if mass_spectrum_obj.is_centroid:

                                    abundance_error = self.calc_error(isotopologue_formula.abundance_calc, ms_peak_iso.abundance,method=&#39;perc&#39;)            

                                    # area_error = self.calc_error(ms_peak.area, ms_peak_iso.area, method=&#39;perc&#39;)

                                    # margin of error was set empirically/ needs statistical calculation
                                    #  of margin of error for the measurement of the abundances
                                    if min_abun_error &lt;= abundance_error &lt;= max_abun_error:

                                        # update the error

                                        self.set_last_error(error, mass_spectrum_obj)

                                        # isotopologue_formula.mz_error = error

                                        # isotopologue_formula.area_error = area_error

                                        # isotopologue_formula.abundance_error = abundance_error

                                        isotopologue_formula.mspeak_index_mono_isotopic = ms_peak.index

                                        mono_isotopic_formula_index = len(ms_peak)

                                        isotopologue_formula.mspeak_index_mono_isotopic = ms_peak.index

                                        isotopologue_formula.mono_isotopic_formula_index = mono_isotopic_formula_index

                                        # add mspeaks isotopologue index to the mono isotopic MolecularFormula obj and the respective formula position  

                                        # add molecular formula match to ms_peak
                                        x = ms_peak_iso.add_molecular_formula(isotopologue_formula)

                                        molecular_formula.mspeak_mf_isotopologues_indexes.append((ms_peak_iso.index, x))
                                        # add mspeaks mono isotopic index to the isotopologue MolecularFormula obj

                    y = ms_peak.add_molecular_formula(molecular_formula)            

                    mspeak_assigned_index.append((ms_peak.index, y))

        return mspeak_assigned_index</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulaWorker.calc_error"><code class="name flex">
<span>def <span class="ident">calc_error</span></span>(<span>mz_exp, mz_calc, method='ppm')</span>
</code></dt>
<dd>
<div class="desc"><p>method should be ppm or ppb</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_error(mz_exp, mz_calc, method=&#39;ppm&#39;):

    &#39;&#39;&#39;method should be ppm or ppb&#39;&#39;&#39;

    if method == &#39;ppm&#39;:
        multi_factor = 1000000

    elif method == &#39;ppb&#39;:
        multi_factor = 1000000

    elif method == &#39;perc&#39;:
        multi_factor = 100

    else:
        raise Exception(&#34;method needs to be ppm or ppb, you have entered %s&#34; % method)

    if mz_exp:

        return ((mz_calc - mz_exp) / mz_calc) * multi_factor

    else:

        raise Exception(&#34;Please set mz_calc first&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulaWorker.find_formulas"><code class="name flex">
<span>def <span class="ident">find_formulas</span></span>(<span>self, formulas, min_abundance, mass_spectrum_obj, ms_peak, ion_type, ion_charge, adduct_atom=None)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="uses-the-closest-error-the-next-search-this-is-not-ideal-it-needs-to-use-confidence">uses the closest error the next search (this is not ideal, it needs to use confidence</h1>
<h1 id="metric-to-choose-the-right-candidate-then-propagate-the-error-using-the-error-from-the-best-candidate">metric to choose the right candidate then propagate the error using the error from the best candidate</h1>
<h1 id="it-needs-to-add-sn-to-the-equation">it needs to add s/n to the equation</h1>
<h1 id="it-need-optimization-to-define-the-mz_error_range-within-a-mz-unit-since-it-is-directly">it need optimization to define the mz_error_range within a m/z unit since it is directly</h1>
<h1 id="proportional-with-the-mass-and-inversely-proportional-to-the-rp">proportional with the mass, and inversely proportional to the rp.</h1>
<h1 id="its-not-linear-ie-sigma-mass">It's not linear, i.e., sigma ∝ mass</h1>
<h1 id="the-idea-it-to-correlate-sigma-to-resolving-power-signal-to-noise-and-sample-complexity-per-mz-unit">the idea it to correlate sigma to resolving power, signal to noise and sample complexity per mz unit</h1>
<h1 id="methoddistance">method='distance'</h1></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_formulas(self, formulas, min_abundance,
                  mass_spectrum_obj, ms_peak, ion_type, ion_charge, adduct_atom=None):
    &#39;&#39;&#39;
    # uses the closest error the next search (this is not ideal, it needs to use confidence
    # metric to choose the right candidate then propagate the error using the error from the best candidate
    # it needs to add s/n to the equation
    # it need optimization to define the mz_error_range within a m/z unit since it is directly 
    # proportional with the mass, and inversely proportional to the rp. 
    # It&#39;s not linear, i.e., sigma ∝ mass 
    # the idea it to correlate sigma to resolving power, signal to noise and sample complexity per mz unit
    # method=&#39;distance&#39;
    &#39;&#39;&#39;

    mspeak_assigned_index = list()

    min_ppm_error = mass_spectrum_obj.molecular_search_settings.min_ppm_error 
    max_ppm_error = mass_spectrum_obj.molecular_search_settings.max_ppm_error

    min_abun_error = mass_spectrum_obj.molecular_search_settings.min_abun_error
    max_abun_error = mass_spectrum_obj.molecular_search_settings.max_abun_error

    # f = open(&#34;abundance_error.txt&#34;, &#34;a+&#34;)    
    ms_peak_mz_exp, ms_peak_abundance = ms_peak.mz_exp, ms_peak.abundance
    # min_error = min([pmf.mz_error for pmf in possible_formulas])

    def mass_by_ion_type(possible_formula_obj):

        if ion_type == Labels.protonated_de_ion:

            return possible_formula_obj.protonated_mass(ion_charge)

        elif ion_type == Labels.radical_ion:

            return possible_formula_obj.radical_mass(ion_charge)

        elif ion_type == Labels.adduct_ion and adduct_atom:

            return possible_formula.adduct_mass(ion_charge, adduct_atom)

        else:

            return possible_formula.mass

    for possible_formula in formulas:

        if possible_formula:

            error = self.calc_error(ms_peak_mz_exp, mass_by_ion_type(possible_formula))

            # error = possible_formula.mz_error

            if min_ppm_error &lt;= error &lt;= max_ppm_error:

                # update the error

                self.set_last_error(error, mass_spectrum_obj)

                # add molecular formula match to ms_peak

                # get molecular formula dict from sql obj
                # formula_dict = pickle.loads(possible_formula.mol_formula)
                formula_dict = possible_formula.formula_dict
                # create the molecular formula obj to be stored
                molecular_formula = MolecularFormula(formula_dict, ion_charge, ion_type=ion_type, adduct_atom=adduct_atom)

                # add the molecular formula obj to the mspeak obj
                # add the mspeak obj and it&#39;s index for tracking next assignment step

                if self.find_isotopologues:

                    # calculates isotopologues
                    isotopologues = molecular_formula.isotopologues(min_abundance, ms_peak_abundance, mass_spectrum_obj.dynamic_range)

                    # search for isotopologues
                    for isotopologue_formula in isotopologues:

                        molecular_formula.expected_isotopologues.append(isotopologue_formula)
                        # move this outside to improve preformace
                        # we need to increase the search space to -+1 m_z 
                        first_index, last_index = mass_spectrum_obj.get_nominal_mz_first_last_indexes(isotopologue_formula.mz_nominal_calc)

                        for ms_peak_iso in mass_spectrum_obj[first_index:last_index]:

                            error = self.calc_error(ms_peak_iso.mz_exp, isotopologue_formula.mz_calc)

                            if min_ppm_error &lt;= error &lt;= max_ppm_error:

                                # need to define error distribution for abundance measurements

                                # if mass_spectrum_obj.is_centroid:

                                abundance_error = self.calc_error(isotopologue_formula.abundance_calc, ms_peak_iso.abundance,method=&#39;perc&#39;)            

                                # area_error = self.calc_error(ms_peak.area, ms_peak_iso.area, method=&#39;perc&#39;)

                                # margin of error was set empirically/ needs statistical calculation
                                #  of margin of error for the measurement of the abundances
                                if min_abun_error &lt;= abundance_error &lt;= max_abun_error:

                                    # update the error

                                    self.set_last_error(error, mass_spectrum_obj)

                                    # isotopologue_formula.mz_error = error

                                    # isotopologue_formula.area_error = area_error

                                    # isotopologue_formula.abundance_error = abundance_error

                                    isotopologue_formula.mspeak_index_mono_isotopic = ms_peak.index

                                    mono_isotopic_formula_index = len(ms_peak)

                                    isotopologue_formula.mspeak_index_mono_isotopic = ms_peak.index

                                    isotopologue_formula.mono_isotopic_formula_index = mono_isotopic_formula_index

                                    # add mspeaks isotopologue index to the mono isotopic MolecularFormula obj and the respective formula position  

                                    # add molecular formula match to ms_peak
                                    x = ms_peak_iso.add_molecular_formula(isotopologue_formula)

                                    molecular_formula.mspeak_mf_isotopologues_indexes.append((ms_peak_iso.index, x))
                                    # add mspeaks mono isotopic index to the isotopologue MolecularFormula obj

                y = ms_peak.add_molecular_formula(molecular_formula)            

                mspeak_assigned_index.append((ms_peak.index, y))

    return mspeak_assigned_index</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulaWorker.reset_error"><code class="name flex">
<span>def <span class="ident">reset_error</span></span>(<span>self, mass_spectrum_obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_error(self, mass_spectrum_obj):
    global last_error, last_dif, closest_error, error_average, nbValues  
    last_error, last_dif, closest_error, nbValues  = 0.0, 0.0, 0.0, 0.0

    error_average = 0</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulaWorker.set_last_error"><code class="name flex">
<span>def <span class="ident">set_last_error</span></span>(<span>self, error, mass_spectrum_obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_last_error(self, error, mass_spectrum_obj):

    # set the changes to the global variables, not internal ones
    global last_error, last_dif, closest_error, error_average, nbValues

    if mass_spectrum_obj.molecular_search_settings.error_method == &#39;distance&#39;:

        dif = error - last_error
        if dif &lt; last_dif:
            last_dif = dif
            closest_error = error
            mass_spectrum_obj.molecular_search_settings.min_ppm_error = closest_error - mass_spectrum_obj.molecular_search_settings.mz_error_range
            mass_spectrum_obj.molecular_search_settings.max_ppm_error = closest_error + mass_spectrum_obj.molecular_search_settings.mz_error_range

    elif mass_spectrum_obj.molecular_search_settings.error_method == &#39;lowest&#39;:

        if error &lt; last_error:
            mass_spectrum_obj.molecular_search_settings.min_ppm_error = error - mass_spectrum_obj.molecular_search_settings.mz_error_range
            mass_spectrum_obj.molecular_search_settings.max_ppm_error = error + mass_spectrum_obj.molecular_search_settings.mz_error_range
            last_error = error


    elif mass_spectrum_obj.molecular_search_settings.error_method == &#39;symmetrical&#39;:

        mass_spectrum_obj.molecular_search_settings.min_ppm_error = mass_spectrum_obj.molecular_search_settings.mz_error_average - mass_spectrum_obj.molecular_search_settings.mz_error_range
        mass_spectrum_obj.molecular_search_settings.max_ppm_error = mass_spectrum_obj.molecular_search_settings.mz_error_average + mass_spectrum_obj.molecular_search_settings.mz_error_range

    elif mass_spectrum_obj.molecular_search_settings.error_method == &#39;average&#39;:

        nbValues += 1
        error_average = error_average + ((error - error_average) / nbValues)
        mass_spectrum_obj.molecular_search_settings.min_ppm_error = error_average - mass_spectrum_obj.molecular_search_settings.mz_error_range
        mass_spectrum_obj.molecular_search_settings.max_ppm_error = error_average + mass_spectrum_obj.molecular_search_settings.mz_error_range    

    else:
        # using set mass_spectrum_obj.molecular_search_settings.min_ppm_error  and max_ppm_error range
        pass

    &#39;&#39;&#39;returns the error based on the selected method at mass_spectrum_obj.molecular_search_settings.method
    &#39;&#39;&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas"><code class="flex name class">
<span>class <span class="ident">SearchMolecularFormulas</span></span>
<span>(</span><span>mass_spectrum_obj, sql_db=None, first_hit=False, find_isotopologues=True)</span>
</code></dt>
<dd>
<div class="desc"><p>runworker()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SearchMolecularFormulas:

    &#39;&#39;&#39;
    runworker()
    &#39;&#39;&#39;
    def __init__(self, mass_spectrum_obj, sql_db=None, first_hit=False, find_isotopologues=True):

        self.first_hit = first_hit

        self.find_isotopologues = find_isotopologues

        self.mass_spectrum_obj = mass_spectrum_obj

        if not sql_db:

            self.sql_db = MolForm_SQL(url=mass_spectrum_obj.molecular_search_settings.url_database)

        else:

            self.sql_db = sql_db

    def __enter__(self):

        return self

    def __exit__(self, exc_type, exc_val, exc_tb):

        self.sql_db.close()

        return False

    def run_search(self, mspeaks, query, min_abundance, ion_type, ion_charge, adduct_atom=None):

        def get_formulas(nominal_overlay=0.1):

            nominal_mz = ms_peak.nominal_mz_exp

            defect_mass = ms_peak.mz_exp - nominal_mz
            nominal_masses = [nominal_mz]

            if (defect_mass) &gt;= 1 - nominal_overlay:
                nominal_masses.append(nominal_mz + 1)
            elif (defect_mass) &lt;= nominal_overlay:
                nominal_masses.append(nominal_mz - 1)

            list_formulas_candidates = []

            for nominal_mass in nominal_masses:
                if nominal_mass in query.keys():
                    list_formulas_candidates.extend(query.get(nominal_mass))

            return list_formulas_candidates

        all_assigned_indexes = list()

        # molecular_search_settings = self.mass_spectrum_obj.molecular_search_settings

        search_molfrom = SearchMolecularFormulaWorker(find_isotopologues=self.find_isotopologues)

        for ms_peak in mspeaks:

            # already assigned a molecular formula
            if self.first_hit:

                if ms_peak.is_assigned:
                    continue

            ms_peak_indexes = search_molfrom.find_formulas(get_formulas(), min_abundance, self.mass_spectrum_obj, ms_peak, ion_type, ion_charge, adduct_atom)    

            all_assigned_indexes.extend(ms_peak_indexes)

        # all_assigned_indexes = MolecularFormulaSearchFilters().filter_isotopologue(all_assigned_indexes, self.mass_spectrum_obj)

        # all_assigned_indexes = MolecularFormulaSearchFilters().filter_kendrick(all_assigned_indexes, self.mass_spectrum_obj)

        # MolecularFormulaSearchFilters().check_min_peaks(all_assigned_indexes, self.mass_spectrum_obj)
        # filter per min peaks per mono isotopic class

    def run_worker_mass_spectrum(self):

        self.run_molecular_formula(self.mass_spectrum_obj.sort_by_abundance())    

    def run_worker_ms_peaks(self, ms_peaks):

        self.run_molecular_formula(ms_peaks)           

    @staticmethod
    def database_to_dict(classe_str_list, nominal_mzs, mf_search_settings, ion_charge):

        sql_db = MolForm_SQL(url=mf_search_settings.url_database)

        dict_res = {}

        if mf_search_settings.isProtonated:
            dict_res[Labels.protonated_de_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.protonated_de_ion, nominal_mzs, ion_charge, mf_search_settings)    

        if mf_search_settings.isRadical:
            dict_res[Labels.radical_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.radical_ion, nominal_mzs, ion_charge,  mf_search_settings)    

        if mf_search_settings.isAdduct:

            adduct_list = mf_search_settings.adduct_atoms_neg if ion_charge &lt; 0 else mf_search_settings.adduct_atoms_pos
            dict_res[Labels.adduct_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.adduct_ion, nominal_mzs, ion_charge, mf_search_settings, adducts=adduct_list)    

        return dict_res

    @timeit       
    def run_molecular_formula(self, ms_peaks):

        # number_of_process = multiprocessing.cpu_count()

        &#39;&#39;&#39;loading this on a shared memory would be better than having to serialize it for every process
            waiting for python 3.8 release&#39;&#39;&#39;

        # ion charge for all the ion in the mass spectrum
        # under the current structure is possible to search for individual m/z but it takes longer than allow all the m/z to be search against
        ion_charge = self.mass_spectrum_obj.polarity

        # use to limit the calculation of possible isotopologues
        min_abundance = self.mass_spectrum_obj.min_abundance

        # only query the database for formulas with the nominal m/z matching the mass spectrum data
        # default m/z overlay is m/z 0.3 unit
        # needs to improve to bin by mass defect instead, faster db creation and faster search execution time 
        nominal_mzs = self.mass_spectrum_obj.nominal_mz

        # reset average error, only relevant is average mass error method is being used
        SearchMolecularFormulaWorker(find_isotopologues=self.find_isotopologues).reset_error(self.mass_spectrum_obj)

        # check database for all possible molecular formula combinations based on the setting passed to self.mass_spectrum_obj.molecular_search_settings
        classes = MolecularCombinations(self.sql_db).runworker(self.mass_spectrum_obj.molecular_search_settings)

        # split the database load to not blowout the memory
        # TODO add to the settings

        def run():

            for classe_chunk in chunks(classes, 300): 

                classes_str_list = [class_tuple[0] for class_tuple in classe_chunk]

                # load the molecular formula objs binned by ion type and heteroatoms classes, {ion type:{classe:[list_formula]}}
                # for adduct ion type a third key is added {atoms:{ion type:{classe:[list_formula]}}} 
                dict_res = self.database_to_dict(classes_str_list, nominal_mzs, self.mass_spectrum_obj.molecular_search_settings, ion_charge)

                pbar = tqdm.tqdm(classe_chunk)

                for classe_tuple in pbar:

                    # class string is a json serialized dict
                    classe_str = classe_tuple[0]
                    classe_dict = classe_tuple[1]

                    if self.mass_spectrum_obj.molecular_search_settings.isProtonated:

                        ion_type = Labels.protonated_de_ion

                        pbar.set_description_str(desc=&#34;Started molecular formula search for class %s, (de)protonated &#34; % classe_str, refresh=True)

                        candidate_formulas = dict_res.get(ion_type).get(classe_str)

                        if candidate_formulas:

                            self.run_search(ms_peaks, candidate_formulas,
                                            min_abundance, ion_type, ion_charge)

                    if self.mass_spectrum_obj.molecular_search_settings.isRadical:

                        pbar.set_description_str(desc=&#34;Started molecular formula search for class %s, radical &#34; % classe_str, refresh=True)

                        ion_type = Labels.radical_ion

                        candidate_formulas = dict_res.get(ion_type).get(classe_str)

                        if candidate_formulas:

                            self.run_search(ms_peaks, candidate_formulas,
                                            min_abundance, ion_type, ion_charge)
                    # looks for adduct, used_atom_valences should be 0 
                    # this code does not support H exchance by halogen atoms
                    if self.mass_spectrum_obj.molecular_search_settings.isAdduct:

                        pbar.set_description_str(desc=&#34;Started molecular formula search for class %s, adduct &#34; % classe_str, refresh=True)

                        ion_type = Labels.adduct_ion
                        dict_atoms_formulas =  dict_res.get(ion_type)

                        for adduct_atom, dict_by_class in dict_atoms_formulas.items():

                            candidate_formulas = dict_by_class.get(classe_str)

                            if candidate_formulas:
                                self.run_search(ms_peaks, candidate_formulas,
                                                min_abundance, ion_type, ion_charge, adduct_atom=adduct_atom)

        run()
        self.sql_db.close()

    def search_mol_formulas(self, possible_formulas_list, find_isotopologues=True):

        SearchMolecularFormulaWorker(find_isotopologues=find_isotopologues).reset_error(self.mass_spectrum_obj)

        initial_min_peak_bool = self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter
        initial_runtime_kendrick_filter = self.mass_spectrum_obj.molecular_search_settings.use_runtime_kendrick_filter

        self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter = False
        self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter = False
        self.mass_spectrum_obj.molecular_search_settings.use_runtime_kendrick_filter = False

        possible_formulas_dict_nm = {}

        for mf in possible_formulas_list:

            nm = int(mf.mass)

            if nm in possible_formulas_dict_nm.keys():

                possible_formulas_dict_nm[nm].append(mf)

            else:
                possible_formulas_dict_nm[nm] = [mf]

        min_abundance = self.mass_spectrum_obj.min_abundance
        ion_type = &#39;unknown&#39;
        self.run_search(self.mass_spectrum_obj, possible_formulas_dict_nm, min_abundance, ion_type, self.mass_spectrum_obj.polarity )          

        self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter = initial_min_peak_bool
        self.mass_spectrum_obj.molecular_search_settings.use_runtime_kendrick_filter = initial_runtime_kendrick_filter

        mspeaks = [mspeak for mspeak in self.mass_spectrum_obj if mspeak.is_assigned]

        self.sql_db.close()

        return mspeaks</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.database_to_dict"><code class="name flex">
<span>def <span class="ident">database_to_dict</span></span>(<span>classe_str_list, nominal_mzs, mf_search_settings, ion_charge)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def database_to_dict(classe_str_list, nominal_mzs, mf_search_settings, ion_charge):

    sql_db = MolForm_SQL(url=mf_search_settings.url_database)

    dict_res = {}

    if mf_search_settings.isProtonated:
        dict_res[Labels.protonated_de_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.protonated_de_ion, nominal_mzs, ion_charge, mf_search_settings)    

    if mf_search_settings.isRadical:
        dict_res[Labels.radical_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.radical_ion, nominal_mzs, ion_charge,  mf_search_settings)    

    if mf_search_settings.isAdduct:

        adduct_list = mf_search_settings.adduct_atoms_neg if ion_charge &lt; 0 else mf_search_settings.adduct_atoms_pos
        dict_res[Labels.adduct_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.adduct_ion, nominal_mzs, ion_charge, mf_search_settings, adducts=adduct_list)    

    return dict_res</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.run_molecular_formula"><code class="name flex">
<span>def <span class="ident">run_molecular_formula</span></span>(<span>*args, **kw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timed(*args, **kw):
    ts = time.time()
    result = method(*args, **kw)
    te = time.time()
    if &#39;log_time&#39; in kw:
        name = kw.get(&#39;log_name&#39;, method.__name__.upper())
        kw[&#39;log_time&#39;][name] = int((te - ts) * 1000)
    else:
        print( &#34;%r  %2.2f ms&#34; % (method.__name__, (te - ts) * 1000))
    return result</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.run_search"><code class="name flex">
<span>def <span class="ident">run_search</span></span>(<span>self, mspeaks, query, min_abundance, ion_type, ion_charge, adduct_atom=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_search(self, mspeaks, query, min_abundance, ion_type, ion_charge, adduct_atom=None):

    def get_formulas(nominal_overlay=0.1):

        nominal_mz = ms_peak.nominal_mz_exp

        defect_mass = ms_peak.mz_exp - nominal_mz
        nominal_masses = [nominal_mz]

        if (defect_mass) &gt;= 1 - nominal_overlay:
            nominal_masses.append(nominal_mz + 1)
        elif (defect_mass) &lt;= nominal_overlay:
            nominal_masses.append(nominal_mz - 1)

        list_formulas_candidates = []

        for nominal_mass in nominal_masses:
            if nominal_mass in query.keys():
                list_formulas_candidates.extend(query.get(nominal_mass))

        return list_formulas_candidates

    all_assigned_indexes = list()

    # molecular_search_settings = self.mass_spectrum_obj.molecular_search_settings

    search_molfrom = SearchMolecularFormulaWorker(find_isotopologues=self.find_isotopologues)

    for ms_peak in mspeaks:

        # already assigned a molecular formula
        if self.first_hit:

            if ms_peak.is_assigned:
                continue

        ms_peak_indexes = search_molfrom.find_formulas(get_formulas(), min_abundance, self.mass_spectrum_obj, ms_peak, ion_type, ion_charge, adduct_atom)    

        all_assigned_indexes.extend(ms_peak_indexes)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.run_worker_mass_spectrum"><code class="name flex">
<span>def <span class="ident">run_worker_mass_spectrum</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_worker_mass_spectrum(self):

    self.run_molecular_formula(self.mass_spectrum_obj.sort_by_abundance())    </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.run_worker_ms_peaks"><code class="name flex">
<span>def <span class="ident">run_worker_ms_peaks</span></span>(<span>self, ms_peaks)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_worker_ms_peaks(self, ms_peaks):

    self.run_molecular_formula(ms_peaks)           </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.search_mol_formulas"><code class="name flex">
<span>def <span class="ident">search_mol_formulas</span></span>(<span>self, possible_formulas_list, find_isotopologues=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_mol_formulas(self, possible_formulas_list, find_isotopologues=True):

    SearchMolecularFormulaWorker(find_isotopologues=find_isotopologues).reset_error(self.mass_spectrum_obj)

    initial_min_peak_bool = self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter
    initial_runtime_kendrick_filter = self.mass_spectrum_obj.molecular_search_settings.use_runtime_kendrick_filter

    self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter = False
    self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter = False
    self.mass_spectrum_obj.molecular_search_settings.use_runtime_kendrick_filter = False

    possible_formulas_dict_nm = {}

    for mf in possible_formulas_list:

        nm = int(mf.mass)

        if nm in possible_formulas_dict_nm.keys():

            possible_formulas_dict_nm[nm].append(mf)

        else:
            possible_formulas_dict_nm[nm] = [mf]

    min_abundance = self.mass_spectrum_obj.min_abundance
    ion_type = &#39;unknown&#39;
    self.run_search(self.mass_spectrum_obj, possible_formulas_dict_nm, min_abundance, ion_type, self.mass_spectrum_obj.polarity )          

    self.mass_spectrum_obj.molecular_search_settings.use_min_peaks_filter = initial_min_peak_bool
    self.mass_spectrum_obj.molecular_search_settings.use_runtime_kendrick_filter = initial_runtime_kendrick_filter

    mspeaks = [mspeak for mspeak in self.mass_spectrum_obj if mspeak.is_assigned]

    self.sql_db.close()

    return mspeaks</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.molecular_id.search" href="index.html">corems.molecular_id.search</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulaWorker" href="#corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulaWorker">SearchMolecularFormulaWorker</a></code></h4>
<ul class="">
<li><code><a title="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulaWorker.calc_error" href="#corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulaWorker.calc_error">calc_error</a></code></li>
<li><code><a title="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulaWorker.find_formulas" href="#corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulaWorker.find_formulas">find_formulas</a></code></li>
<li><code><a title="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulaWorker.reset_error" href="#corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulaWorker.reset_error">reset_error</a></code></li>
<li><code><a title="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulaWorker.set_last_error" href="#corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulaWorker.set_last_error">set_last_error</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas" href="#corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas">SearchMolecularFormulas</a></code></h4>
<ul class="">
<li><code><a title="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.database_to_dict" href="#corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.database_to_dict">database_to_dict</a></code></li>
<li><code><a title="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.run_molecular_formula" href="#corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.run_molecular_formula">run_molecular_formula</a></code></li>
<li><code><a title="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.run_search" href="#corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.run_search">run_search</a></code></li>
<li><code><a title="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.run_worker_mass_spectrum" href="#corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.run_worker_mass_spectrum">run_worker_mass_spectrum</a></code></li>
<li><code><a title="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.run_worker_ms_peaks" href="#corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.run_worker_ms_peaks">run_worker_ms_peaks</a></code></li>
<li><code><a title="corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.search_mol_formulas" href="#corems.molecular_id.search.molecularFormulaSearch.SearchMolecularFormulas.search_mol_formulas">search_mol_formulas</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>