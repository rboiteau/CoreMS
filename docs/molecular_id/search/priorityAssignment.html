<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.molecular_id.search.priorityAssignment API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.molecular_id.search.priorityAssignment</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os,  sys
sys.path.append(&#39;.&#39;)
from copy import deepcopy
from threading import Thread
from itertools import product

import tqdm

from corems.encapsulation.constant import Labels, Atoms
from corems.molecular_id.calc.MolecularFilter import MolecularFormulaSearchFilters
from corems.molecular_id.factory.MolecularLookupTable import MolecularCombinations
from corems.molecular_id.search.findOxygenPeaks import FindOxygenPeaks
from corems.molecular_id.search.molecularFormulaSearch import SearchMolecularFormulaWorker
from corems.molecular_id.factory.molecularSQL import MolForm_SQL
from corems.molecular_id.calc.ClusterFilter import ClusteringFilter
import json


class OxygenPriorityAssignment(Thread):

    def __init__(self, mass_spectrum_obj, sql_db=False):
        &#39;&#39;&#39;TODO:- add support for other atoms and adducts: Done
                - add dbe range on search runtime : Done
                - add docs
                - improve performace : Done 
        &#39;&#39;&#39;
        Thread.__init__(self)
        self.mass_spectrum_obj = mass_spectrum_obj
        #  initiated at create_molecular_database()
        #self.dict_molecular_lookup_table = None
        
        if not sql_db:

            self.sql_db = MolForm_SQL(url=mass_spectrum_obj.molecular_search_settings.url_database)
        
        else:
            
            self.sql_db = sql_db

    def run(self):
        
        # get Oxygen classes dict and the associate mspeak class 
        # list_of_classes_min_max_dbe = self.class_and_dbes_in_order()
        # create database separated to give the user the chance to use mass spec filters
             
        assign_classes_order_str_dict_tuple_list = self.create_data_base()
        
        if assign_classes_order_str_dict_tuple_list:
            
            self.run_worker_mass_spectrum(assign_classes_order_str_dict_tuple_list)
        
        else:
            
            raise RuntimeError(&#39;call create_data_base() first&#39;)

        self.sql_db.close()   

    def create_data_base(self):
        
        def create_molecular_database():
            
            # checks and creates the database entries for the specified heteroatomic classes 
            
            min_o = min(self.mass_spectrum_obj, key=lambda msp: msp[0][&#39;O&#39;])[0][&#39;O&#39;] - 2
            
            if min_o &lt;= 0:
                min_o = 1

            max_o = max(self.mass_spectrum_obj, key=lambda msp: msp[0][&#39;O&#39;])[0][&#39;O&#39;] + 2

            #min_dbe = min(self.mass_spectrum_obj, key=lambda msp: msp[0].dbe)[0].dbe

            #max_dbe = max(self.mass_spectrum_obj, key=lambda msp: msp[0].dbe)[0].dbe

            #self.lookupTableSettings.use_pah_line_rule = False
            
            #self.lookupTableSettings.min_dbe = min_dbe/2#min_dbe - 7 if  (min_dbe - 7) &gt; 0 else 0
            
            #self.lookupTableSettings.max_dbe = max_dbe * 2 #max_dbe + 7
            
            self.mass_spectrum_obj.reset_indexes()

            self.mass_spectrum_obj.filter_by_noise_threshold()
            
            #initial_ox = deepcopy(self.mass_spectrum_obj.molecular_search_settings.usedAtoms)

            self.mass_spectrum_obj.molecular_search_settings.usedAtoms[&#39;O&#39;] = (min_o, max_o)

            self.nominal_mzs = self.mass_spectrum_obj.nominal_mz

        
        # get the most abundant peak and them every 14Da, only allow Ox and its derivatives
        print(&#34;Getting Oxygen Series&#34;)
        find_formula_thread = FindOxygenPeaks(self.mass_spectrum_obj, self.sql_db)
        find_formula_thread.run()
        
        #mass spec obj indexes are set to interate over only the peaks with a molecular formula candidate
        print(&#34;Getting Oxygen Series&#34;)
        find_formula_thread.set_mass_spec_indexes_by_found_peaks()
        
        #get the Ox class and the DBE for the lowest error molecular formula candidate
        dict_ox_class_and_ms_peak = self.ox_classes_and_peaks_in_order_()
                      
        # sort the classes by abundance
        print(&#34;Getting Oxygen Series Order&#34;)
        assign_classes_order_str_dict_tuple_list = self.get_classes_in_order(dict_ox_class_and_ms_peak)
        
        create_molecular_database()
                
        return assign_classes_order_str_dict_tuple_list
        
    def run_worker_mass_spectrum(self, assign_classes_order_tuples):
        
        def check_adduct_class(classe_dict):

            return any([key in classe_dict.keys() for key in self.mass_spectrum_obj.molecular_search_settings.adduct_atoms_neg])
        
        def set_min_max_dbe_by_oxygen(classe_dict):
            # calculates min and max DBE based on the Oxygen number
            # ref :https://pubs.acs.org/doi/full/10.1021/ac200464q
            # if class does not has O it use the pha rule
            # ref : Vlad Lobodin manuscript to be include here
            &#39;&#39;&#39;
            atoms_exchanges = [&#39;N&#39;]
            if &#39;O&#39; in classe_dict.keys():
                
                Oxygen_number = classe_dict.get(&#34;O&#34;)
                for atom in atoms_exchanges:
                    if atom in classe_dict.keys():
                        Oxygen_number += classe_dict.get(atom)

                self.mass_spectrum_obj.molecular_search_settings.min_dbe = (Oxygen_number/3) - 0.5 
                self.mass_spectrum_obj.molecular_search_settings.max_dbe = Oxygen_number*3 + 0.5 + 2
            
            else:
            &#39;&#39;&#39;    
            self.mass_spectrum_obj.molecular_search_settings.use_pah_line_rule = True

        def run_search(possible_formulas_dict, mass_spectrum_obj, min_abundance):
            
            all_assigned_indexes = list()
            
            for ms_peak in mass_spectrum_obj.sort_by_abundance():

                if ms_peak: continue
                #already assigned a molecular formula
               
                nominal_mz  = ms_peak.nominal_mz_exp

                #get mono isotopic peaks that was added a molecular formula obj
                #TODO update error variables

                possible_formulas_nominal = possible_formulas_dict.get(nominal_mz)
                
                if possible_formulas_nominal:

                    ms_peak_indexes = SearchMolecularFormulaWorker().find_formulas(possible_formulas_nominal, min_abundance, mass_spectrum_obj, ms_peak)    

                    all_assigned_indexes.extend(ms_peak_indexes)
            
            
            #filter peaks by percentile threshold of found isotopologues 
            all_assigned_indexes = MolecularFormulaSearchFilters().filter_isotopologue(all_assigned_indexes, mass_spectrum_obj)

            #filter noise by kendrick density
            all_assigned_indexes = MolecularFormulaSearchFilters().filter_kendrick(all_assigned_indexes, mass_spectrum_obj)

            #filter per min peaks per mono isotopic class
            # this function should always be the last filter, 
            # thefore no need to return remaining indexes
            MolecularFormulaSearchFilters().check_min_peaks(all_assigned_indexes, mass_spectrum_obj)

        #error_average = self.mass_spectrum_obj.molecular_search_settings.mz_error_average
        
        kdm_base = self.mass_spectrum_obj.mspeaks_settings.kendrick_base
        
        self.mass_spectrum_obj.change_kendrick_base_all_mspeaks(kdm_base)

        ClusteringFilter().filter_kendrick(self.mass_spectrum_obj)

        min_abundance = self.mass_spectrum_obj.min_abundance

        list_classes_str = [i[0] for i in assign_classes_order_tuples]

        pbar = tqdm.tqdm(assign_classes_order_tuples)
        
        dict_molecular_lookup_table = self.get_dict_molecular_database(list_classes_str)

        for classe_tuple in pbar:

            classe_str  = classe_tuple[0]
            classe_dict = classe_tuple[1]
            
            set_min_max_dbe_by_oxygen(classe_dict)
            
            #if len(classe_dict.keys()) == 2:
            #    if classe_dict.get(&#39;S&#39;) == 1:
            #       continue
            # limits the dbe by the Ox class most abundant,
            # need to add other atoms contribution to be more accurate
            # but +-7 should be sufficient to cover the range 
            
            if self.mass_spectrum_obj.molecular_search_settings.isProtonated:

                    #tqdm.set_description_str(desc=None, refresh=True)
                    pbar.set_description_str(desc=&#34;Started molecular formula search for class %s, (de)protonated &#34; % classe_str, refresh=True)

                    ion_type = Labels.protonated_de_ion

                    possible_formulas_dict = dict_molecular_lookup_table.get(ion_type).get(classe_str)
                    
                    if possible_formulas_dict:

                        run_search(possible_formulas_dict, self.mass_spectrum_obj, min_abundance)

            if self.mass_spectrum_obj.molecular_search_settings.isRadical:

                    #print(&#34;Started molecular formula search for class %s,  radical&#34; % classe_str)
                    pbar.set_description_str(desc=&#34;Started molecular formula search for class %s, radical&#34; % classe_str, refresh=True)

                    ion_type = Labels.radical_ion
                    
                    possible_formulas_dict = dict_molecular_lookup_table.get(ion_type).get(classe_str)
                    
                    if possible_formulas_dict:

                        run_search(possible_formulas_dict, self.mass_spectrum_obj, min_abundance)

            # looks for adduct, used_atom_valences should be 0 
            # this code does not support H exchance by halogen atoms
            if self.mass_spectrum_obj.molecular_search_settings.isAdduct:
                
                pbar.set_description_str(desc=&#34;Started molecular formula search for class %s, adduct&#34; % classe_str, refresh=True)
                #print(&#34;Started molecular formula search for class %s, adduct&#34; % classe_str)
                
                ion_type = Labels.radical_ion
                
                possible_formulas_dict = dict_molecular_lookup_table.get(ion_type).get(classe_str)

                possible_formulas_adduct =self.add_adducts(possible_formulas_dict)

                if possible_formulas_adduct:

                    run_search(possible_formulas_adduct, self.mass_spectrum_obj, min_abundance)
        
        
    def get_dict_molecular_database(self, classe_str_list):
        
        nominal_mzs = self.nominal_mzs
        mf_search_settings = self.mass_spectrum_obj.molecular_search_settings
        ion_charge = self.mass_spectrum_obj.polarity

        sql_db = MolForm_SQL(url=mf_search_settings.url_database)
        
        dict_res = {}

        if mf_search_settings.isProtonated:
            dict_res[Labels.protonated_de_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.protonated_de_ion, nominal_mzs, ion_charge, mf_search_settings)    
            
        if mf_search_settings.isRadical:
            dict_res[Labels.radical_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.radical_ion, nominal_mzs, ion_charge, mf_search_settings)    

        if mf_search_settings.isAdduct:
            
            adduct_list = mf_search_settings.adduct_atoms_neg if ion_charge &lt; 0 else mf_search_settings.adduct_atoms_pos
            dict_res[Labels.adduct_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.adduct_ion, nominal_mzs, ion_charge, mf_search_settings, adducts=adduct_list)    

        return dict_res

    def ox_classes_and_peaks_in_order_(self) -&gt; dict:
        # order is only valid in python 3.4 and above
        # change to OrderedDict if your version is lower
        dict_ox_class_and_ms_peak = dict()
        
        for mspeak in self.mass_spectrum_obj.sort_by_abundance(reverse=True):
            
            #change this filter to cia filter, give more option here, confidence, number of isotopologue found etc

            ox_classe = mspeak.best_molecular_formula_candidate.class_label
            
            if ox_classe in dict_ox_class_and_ms_peak.keys():
                
                #get the most abundant of the same ox class
                if mspeak.abundance &gt; dict_ox_class_and_ms_peak[ox_classe].abundance:

                    dict_ox_class_and_ms_peak[ox_classe] = (mspeak)
            else:
                    
                dict_ox_class_and_ms_peak[ox_classe] = (mspeak)
        
        return dict_ox_class_and_ms_peak

    def get_classes_in_order(self, dict_ox_class_and_ms_peak)-&gt; [(str, dict)]: 
        &#39;&#39;&#39; structure is 
            (&#39;HC&#39;, {&#39;HC&#39;: 1})&#39;&#39;&#39;
        
        usedAtoms = deepcopy(self.mass_spectrum_obj.molecular_search_settings.usedAtoms)
        
        usedAtoms.pop(&#34;C&#34;)
        usedAtoms.pop(&#34;H&#34;)
        usedAtoms.pop(&#34;O&#34;)

        min_n, max_n = usedAtoms.get(&#39;N&#39;) if usedAtoms.get(&#39;N&#39;) else (0,0)
        min_s, max_s = usedAtoms.get(&#39;S&#39;) if usedAtoms.get(&#39;S&#39;) else (0,0)
        min_p, max_p = usedAtoms.get(&#39;P&#39;) if usedAtoms.get(&#39;P&#39;) else (0,0)

        possible_n = [n for n in range(min_n, max_n + 1)]
        possible_s = [s for s in range(min_s, max_s + 1)]
        possible_p = [p for p in range(min_p, max_p + 1)]
        
        #used to enforce order for commum atoms 
        # and track the atom index in on the tuple in all_atoms_tuples
        atoms_in_order = [&#39;N&#39;, &#39;S&#39;, &#39;P&#39;]
        
        #do number atoms prodcut and remove then from the usedAtoms dict
        all_atoms_tuples = product(possible_n, possible_s, possible_p)
        for atom in atoms_in_order:
            
            usedAtoms.pop(atom, None)
        
        #iterate over other atoms besides C,H, N, O, S and P
        
        for selected_atom_label, min_max_tuple in usedAtoms.items():
            
            min_x = min_max_tuple[0]
            max_x = min_max_tuple[1]

            possible_x = [x for x in range(min_x, max_x + 1)]
            all_atoms_tuples = product(all_atoms_tuples, possible_x)
            
            #merge tuples
            all_atoms_tuples = [all_atoms_combined[0] + (all_atoms_combined[1],) for all_atoms_combined in
                                all_atoms_tuples]
            
            #add atom label to the atoms_in_order list
            
            #important to index where the atom position is in on the tuple in all_atoms_tuples
            atoms_in_order.append(selected_atom_label)

        classes_strings_dict_tuples, hc_class = self.get_class_strings_dict(all_atoms_tuples, atoms_in_order)

        combined_classes = self.combine_ox_class_with_other(atoms_in_order, classes_strings_dict_tuples, dict_ox_class_and_ms_peak)
        
        combination_classes_ordered = self.sort_classes(atoms_in_order, combined_classes)
        
        oxygen_class_str_dict_tuple = [(ox_class, mspeak[0].class_dict) for ox_class, mspeak in dict_ox_class_and_ms_peak.items()] 

        ## add classes together and ignores classes selected from the main series
        for class_tuple in  combination_classes_ordered:
            if class_tuple not in oxygen_class_str_dict_tuple:
                oxygen_class_str_dict_tuple.append(class_tuple)
        
        return oxygen_class_str_dict_tuple

    @staticmethod
    def get_class_strings_dict(all_atoms_tuples, atoms_in_order) -&gt; [(str, dict)]: 
        
        classe_list= []
        hc_class = []
        
        for all_atoms_tuple in all_atoms_tuples:
            
            classe_str = &#39;&#39;
            classe_dict = dict()
            
            for each_atoms_index, atoms_number in enumerate(all_atoms_tuple):
                
                if atoms_number != 0:
                    
                    classe_str = (classe_str + atoms_in_order[each_atoms_index] + str(atoms_number) + &#39; &#39;)
                    
                    classe_dict[atoms_in_order[each_atoms_index]] = atoms_number

            classe_str = classe_str.strip()
            
            if len(classe_str) &gt; 0:
            
                classe_list.append((classe_str,classe_dict))

            elif len(classe_str) == 0:

                hc_class.append((&#39;HC&#39;, {&#39;HC&#39;:1}))
        
        return classe_list, hc_class
    
    @staticmethod
    def combine_ox_class_with_other( atoms_in_order, classes_strings_dict_tuples, dict_ox_class_and_ms_peak) -&gt; [dict]:
        
        #sort methods that uses the key of classes dictionary and the atoms_in_order as reference
        # c_tuple[1] = class_dict, because is one key:value map we loop through keys and get the first item only 
        # sort by len first then sort based on the atoms_in_order list
        atoms_in_order = Atoms.atoms_order

        Oxygen_mfs = dict_ox_class_and_ms_peak.values()
        
        
        #sort_method = lambda word: (len(word[0]), [atoms_in_order.index(atom) for atom in list( word[1].keys())])
        
        #print(classes_strings_dict_tuples)
        #classe_in_order = sorted(classes_strings_dict_tuples, key = sort_method)
        #print(classe_in_order)
        
        combination = []
        
        # _ ignoring the class_str
        for _ , other_classe_dict in classes_strings_dict_tuples:
          
           #combination.extend([[other_classe_str + &#39; &#39; + Oxygen_mf[0].class_label , {**other_classe_dict, **Oxygen_mf[0].class_dict}] for Oxygen_mf in Oxygen_mfs])
           combination.extend([{**other_classe_dict, **Oxygen_mf[0].class_dict} for Oxygen_mf in Oxygen_mfs])
 
        return combination
    
    @staticmethod
    def sort_classes( atoms_in_order, combination_tuples) -&gt; [(str, dict)]: 
        
        join_list_of_list_classes = list()
        atoms_in_order =  [&#39;N&#39;,&#39;S&#39;,&#39;P&#39;,&#39;O&#39;] + atoms_in_order[3:]
        
        sort_method = lambda atoms_keys: [atoms_in_order.index(atoms_keys)] #(len(word[0]), print(word[1]))#[atoms_in_order.index(atom) for atom in list( word[1].keys())])
        for class_dict in combination_tuples:
            
            sorted_dict_keys = sorted(class_dict, key = sort_method)
            class_str = &#39; &#39;.join([atom + str(class_dict[atom]) for atom in sorted_dict_keys])
            new_class_dict = { atom: class_dict[atom] for atom in sorted_dict_keys}
            join_list_of_list_classes.append((class_str, new_class_dict))
        
        return join_list_of_list_classes
 
    def add_adducts(self, possible_formulas):
        
        ion_type = Labels.adduct_ion

        if self.mass_spectrum_obj.polarity &lt; 0:
            adduct_atoms = self.mass_spectrum_obj.molecular_search_settings.adduct_atoms_neg
            molform_model = MolecularFormulaTableNeg
        else:
            adduct_atoms = self.mass_spectrum_obj.molecular_search_settings.adduct_atoms_pos
            molform_model = MolecularFormulaTablePos

        new_dict = {}
        
        for nominal_mz, list_formulas in possible_formulas.items():
            
            for adduct_atom in adduct_atoms:
                
                adduct_atom_mass= Atoms.atomic_masses.get(adduct_atom) 

                for molecularFormulaTable in  list_formulas:
                    
                    formula_dict = json.loads(molecularFormulaTable.mol_formula)
                    
                    if adduct_atom in formula_dict.keys():
                        formula_dict[adduct_atom] += 1  
                    else:
                        formula_dict[adduct_atom] = 1      
                    
                    mz = adduct_atom_mass + molecularFormulaTable.mz
                    nm = int(mz)
                    
                    new_formul_obj = molform_model( **{&#34;mol_formula&#34; : json.dumps(formula_dict),
                                            &#34;mz&#34; : mz,
                                            &#34;ion_type&#34; : ion_type,
                                            &#34;nominal_mz&#34; : nm,
                                            &#34;ion_charge&#34; : molecularFormulaTable.ion_charge,
                                            &#34;classe&#34; : molecularFormulaTable.classe,
                                            &#34;C&#34; : molecularFormulaTable.C,
                                            &#34;H&#34; : molecularFormulaTable.H,
                                            &#34;N&#34; : molecularFormulaTable.N,
                                            &#34;O&#34; : molecularFormulaTable.O,
                                            &#34;S&#34; : molecularFormulaTable.S,
                                            &#34;P&#34; : molecularFormulaTable.P,
                                            &#34;H_C&#34; : molecularFormulaTable.H_C,
                                            &#34;O_C&#34; : molecularFormulaTable.O_C,
                                            &#34;DBE&#34; : molecularFormulaTable.DBE,
                                            })
                    if nm in new_dict:
                        new_dict[nm].append(new_formul_obj)
                    
                    else:
                        new_dict[nm]= [new_formul_obj]
                    
        return new_dict</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment"><code class="flex name class">
<span>class <span class="ident">OxygenPriorityAssignment</span></span>
<span>(</span><span>mass_spectrum_obj, sql_db=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that represents a thread of control.</p>
<p>This class can be safely subclassed in a limited fashion. There are two ways
to specify the activity: by passing a callable object to the constructor, or
by overriding the run() method in a subclass.</p>
<p>TODO:- add support for other atoms and adducts: Done
- add dbe range on search runtime : Done
- add docs
- improve performace : Done</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OxygenPriorityAssignment(Thread):

    def __init__(self, mass_spectrum_obj, sql_db=False):
        &#39;&#39;&#39;TODO:- add support for other atoms and adducts: Done
                - add dbe range on search runtime : Done
                - add docs
                - improve performace : Done 
        &#39;&#39;&#39;
        Thread.__init__(self)
        self.mass_spectrum_obj = mass_spectrum_obj
        #  initiated at create_molecular_database()
        #self.dict_molecular_lookup_table = None
        
        if not sql_db:

            self.sql_db = MolForm_SQL(url=mass_spectrum_obj.molecular_search_settings.url_database)
        
        else:
            
            self.sql_db = sql_db

    def run(self):
        
        # get Oxygen classes dict and the associate mspeak class 
        # list_of_classes_min_max_dbe = self.class_and_dbes_in_order()
        # create database separated to give the user the chance to use mass spec filters
             
        assign_classes_order_str_dict_tuple_list = self.create_data_base()
        
        if assign_classes_order_str_dict_tuple_list:
            
            self.run_worker_mass_spectrum(assign_classes_order_str_dict_tuple_list)
        
        else:
            
            raise RuntimeError(&#39;call create_data_base() first&#39;)

        self.sql_db.close()   

    def create_data_base(self):
        
        def create_molecular_database():
            
            # checks and creates the database entries for the specified heteroatomic classes 
            
            min_o = min(self.mass_spectrum_obj, key=lambda msp: msp[0][&#39;O&#39;])[0][&#39;O&#39;] - 2
            
            if min_o &lt;= 0:
                min_o = 1

            max_o = max(self.mass_spectrum_obj, key=lambda msp: msp[0][&#39;O&#39;])[0][&#39;O&#39;] + 2

            #min_dbe = min(self.mass_spectrum_obj, key=lambda msp: msp[0].dbe)[0].dbe

            #max_dbe = max(self.mass_spectrum_obj, key=lambda msp: msp[0].dbe)[0].dbe

            #self.lookupTableSettings.use_pah_line_rule = False
            
            #self.lookupTableSettings.min_dbe = min_dbe/2#min_dbe - 7 if  (min_dbe - 7) &gt; 0 else 0
            
            #self.lookupTableSettings.max_dbe = max_dbe * 2 #max_dbe + 7
            
            self.mass_spectrum_obj.reset_indexes()

            self.mass_spectrum_obj.filter_by_noise_threshold()
            
            #initial_ox = deepcopy(self.mass_spectrum_obj.molecular_search_settings.usedAtoms)

            self.mass_spectrum_obj.molecular_search_settings.usedAtoms[&#39;O&#39;] = (min_o, max_o)

            self.nominal_mzs = self.mass_spectrum_obj.nominal_mz

        
        # get the most abundant peak and them every 14Da, only allow Ox and its derivatives
        print(&#34;Getting Oxygen Series&#34;)
        find_formula_thread = FindOxygenPeaks(self.mass_spectrum_obj, self.sql_db)
        find_formula_thread.run()
        
        #mass spec obj indexes are set to interate over only the peaks with a molecular formula candidate
        print(&#34;Getting Oxygen Series&#34;)
        find_formula_thread.set_mass_spec_indexes_by_found_peaks()
        
        #get the Ox class and the DBE for the lowest error molecular formula candidate
        dict_ox_class_and_ms_peak = self.ox_classes_and_peaks_in_order_()
                      
        # sort the classes by abundance
        print(&#34;Getting Oxygen Series Order&#34;)
        assign_classes_order_str_dict_tuple_list = self.get_classes_in_order(dict_ox_class_and_ms_peak)
        
        create_molecular_database()
                
        return assign_classes_order_str_dict_tuple_list
        
    def run_worker_mass_spectrum(self, assign_classes_order_tuples):
        
        def check_adduct_class(classe_dict):

            return any([key in classe_dict.keys() for key in self.mass_spectrum_obj.molecular_search_settings.adduct_atoms_neg])
        
        def set_min_max_dbe_by_oxygen(classe_dict):
            # calculates min and max DBE based on the Oxygen number
            # ref :https://pubs.acs.org/doi/full/10.1021/ac200464q
            # if class does not has O it use the pha rule
            # ref : Vlad Lobodin manuscript to be include here
            &#39;&#39;&#39;
            atoms_exchanges = [&#39;N&#39;]
            if &#39;O&#39; in classe_dict.keys():
                
                Oxygen_number = classe_dict.get(&#34;O&#34;)
                for atom in atoms_exchanges:
                    if atom in classe_dict.keys():
                        Oxygen_number += classe_dict.get(atom)

                self.mass_spectrum_obj.molecular_search_settings.min_dbe = (Oxygen_number/3) - 0.5 
                self.mass_spectrum_obj.molecular_search_settings.max_dbe = Oxygen_number*3 + 0.5 + 2
            
            else:
            &#39;&#39;&#39;    
            self.mass_spectrum_obj.molecular_search_settings.use_pah_line_rule = True

        def run_search(possible_formulas_dict, mass_spectrum_obj, min_abundance):
            
            all_assigned_indexes = list()
            
            for ms_peak in mass_spectrum_obj.sort_by_abundance():

                if ms_peak: continue
                #already assigned a molecular formula
               
                nominal_mz  = ms_peak.nominal_mz_exp

                #get mono isotopic peaks that was added a molecular formula obj
                #TODO update error variables

                possible_formulas_nominal = possible_formulas_dict.get(nominal_mz)
                
                if possible_formulas_nominal:

                    ms_peak_indexes = SearchMolecularFormulaWorker().find_formulas(possible_formulas_nominal, min_abundance, mass_spectrum_obj, ms_peak)    

                    all_assigned_indexes.extend(ms_peak_indexes)
            
            
            #filter peaks by percentile threshold of found isotopologues 
            all_assigned_indexes = MolecularFormulaSearchFilters().filter_isotopologue(all_assigned_indexes, mass_spectrum_obj)

            #filter noise by kendrick density
            all_assigned_indexes = MolecularFormulaSearchFilters().filter_kendrick(all_assigned_indexes, mass_spectrum_obj)

            #filter per min peaks per mono isotopic class
            # this function should always be the last filter, 
            # thefore no need to return remaining indexes
            MolecularFormulaSearchFilters().check_min_peaks(all_assigned_indexes, mass_spectrum_obj)

        #error_average = self.mass_spectrum_obj.molecular_search_settings.mz_error_average
        
        kdm_base = self.mass_spectrum_obj.mspeaks_settings.kendrick_base
        
        self.mass_spectrum_obj.change_kendrick_base_all_mspeaks(kdm_base)

        ClusteringFilter().filter_kendrick(self.mass_spectrum_obj)

        min_abundance = self.mass_spectrum_obj.min_abundance

        list_classes_str = [i[0] for i in assign_classes_order_tuples]

        pbar = tqdm.tqdm(assign_classes_order_tuples)
        
        dict_molecular_lookup_table = self.get_dict_molecular_database(list_classes_str)

        for classe_tuple in pbar:

            classe_str  = classe_tuple[0]
            classe_dict = classe_tuple[1]
            
            set_min_max_dbe_by_oxygen(classe_dict)
            
            #if len(classe_dict.keys()) == 2:
            #    if classe_dict.get(&#39;S&#39;) == 1:
            #       continue
            # limits the dbe by the Ox class most abundant,
            # need to add other atoms contribution to be more accurate
            # but +-7 should be sufficient to cover the range 
            
            if self.mass_spectrum_obj.molecular_search_settings.isProtonated:

                    #tqdm.set_description_str(desc=None, refresh=True)
                    pbar.set_description_str(desc=&#34;Started molecular formula search for class %s, (de)protonated &#34; % classe_str, refresh=True)

                    ion_type = Labels.protonated_de_ion

                    possible_formulas_dict = dict_molecular_lookup_table.get(ion_type).get(classe_str)
                    
                    if possible_formulas_dict:

                        run_search(possible_formulas_dict, self.mass_spectrum_obj, min_abundance)

            if self.mass_spectrum_obj.molecular_search_settings.isRadical:

                    #print(&#34;Started molecular formula search for class %s,  radical&#34; % classe_str)
                    pbar.set_description_str(desc=&#34;Started molecular formula search for class %s, radical&#34; % classe_str, refresh=True)

                    ion_type = Labels.radical_ion
                    
                    possible_formulas_dict = dict_molecular_lookup_table.get(ion_type).get(classe_str)
                    
                    if possible_formulas_dict:

                        run_search(possible_formulas_dict, self.mass_spectrum_obj, min_abundance)

            # looks for adduct, used_atom_valences should be 0 
            # this code does not support H exchance by halogen atoms
            if self.mass_spectrum_obj.molecular_search_settings.isAdduct:
                
                pbar.set_description_str(desc=&#34;Started molecular formula search for class %s, adduct&#34; % classe_str, refresh=True)
                #print(&#34;Started molecular formula search for class %s, adduct&#34; % classe_str)
                
                ion_type = Labels.radical_ion
                
                possible_formulas_dict = dict_molecular_lookup_table.get(ion_type).get(classe_str)

                possible_formulas_adduct =self.add_adducts(possible_formulas_dict)

                if possible_formulas_adduct:

                    run_search(possible_formulas_adduct, self.mass_spectrum_obj, min_abundance)
        
        
    def get_dict_molecular_database(self, classe_str_list):
        
        nominal_mzs = self.nominal_mzs
        mf_search_settings = self.mass_spectrum_obj.molecular_search_settings
        ion_charge = self.mass_spectrum_obj.polarity

        sql_db = MolForm_SQL(url=mf_search_settings.url_database)
        
        dict_res = {}

        if mf_search_settings.isProtonated:
            dict_res[Labels.protonated_de_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.protonated_de_ion, nominal_mzs, ion_charge, mf_search_settings)    
            
        if mf_search_settings.isRadical:
            dict_res[Labels.radical_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.radical_ion, nominal_mzs, ion_charge, mf_search_settings)    

        if mf_search_settings.isAdduct:
            
            adduct_list = mf_search_settings.adduct_atoms_neg if ion_charge &lt; 0 else mf_search_settings.adduct_atoms_pos
            dict_res[Labels.adduct_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.adduct_ion, nominal_mzs, ion_charge, mf_search_settings, adducts=adduct_list)    

        return dict_res

    def ox_classes_and_peaks_in_order_(self) -&gt; dict:
        # order is only valid in python 3.4 and above
        # change to OrderedDict if your version is lower
        dict_ox_class_and_ms_peak = dict()
        
        for mspeak in self.mass_spectrum_obj.sort_by_abundance(reverse=True):
            
            #change this filter to cia filter, give more option here, confidence, number of isotopologue found etc

            ox_classe = mspeak.best_molecular_formula_candidate.class_label
            
            if ox_classe in dict_ox_class_and_ms_peak.keys():
                
                #get the most abundant of the same ox class
                if mspeak.abundance &gt; dict_ox_class_and_ms_peak[ox_classe].abundance:

                    dict_ox_class_and_ms_peak[ox_classe] = (mspeak)
            else:
                    
                dict_ox_class_and_ms_peak[ox_classe] = (mspeak)
        
        return dict_ox_class_and_ms_peak

    def get_classes_in_order(self, dict_ox_class_and_ms_peak)-&gt; [(str, dict)]: 
        &#39;&#39;&#39; structure is 
            (&#39;HC&#39;, {&#39;HC&#39;: 1})&#39;&#39;&#39;
        
        usedAtoms = deepcopy(self.mass_spectrum_obj.molecular_search_settings.usedAtoms)
        
        usedAtoms.pop(&#34;C&#34;)
        usedAtoms.pop(&#34;H&#34;)
        usedAtoms.pop(&#34;O&#34;)

        min_n, max_n = usedAtoms.get(&#39;N&#39;) if usedAtoms.get(&#39;N&#39;) else (0,0)
        min_s, max_s = usedAtoms.get(&#39;S&#39;) if usedAtoms.get(&#39;S&#39;) else (0,0)
        min_p, max_p = usedAtoms.get(&#39;P&#39;) if usedAtoms.get(&#39;P&#39;) else (0,0)

        possible_n = [n for n in range(min_n, max_n + 1)]
        possible_s = [s for s in range(min_s, max_s + 1)]
        possible_p = [p for p in range(min_p, max_p + 1)]
        
        #used to enforce order for commum atoms 
        # and track the atom index in on the tuple in all_atoms_tuples
        atoms_in_order = [&#39;N&#39;, &#39;S&#39;, &#39;P&#39;]
        
        #do number atoms prodcut and remove then from the usedAtoms dict
        all_atoms_tuples = product(possible_n, possible_s, possible_p)
        for atom in atoms_in_order:
            
            usedAtoms.pop(atom, None)
        
        #iterate over other atoms besides C,H, N, O, S and P
        
        for selected_atom_label, min_max_tuple in usedAtoms.items():
            
            min_x = min_max_tuple[0]
            max_x = min_max_tuple[1]

            possible_x = [x for x in range(min_x, max_x + 1)]
            all_atoms_tuples = product(all_atoms_tuples, possible_x)
            
            #merge tuples
            all_atoms_tuples = [all_atoms_combined[0] + (all_atoms_combined[1],) for all_atoms_combined in
                                all_atoms_tuples]
            
            #add atom label to the atoms_in_order list
            
            #important to index where the atom position is in on the tuple in all_atoms_tuples
            atoms_in_order.append(selected_atom_label)

        classes_strings_dict_tuples, hc_class = self.get_class_strings_dict(all_atoms_tuples, atoms_in_order)

        combined_classes = self.combine_ox_class_with_other(atoms_in_order, classes_strings_dict_tuples, dict_ox_class_and_ms_peak)
        
        combination_classes_ordered = self.sort_classes(atoms_in_order, combined_classes)
        
        oxygen_class_str_dict_tuple = [(ox_class, mspeak[0].class_dict) for ox_class, mspeak in dict_ox_class_and_ms_peak.items()] 

        ## add classes together and ignores classes selected from the main series
        for class_tuple in  combination_classes_ordered:
            if class_tuple not in oxygen_class_str_dict_tuple:
                oxygen_class_str_dict_tuple.append(class_tuple)
        
        return oxygen_class_str_dict_tuple

    @staticmethod
    def get_class_strings_dict(all_atoms_tuples, atoms_in_order) -&gt; [(str, dict)]: 
        
        classe_list= []
        hc_class = []
        
        for all_atoms_tuple in all_atoms_tuples:
            
            classe_str = &#39;&#39;
            classe_dict = dict()
            
            for each_atoms_index, atoms_number in enumerate(all_atoms_tuple):
                
                if atoms_number != 0:
                    
                    classe_str = (classe_str + atoms_in_order[each_atoms_index] + str(atoms_number) + &#39; &#39;)
                    
                    classe_dict[atoms_in_order[each_atoms_index]] = atoms_number

            classe_str = classe_str.strip()
            
            if len(classe_str) &gt; 0:
            
                classe_list.append((classe_str,classe_dict))

            elif len(classe_str) == 0:

                hc_class.append((&#39;HC&#39;, {&#39;HC&#39;:1}))
        
        return classe_list, hc_class
    
    @staticmethod
    def combine_ox_class_with_other( atoms_in_order, classes_strings_dict_tuples, dict_ox_class_and_ms_peak) -&gt; [dict]:
        
        #sort methods that uses the key of classes dictionary and the atoms_in_order as reference
        # c_tuple[1] = class_dict, because is one key:value map we loop through keys and get the first item only 
        # sort by len first then sort based on the atoms_in_order list
        atoms_in_order = Atoms.atoms_order

        Oxygen_mfs = dict_ox_class_and_ms_peak.values()
        
        
        #sort_method = lambda word: (len(word[0]), [atoms_in_order.index(atom) for atom in list( word[1].keys())])
        
        #print(classes_strings_dict_tuples)
        #classe_in_order = sorted(classes_strings_dict_tuples, key = sort_method)
        #print(classe_in_order)
        
        combination = []
        
        # _ ignoring the class_str
        for _ , other_classe_dict in classes_strings_dict_tuples:
          
           #combination.extend([[other_classe_str + &#39; &#39; + Oxygen_mf[0].class_label , {**other_classe_dict, **Oxygen_mf[0].class_dict}] for Oxygen_mf in Oxygen_mfs])
           combination.extend([{**other_classe_dict, **Oxygen_mf[0].class_dict} for Oxygen_mf in Oxygen_mfs])
 
        return combination
    
    @staticmethod
    def sort_classes( atoms_in_order, combination_tuples) -&gt; [(str, dict)]: 
        
        join_list_of_list_classes = list()
        atoms_in_order =  [&#39;N&#39;,&#39;S&#39;,&#39;P&#39;,&#39;O&#39;] + atoms_in_order[3:]
        
        sort_method = lambda atoms_keys: [atoms_in_order.index(atoms_keys)] #(len(word[0]), print(word[1]))#[atoms_in_order.index(atom) for atom in list( word[1].keys())])
        for class_dict in combination_tuples:
            
            sorted_dict_keys = sorted(class_dict, key = sort_method)
            class_str = &#39; &#39;.join([atom + str(class_dict[atom]) for atom in sorted_dict_keys])
            new_class_dict = { atom: class_dict[atom] for atom in sorted_dict_keys}
            join_list_of_list_classes.append((class_str, new_class_dict))
        
        return join_list_of_list_classes
 
    def add_adducts(self, possible_formulas):
        
        ion_type = Labels.adduct_ion

        if self.mass_spectrum_obj.polarity &lt; 0:
            adduct_atoms = self.mass_spectrum_obj.molecular_search_settings.adduct_atoms_neg
            molform_model = MolecularFormulaTableNeg
        else:
            adduct_atoms = self.mass_spectrum_obj.molecular_search_settings.adduct_atoms_pos
            molform_model = MolecularFormulaTablePos

        new_dict = {}
        
        for nominal_mz, list_formulas in possible_formulas.items():
            
            for adduct_atom in adduct_atoms:
                
                adduct_atom_mass= Atoms.atomic_masses.get(adduct_atom) 

                for molecularFormulaTable in  list_formulas:
                    
                    formula_dict = json.loads(molecularFormulaTable.mol_formula)
                    
                    if adduct_atom in formula_dict.keys():
                        formula_dict[adduct_atom] += 1  
                    else:
                        formula_dict[adduct_atom] = 1      
                    
                    mz = adduct_atom_mass + molecularFormulaTable.mz
                    nm = int(mz)
                    
                    new_formul_obj = molform_model( **{&#34;mol_formula&#34; : json.dumps(formula_dict),
                                            &#34;mz&#34; : mz,
                                            &#34;ion_type&#34; : ion_type,
                                            &#34;nominal_mz&#34; : nm,
                                            &#34;ion_charge&#34; : molecularFormulaTable.ion_charge,
                                            &#34;classe&#34; : molecularFormulaTable.classe,
                                            &#34;C&#34; : molecularFormulaTable.C,
                                            &#34;H&#34; : molecularFormulaTable.H,
                                            &#34;N&#34; : molecularFormulaTable.N,
                                            &#34;O&#34; : molecularFormulaTable.O,
                                            &#34;S&#34; : molecularFormulaTable.S,
                                            &#34;P&#34; : molecularFormulaTable.P,
                                            &#34;H_C&#34; : molecularFormulaTable.H_C,
                                            &#34;O_C&#34; : molecularFormulaTable.O_C,
                                            &#34;DBE&#34; : molecularFormulaTable.DBE,
                                            })
                    if nm in new_dict:
                        new_dict[nm].append(new_formul_obj)
                    
                    else:
                        new_dict[nm]= [new_formul_obj]
                    
        return new_dict</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.combine_ox_class_with_other"><code class="name flex">
<span>def <span class="ident">combine_ox_class_with_other</span></span>(<span>atoms_in_order, classes_strings_dict_tuples, dict_ox_class_and_ms_peak) ‑> [<class 'dict'>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def combine_ox_class_with_other( atoms_in_order, classes_strings_dict_tuples, dict_ox_class_and_ms_peak) -&gt; [dict]:
    
    #sort methods that uses the key of classes dictionary and the atoms_in_order as reference
    # c_tuple[1] = class_dict, because is one key:value map we loop through keys and get the first item only 
    # sort by len first then sort based on the atoms_in_order list
    atoms_in_order = Atoms.atoms_order

    Oxygen_mfs = dict_ox_class_and_ms_peak.values()
    
    
    #sort_method = lambda word: (len(word[0]), [atoms_in_order.index(atom) for atom in list( word[1].keys())])
    
    #print(classes_strings_dict_tuples)
    #classe_in_order = sorted(classes_strings_dict_tuples, key = sort_method)
    #print(classe_in_order)
    
    combination = []
    
    # _ ignoring the class_str
    for _ , other_classe_dict in classes_strings_dict_tuples:
      
       #combination.extend([[other_classe_str + &#39; &#39; + Oxygen_mf[0].class_label , {**other_classe_dict, **Oxygen_mf[0].class_dict}] for Oxygen_mf in Oxygen_mfs])
       combination.extend([{**other_classe_dict, **Oxygen_mf[0].class_dict} for Oxygen_mf in Oxygen_mfs])

    return combination</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.get_class_strings_dict"><code class="name flex">
<span>def <span class="ident">get_class_strings_dict</span></span>(<span>all_atoms_tuples, atoms_in_order) ‑> [(<class 'str'>, <class 'dict'>)]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_class_strings_dict(all_atoms_tuples, atoms_in_order) -&gt; [(str, dict)]: 
    
    classe_list= []
    hc_class = []
    
    for all_atoms_tuple in all_atoms_tuples:
        
        classe_str = &#39;&#39;
        classe_dict = dict()
        
        for each_atoms_index, atoms_number in enumerate(all_atoms_tuple):
            
            if atoms_number != 0:
                
                classe_str = (classe_str + atoms_in_order[each_atoms_index] + str(atoms_number) + &#39; &#39;)
                
                classe_dict[atoms_in_order[each_atoms_index]] = atoms_number

        classe_str = classe_str.strip()
        
        if len(classe_str) &gt; 0:
        
            classe_list.append((classe_str,classe_dict))

        elif len(classe_str) == 0:

            hc_class.append((&#39;HC&#39;, {&#39;HC&#39;:1}))
    
    return classe_list, hc_class</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.sort_classes"><code class="name flex">
<span>def <span class="ident">sort_classes</span></span>(<span>atoms_in_order, combination_tuples) ‑> [(<class 'str'>, <class 'dict'>)]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sort_classes( atoms_in_order, combination_tuples) -&gt; [(str, dict)]: 
    
    join_list_of_list_classes = list()
    atoms_in_order =  [&#39;N&#39;,&#39;S&#39;,&#39;P&#39;,&#39;O&#39;] + atoms_in_order[3:]
    
    sort_method = lambda atoms_keys: [atoms_in_order.index(atoms_keys)] #(len(word[0]), print(word[1]))#[atoms_in_order.index(atom) for atom in list( word[1].keys())])
    for class_dict in combination_tuples:
        
        sorted_dict_keys = sorted(class_dict, key = sort_method)
        class_str = &#39; &#39;.join([atom + str(class_dict[atom]) for atom in sorted_dict_keys])
        new_class_dict = { atom: class_dict[atom] for atom in sorted_dict_keys}
        join_list_of_list_classes.append((class_str, new_class_dict))
    
    return join_list_of_list_classes</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.add_adducts"><code class="name flex">
<span>def <span class="ident">add_adducts</span></span>(<span>self, possible_formulas)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_adducts(self, possible_formulas):
    
    ion_type = Labels.adduct_ion

    if self.mass_spectrum_obj.polarity &lt; 0:
        adduct_atoms = self.mass_spectrum_obj.molecular_search_settings.adduct_atoms_neg
        molform_model = MolecularFormulaTableNeg
    else:
        adduct_atoms = self.mass_spectrum_obj.molecular_search_settings.adduct_atoms_pos
        molform_model = MolecularFormulaTablePos

    new_dict = {}
    
    for nominal_mz, list_formulas in possible_formulas.items():
        
        for adduct_atom in adduct_atoms:
            
            adduct_atom_mass= Atoms.atomic_masses.get(adduct_atom) 

            for molecularFormulaTable in  list_formulas:
                
                formula_dict = json.loads(molecularFormulaTable.mol_formula)
                
                if adduct_atom in formula_dict.keys():
                    formula_dict[adduct_atom] += 1  
                else:
                    formula_dict[adduct_atom] = 1      
                
                mz = adduct_atom_mass + molecularFormulaTable.mz
                nm = int(mz)
                
                new_formul_obj = molform_model( **{&#34;mol_formula&#34; : json.dumps(formula_dict),
                                        &#34;mz&#34; : mz,
                                        &#34;ion_type&#34; : ion_type,
                                        &#34;nominal_mz&#34; : nm,
                                        &#34;ion_charge&#34; : molecularFormulaTable.ion_charge,
                                        &#34;classe&#34; : molecularFormulaTable.classe,
                                        &#34;C&#34; : molecularFormulaTable.C,
                                        &#34;H&#34; : molecularFormulaTable.H,
                                        &#34;N&#34; : molecularFormulaTable.N,
                                        &#34;O&#34; : molecularFormulaTable.O,
                                        &#34;S&#34; : molecularFormulaTable.S,
                                        &#34;P&#34; : molecularFormulaTable.P,
                                        &#34;H_C&#34; : molecularFormulaTable.H_C,
                                        &#34;O_C&#34; : molecularFormulaTable.O_C,
                                        &#34;DBE&#34; : molecularFormulaTable.DBE,
                                        })
                if nm in new_dict:
                    new_dict[nm].append(new_formul_obj)
                
                else:
                    new_dict[nm]= [new_formul_obj]
                
    return new_dict</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.create_data_base"><code class="name flex">
<span>def <span class="ident">create_data_base</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_data_base(self):
    
    def create_molecular_database():
        
        # checks and creates the database entries for the specified heteroatomic classes 
        
        min_o = min(self.mass_spectrum_obj, key=lambda msp: msp[0][&#39;O&#39;])[0][&#39;O&#39;] - 2
        
        if min_o &lt;= 0:
            min_o = 1

        max_o = max(self.mass_spectrum_obj, key=lambda msp: msp[0][&#39;O&#39;])[0][&#39;O&#39;] + 2

        #min_dbe = min(self.mass_spectrum_obj, key=lambda msp: msp[0].dbe)[0].dbe

        #max_dbe = max(self.mass_spectrum_obj, key=lambda msp: msp[0].dbe)[0].dbe

        #self.lookupTableSettings.use_pah_line_rule = False
        
        #self.lookupTableSettings.min_dbe = min_dbe/2#min_dbe - 7 if  (min_dbe - 7) &gt; 0 else 0
        
        #self.lookupTableSettings.max_dbe = max_dbe * 2 #max_dbe + 7
        
        self.mass_spectrum_obj.reset_indexes()

        self.mass_spectrum_obj.filter_by_noise_threshold()
        
        #initial_ox = deepcopy(self.mass_spectrum_obj.molecular_search_settings.usedAtoms)

        self.mass_spectrum_obj.molecular_search_settings.usedAtoms[&#39;O&#39;] = (min_o, max_o)

        self.nominal_mzs = self.mass_spectrum_obj.nominal_mz

    
    # get the most abundant peak and them every 14Da, only allow Ox and its derivatives
    print(&#34;Getting Oxygen Series&#34;)
    find_formula_thread = FindOxygenPeaks(self.mass_spectrum_obj, self.sql_db)
    find_formula_thread.run()
    
    #mass spec obj indexes are set to interate over only the peaks with a molecular formula candidate
    print(&#34;Getting Oxygen Series&#34;)
    find_formula_thread.set_mass_spec_indexes_by_found_peaks()
    
    #get the Ox class and the DBE for the lowest error molecular formula candidate
    dict_ox_class_and_ms_peak = self.ox_classes_and_peaks_in_order_()
                  
    # sort the classes by abundance
    print(&#34;Getting Oxygen Series Order&#34;)
    assign_classes_order_str_dict_tuple_list = self.get_classes_in_order(dict_ox_class_and_ms_peak)
    
    create_molecular_database()
            
    return assign_classes_order_str_dict_tuple_list</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.get_classes_in_order"><code class="name flex">
<span>def <span class="ident">get_classes_in_order</span></span>(<span>self, dict_ox_class_and_ms_peak) ‑> [(<class 'str'>, <class 'dict'>)]</span>
</code></dt>
<dd>
<div class="desc"><p>structure is
('HC', {'HC': 1})</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_classes_in_order(self, dict_ox_class_and_ms_peak)-&gt; [(str, dict)]: 
    &#39;&#39;&#39; structure is 
        (&#39;HC&#39;, {&#39;HC&#39;: 1})&#39;&#39;&#39;
    
    usedAtoms = deepcopy(self.mass_spectrum_obj.molecular_search_settings.usedAtoms)
    
    usedAtoms.pop(&#34;C&#34;)
    usedAtoms.pop(&#34;H&#34;)
    usedAtoms.pop(&#34;O&#34;)

    min_n, max_n = usedAtoms.get(&#39;N&#39;) if usedAtoms.get(&#39;N&#39;) else (0,0)
    min_s, max_s = usedAtoms.get(&#39;S&#39;) if usedAtoms.get(&#39;S&#39;) else (0,0)
    min_p, max_p = usedAtoms.get(&#39;P&#39;) if usedAtoms.get(&#39;P&#39;) else (0,0)

    possible_n = [n for n in range(min_n, max_n + 1)]
    possible_s = [s for s in range(min_s, max_s + 1)]
    possible_p = [p for p in range(min_p, max_p + 1)]
    
    #used to enforce order for commum atoms 
    # and track the atom index in on the tuple in all_atoms_tuples
    atoms_in_order = [&#39;N&#39;, &#39;S&#39;, &#39;P&#39;]
    
    #do number atoms prodcut and remove then from the usedAtoms dict
    all_atoms_tuples = product(possible_n, possible_s, possible_p)
    for atom in atoms_in_order:
        
        usedAtoms.pop(atom, None)
    
    #iterate over other atoms besides C,H, N, O, S and P
    
    for selected_atom_label, min_max_tuple in usedAtoms.items():
        
        min_x = min_max_tuple[0]
        max_x = min_max_tuple[1]

        possible_x = [x for x in range(min_x, max_x + 1)]
        all_atoms_tuples = product(all_atoms_tuples, possible_x)
        
        #merge tuples
        all_atoms_tuples = [all_atoms_combined[0] + (all_atoms_combined[1],) for all_atoms_combined in
                            all_atoms_tuples]
        
        #add atom label to the atoms_in_order list
        
        #important to index where the atom position is in on the tuple in all_atoms_tuples
        atoms_in_order.append(selected_atom_label)

    classes_strings_dict_tuples, hc_class = self.get_class_strings_dict(all_atoms_tuples, atoms_in_order)

    combined_classes = self.combine_ox_class_with_other(atoms_in_order, classes_strings_dict_tuples, dict_ox_class_and_ms_peak)
    
    combination_classes_ordered = self.sort_classes(atoms_in_order, combined_classes)
    
    oxygen_class_str_dict_tuple = [(ox_class, mspeak[0].class_dict) for ox_class, mspeak in dict_ox_class_and_ms_peak.items()] 

    ## add classes together and ignores classes selected from the main series
    for class_tuple in  combination_classes_ordered:
        if class_tuple not in oxygen_class_str_dict_tuple:
            oxygen_class_str_dict_tuple.append(class_tuple)
    
    return oxygen_class_str_dict_tuple</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.get_dict_molecular_database"><code class="name flex">
<span>def <span class="ident">get_dict_molecular_database</span></span>(<span>self, classe_str_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dict_molecular_database(self, classe_str_list):
    
    nominal_mzs = self.nominal_mzs
    mf_search_settings = self.mass_spectrum_obj.molecular_search_settings
    ion_charge = self.mass_spectrum_obj.polarity

    sql_db = MolForm_SQL(url=mf_search_settings.url_database)
    
    dict_res = {}

    if mf_search_settings.isProtonated:
        dict_res[Labels.protonated_de_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.protonated_de_ion, nominal_mzs, ion_charge, mf_search_settings)    
        
    if mf_search_settings.isRadical:
        dict_res[Labels.radical_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.radical_ion, nominal_mzs, ion_charge, mf_search_settings)    

    if mf_search_settings.isAdduct:
        
        adduct_list = mf_search_settings.adduct_atoms_neg if ion_charge &lt; 0 else mf_search_settings.adduct_atoms_pos
        dict_res[Labels.adduct_ion] = sql_db.get_dict_by_classes(classe_str_list, Labels.adduct_ion, nominal_mzs, ion_charge, mf_search_settings, adducts=adduct_list)    

    return dict_res</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.ox_classes_and_peaks_in_order_"><code class="name flex">
<span>def <span class="ident">ox_classes_and_peaks_in_order_</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ox_classes_and_peaks_in_order_(self) -&gt; dict:
    # order is only valid in python 3.4 and above
    # change to OrderedDict if your version is lower
    dict_ox_class_and_ms_peak = dict()
    
    for mspeak in self.mass_spectrum_obj.sort_by_abundance(reverse=True):
        
        #change this filter to cia filter, give more option here, confidence, number of isotopologue found etc

        ox_classe = mspeak.best_molecular_formula_candidate.class_label
        
        if ox_classe in dict_ox_class_and_ms_peak.keys():
            
            #get the most abundant of the same ox class
            if mspeak.abundance &gt; dict_ox_class_and_ms_peak[ox_classe].abundance:

                dict_ox_class_and_ms_peak[ox_classe] = (mspeak)
        else:
                
            dict_ox_class_and_ms_peak[ox_classe] = (mspeak)
    
    return dict_ox_class_and_ms_peak</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method representing the thread's activity.</p>
<p>You may override this method in a subclass. The standard run() method
invokes the callable object passed to the object's constructor as the
target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    
    # get Oxygen classes dict and the associate mspeak class 
    # list_of_classes_min_max_dbe = self.class_and_dbes_in_order()
    # create database separated to give the user the chance to use mass spec filters
         
    assign_classes_order_str_dict_tuple_list = self.create_data_base()
    
    if assign_classes_order_str_dict_tuple_list:
        
        self.run_worker_mass_spectrum(assign_classes_order_str_dict_tuple_list)
    
    else:
        
        raise RuntimeError(&#39;call create_data_base() first&#39;)

    self.sql_db.close()   </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.run_worker_mass_spectrum"><code class="name flex">
<span>def <span class="ident">run_worker_mass_spectrum</span></span>(<span>self, assign_classes_order_tuples)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_worker_mass_spectrum(self, assign_classes_order_tuples):
    
    def check_adduct_class(classe_dict):

        return any([key in classe_dict.keys() for key in self.mass_spectrum_obj.molecular_search_settings.adduct_atoms_neg])
    
    def set_min_max_dbe_by_oxygen(classe_dict):
        # calculates min and max DBE based on the Oxygen number
        # ref :https://pubs.acs.org/doi/full/10.1021/ac200464q
        # if class does not has O it use the pha rule
        # ref : Vlad Lobodin manuscript to be include here
        &#39;&#39;&#39;
        atoms_exchanges = [&#39;N&#39;]
        if &#39;O&#39; in classe_dict.keys():
            
            Oxygen_number = classe_dict.get(&#34;O&#34;)
            for atom in atoms_exchanges:
                if atom in classe_dict.keys():
                    Oxygen_number += classe_dict.get(atom)

            self.mass_spectrum_obj.molecular_search_settings.min_dbe = (Oxygen_number/3) - 0.5 
            self.mass_spectrum_obj.molecular_search_settings.max_dbe = Oxygen_number*3 + 0.5 + 2
        
        else:
        &#39;&#39;&#39;    
        self.mass_spectrum_obj.molecular_search_settings.use_pah_line_rule = True

    def run_search(possible_formulas_dict, mass_spectrum_obj, min_abundance):
        
        all_assigned_indexes = list()
        
        for ms_peak in mass_spectrum_obj.sort_by_abundance():

            if ms_peak: continue
            #already assigned a molecular formula
           
            nominal_mz  = ms_peak.nominal_mz_exp

            #get mono isotopic peaks that was added a molecular formula obj
            #TODO update error variables

            possible_formulas_nominal = possible_formulas_dict.get(nominal_mz)
            
            if possible_formulas_nominal:

                ms_peak_indexes = SearchMolecularFormulaWorker().find_formulas(possible_formulas_nominal, min_abundance, mass_spectrum_obj, ms_peak)    

                all_assigned_indexes.extend(ms_peak_indexes)
        
        
        #filter peaks by percentile threshold of found isotopologues 
        all_assigned_indexes = MolecularFormulaSearchFilters().filter_isotopologue(all_assigned_indexes, mass_spectrum_obj)

        #filter noise by kendrick density
        all_assigned_indexes = MolecularFormulaSearchFilters().filter_kendrick(all_assigned_indexes, mass_spectrum_obj)

        #filter per min peaks per mono isotopic class
        # this function should always be the last filter, 
        # thefore no need to return remaining indexes
        MolecularFormulaSearchFilters().check_min_peaks(all_assigned_indexes, mass_spectrum_obj)

    #error_average = self.mass_spectrum_obj.molecular_search_settings.mz_error_average
    
    kdm_base = self.mass_spectrum_obj.mspeaks_settings.kendrick_base
    
    self.mass_spectrum_obj.change_kendrick_base_all_mspeaks(kdm_base)

    ClusteringFilter().filter_kendrick(self.mass_spectrum_obj)

    min_abundance = self.mass_spectrum_obj.min_abundance

    list_classes_str = [i[0] for i in assign_classes_order_tuples]

    pbar = tqdm.tqdm(assign_classes_order_tuples)
    
    dict_molecular_lookup_table = self.get_dict_molecular_database(list_classes_str)

    for classe_tuple in pbar:

        classe_str  = classe_tuple[0]
        classe_dict = classe_tuple[1]
        
        set_min_max_dbe_by_oxygen(classe_dict)
        
        #if len(classe_dict.keys()) == 2:
        #    if classe_dict.get(&#39;S&#39;) == 1:
        #       continue
        # limits the dbe by the Ox class most abundant,
        # need to add other atoms contribution to be more accurate
        # but +-7 should be sufficient to cover the range 
        
        if self.mass_spectrum_obj.molecular_search_settings.isProtonated:

                #tqdm.set_description_str(desc=None, refresh=True)
                pbar.set_description_str(desc=&#34;Started molecular formula search for class %s, (de)protonated &#34; % classe_str, refresh=True)

                ion_type = Labels.protonated_de_ion

                possible_formulas_dict = dict_molecular_lookup_table.get(ion_type).get(classe_str)
                
                if possible_formulas_dict:

                    run_search(possible_formulas_dict, self.mass_spectrum_obj, min_abundance)

        if self.mass_spectrum_obj.molecular_search_settings.isRadical:

                #print(&#34;Started molecular formula search for class %s,  radical&#34; % classe_str)
                pbar.set_description_str(desc=&#34;Started molecular formula search for class %s, radical&#34; % classe_str, refresh=True)

                ion_type = Labels.radical_ion
                
                possible_formulas_dict = dict_molecular_lookup_table.get(ion_type).get(classe_str)
                
                if possible_formulas_dict:

                    run_search(possible_formulas_dict, self.mass_spectrum_obj, min_abundance)

        # looks for adduct, used_atom_valences should be 0 
        # this code does not support H exchance by halogen atoms
        if self.mass_spectrum_obj.molecular_search_settings.isAdduct:
            
            pbar.set_description_str(desc=&#34;Started molecular formula search for class %s, adduct&#34; % classe_str, refresh=True)
            #print(&#34;Started molecular formula search for class %s, adduct&#34; % classe_str)
            
            ion_type = Labels.radical_ion
            
            possible_formulas_dict = dict_molecular_lookup_table.get(ion_type).get(classe_str)

            possible_formulas_adduct =self.add_adducts(possible_formulas_dict)

            if possible_formulas_adduct:

                run_search(possible_formulas_adduct, self.mass_spectrum_obj, min_abundance)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.molecular_id.search" href="index.html">corems.molecular_id.search</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment" href="#corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment">OxygenPriorityAssignment</a></code></h4>
<ul class="">
<li><code><a title="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.add_adducts" href="#corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.add_adducts">add_adducts</a></code></li>
<li><code><a title="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.combine_ox_class_with_other" href="#corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.combine_ox_class_with_other">combine_ox_class_with_other</a></code></li>
<li><code><a title="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.create_data_base" href="#corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.create_data_base">create_data_base</a></code></li>
<li><code><a title="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.get_class_strings_dict" href="#corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.get_class_strings_dict">get_class_strings_dict</a></code></li>
<li><code><a title="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.get_classes_in_order" href="#corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.get_classes_in_order">get_classes_in_order</a></code></li>
<li><code><a title="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.get_dict_molecular_database" href="#corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.get_dict_molecular_database">get_dict_molecular_database</a></code></li>
<li><code><a title="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.ox_classes_and_peaks_in_order_" href="#corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.ox_classes_and_peaks_in_order_">ox_classes_and_peaks_in_order_</a></code></li>
<li><code><a title="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.run" href="#corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.run">run</a></code></li>
<li><code><a title="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.run_worker_mass_spectrum" href="#corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.run_worker_mass_spectrum">run_worker_mass_spectrum</a></code></li>
<li><code><a title="corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.sort_classes" href="#corems.molecular_id.search.priorityAssignment.OxygenPriorityAssignment.sort_classes">sort_classes</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>