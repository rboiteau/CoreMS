<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.molecular_id.calc.SpectralSimilarity API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.molecular_id.calc.SpectralSimilarity</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from numpy.fft import rfft
from pywt import dwt 
from scipy.spatial.distance import cosine, jaccard, euclidean, cityblock
from scipy.stats import pearsonr, spearmanr, kendalltau
from sklearn.metrics.pairwise import cosine_similarity
from numpy import power, dot, absolute, subtract, intersect1d, where, average, corrcoef, sqrt
from numpy import sum as np_sum
from numpy.linalg import norm
from pandas import DataFrame
import numpy as np

methods_name = {
    #&#34;entropy_distance&#34;: &#34;Entropy Distance&#34;,
    #&#34;weighted_entropy_distance&#34;: &#34;Dynamic weighted entropy Distance&#34;,
    &#34;chebyshev_distance&#34;: &#34;Chebyshev Distance&#34;,
    &#34;squared_euclidean_distance&#34;: &#34;Squared Euclidean Distance&#34;,
    &#34;fidelity_similarity&#34;: &#34;Fidelity Similarity&#34;,
    &#34;matusita_distance&#34;: &#34;Matusita Distance&#34;,
    &#34;squared_chord_distance&#34;: &#34;Squared-chord Distance&#34;,
    #&#34;bhattacharya_1_distance&#34;: &#34;Bhattacharya 1 Distance&#34;,
    #&#34;bhattacharya_2_distance&#34;: &#34;Bhattacharya 2 Distance&#34;,
    &#34;harmonic_mean_similarity&#34;: &#34;Harmonic mean Distance&#34;,
    &#34;Pearson_chi_squared_distance&#34;: &#34;Pearson Chi Squared Distance&#34;,
    &#34;Neyman_chi_squared_distance&#34;: &#34;Neyman Chi Squared Distance&#34;,
    &#34;probabilistic_symmetric_chi_squared_distance&#34;: &#34;Probabilistic symmetric X2 Distance&#34;,
    &#34;topsoe_distance&#34;: &#34;Topsoe Distance&#34;,
    &#34;chernoff_distance&#34;: &#34;Chernoff Distance&#34;,
    &#34;ruzicka_distance&#34;: &#34;Ruzicka Distance&#34;,
    &#34;roberts_distance&#34;: &#34;Roberts Distance&#34;,
    #&#34;intersection_distance&#34;: &#34;Intersection Distance&#34;,
    &#34;motyka_distance&#34;: &#34;Motyka Distance&#34;,
    &#34;canberra_distance&#34;: &#34;Canberra Distance&#34;,
    &#34;canberra_metric&#34;: &#34;Canberra Metric&#34;,
    &#34;kulczynski_1_distance&#34;: &#34;Kulczynski 1 Distance&#34;,
    #&#34;baroni_urbani_buser_distance&#34;: &#34;Baroni-Urbani-Buser Distance&#34;,
    #&#34;penrose_size_distance&#34;: &#34;Penrose size Distance&#34;,
    #&#34;mean_character_distance&#34;: &#34;Mean character Distance&#34;,
    &#34;lorentzian_distance&#34;: &#34;Lorentzian Distance&#34;,
    #&#34;penrose_shape_distance&#34;: &#34;Penrose shape Distance&#34;,
    &#34;clark_distance&#34;: &#34;Clark Distance&#34;,
    &#34;hellinger_distance&#34;: &#34;Hellinger Distance&#34;,
    &#34;whittaker_index_of_association_distance&#34;: &#34;Whittaker index of association Distance&#34;,
    #&#34;similarity_index_distance&#34;: &#34;Similarity Index Distance&#34;,
    #&#34;improved_similarity_distance&#34;: &#34;Improved Similarity&#34;,
    #&#34;absolute_value_distance&#34;: &#34;Absolute Value Distance&#34;,
    &#34;spectral_contrast_angle_distance&#34;: &#34;Spectral Contrast Angle&#34;,
    &#34;wave_hedges_distance&#34;: &#34;Wave Hedges Distance&#34;,
    &#34;dice_similarity&#34;: &#34;Dice Similarity&#34;,
    &#34;inner_product_distance&#34;: &#34;Inner Product Distance&#34;,
    &#34;divergence_distance&#34;: &#34;Divergence Distance&#34;,
    &#34;jensen_difference_distance&#34;: &#34;Jensen Differences Distance&#34;,
    &#34;kumar_johnson_distance&#34;: &#34;Kumar Johnson Distance&#34;,
    &#34;avg_l_distance&#34;: &#34;Avg (L1, L8) Distance&#34;,
    &#34;vicis_wave_hadges_distance&#34;: &#34;Vicis Wave Hadges Distance&#34;,
    &#34;vicis_symmetric_chi_squared_1_distance&#34;: &#34;Vicis-Symmetric X2 1 Distance&#34;,
    &#34;vicis_symmetric_chi_squared_2_distance&#34;: &#34;Vicis-Symmetric X2 2 Distance&#34;,
    &#34;vicis_symmetric_chi_squared_3_distance&#34;: &#34;Vicis-Symmetric X2 3 Distance&#34;,
    &#34;max_symmetric_chi_squared_distance&#34;: &#34;Max Symmetric Chi Squared Distance&#34;,
    &#34;min_symmetric_chi_squared_distance&#34;: &#34;Min Symmetric Chi Squared Distance&#34;,
    #&#34;ms_for_id_v1&#34;: &#34;MSforID Distance version 1&#34;,
    #&#34;ms_for_id&#34;: &#34;MSforID Distance&#34;,
    &#34;additive_sym_chi_sq&#34;: &#34;Additive Symmetric Chi Squared&#34;,
    &#34;bhattacharya_distance&#34;: &#34;Battacharya Distance&#34;,
    &#34;generalized_ochai_index&#34;: &#34;Generalized Ochai Index&#34;,
    &#34;gower_distance&#34;: &#34;Gower Distance&#34;,
    &#34;impr_sqrt_cosine_sim&#34;: &#34;Improved Square Root Cosine Similarity&#34;,
    &#34;intersection_sim&#34;: &#34;Intersection Similarity&#34;,
    &#34;j_divergence&#34;: &#34;J Divergence&#34;,
    &#34;jensen_shannon_index&#34;: &#34;Jensen Shannon Index&#34;,
    &#34;k_divergence&#34;: &#34;K Divergence&#34;,
    &#34;VW6&#34;: &#34;VW6&#34;,
    &#34;VW5&#34;: &#34;VW5&#34;,
    &#34;VW4&#34;: &#34;VW4&#34;,
    &#34;VW3&#34;: &#34;VW3&#34;,
    &#34;VW2&#34;: &#34;VW2&#34;,
    &#34;VW1&#34;: &#34;VW1&#34;,
    &#34;taneja_divergence&#34;: &#34;Taneja Divergence&#34;,
    &#34;symmetric_chi_squared_distance&#34;: &#34;Symmetric Chi Squared Distance&#34;,
    &#34;squared_chi_squared_distance&#34;: &#34;Squared Chi Squared Distance&#34;,
    &#34;square_root_cosine_correlation&#34;: &#34;Square Root Cosine Correlation&#34;,
    &#34;sorensen_distance&#34;: &#34;Sorensen Distance&#34;,
    &#34;Minokowski_3&#34;: &#34;Minokowski 3 Distance&#34;,
    &#34;Minokowski_4&#34;: &#34;Minokowski 4 Distance&#34;,
    &#34;kumarjohnson_divergence&#34;: &#34;Kumar Johnson Divergence&#34;,
    &#34;kumarhassebrook_similarity&#34;: &#34;Kumar Hassebrook Similarity&#34;,
    &#34;kullbackleibler_divergence&#34;: &#34;Kullback Leibler Divergence&#34;,
    &#34;soergel_distance&#34;: &#34;Soergel Distance&#34;,
}

methods_scale = {
    &#34;entropy&#34;: [0, np.log(4)],
    &#34;weighted_entropy&#34;: [0, np.log(4)],
    &#34;absolute_value&#34;: [0, 2],
    &#34;avg_l&#34;: [0, 1.5],
    &#34;bhattacharya_1&#34;: [0, np.arccos(0) ** 2],
    &#34;bhattacharya_2&#34;: [0, np.inf],
    &#34;canberra&#34;: [0, np.inf],
    &#34;clark&#34;: [0, np.inf],
    &#34;divergence&#34;: [0, np.inf],
    &#34;euclidean&#34;: [0, np.sqrt(2)],
    &#34;hellinger&#34;: [0, np.inf],
    &#34;improved_similarity&#34;: [0, np.inf],
    &#34;lorentzian&#34;: [0, np.inf],
    &#34;manhattan&#34;: [0, 2],
    &#34;matusita&#34;: [0, np.sqrt(2)],
    &#34;mean_character&#34;: [0, 2],
    &#34;motyka&#34;: [-0.5, 0],
    &#34;ms_for_id&#34;: [-np.inf, 0],
    &#34;ms_for_id_v1&#34;: [0, np.inf],
    &#34;pearson_correlation&#34;: [-1, 1],
    &#34;penrose_shape&#34;: [0, np.sqrt(2)],
    &#34;penrose_size&#34;: [0, np.inf],
    &#34;probabilistic_symmetric_chi_squared&#34;: [0, 1],
    &#34;similarity_index&#34;: [0, np.inf],
    &#34;squared_chord&#34;: [0, 2],
    &#34;squared_euclidean&#34;: [0, 2],
    &#34;symmetric_chi_squared&#34;: [0, 0.5 * np.sqrt(2)],
    &#34;topsoe&#34;: [0, np.sqrt(2)],
    &#34;vicis_symmetric_chi_squared_3&#34;: [0, 2],
    &#34;wave_hedges&#34;: [0, np.inf],
    &#34;whittaker_index_of_association&#34;: [0, np.inf]
}

class SpectralSimilarity():

    def __init__(self, ms_mz_abun_dict, ref_obj, norm_func=sum):

        self.normalize_func = norm_func
        self.ms_mz_abun_dict = ms_mz_abun_dict
        self.ref_obj = ref_obj

        self.exp_abun = list(self.ms_mz_abun_dict.values())
        self.exp_mz = list(self.ms_mz_abun_dict.keys())

        self.ref_mz = self.ref_obj.get(&#34;mz&#34;)
        self.ref_abun = self.ref_obj.get(&#34;abundance&#34;)

        self.ref_mz_abun_dict = dict(zip(self.ref_mz, self.ref_abun))

        # parse to dataframe, easier to zerofill and tranpose
        self.df = DataFrame([self.ms_mz_abun_dict, self.ref_mz_abun_dict])

        # fill missing mz with abundance 0
        x, y = self.nan_fill(self.df, fill_with=1e-10)
        
        self.zero_filled_u_l = self.normalize(x, y, norm_func=self.normalize_func)
        
        # filter out the mass values that have zero intensities in self.exp_abun
        exp_mz_filtered = set([k for k in self.exp_mz if self.ms_mz_abun_dict[k] != 0])

        # filter out the mass values that have zero intensities in self.ref_mz
        ref_mz_filtered = set([k for k in self.ref_mz if self.ref_mz_abun_dict[k] != 0])

        # find the intersection/common mass values of both ref and exp, and sort them
        self.common_mz_values = sorted(list(exp_mz_filtered.intersection(ref_mz_filtered)))

        # find the number of common mass values (after filtering 0s)
        self.n_x_y = len(self.common_mz_values)
        # print(self.n_x_y)

    def nan_fill(self, df, fill_with=0):

        df.fillna(fill_with, inplace=True)
        
        return df.T[0].values, df.T[1].values

    def normalize(self, x, y, norm_func=sum):

        u_l = (x / norm_func(x), y / norm_func(y) )

        return u_l

    def weighted_cosine_correlation(self, a=0.5, b=1.3, nanfill=1e-10):

        # create dict[&#39;mz&#39;] = abundance, for experimental data
        # ms_mz_abun_dict = mass_spec.mz_abun_dict
        # weight exp data

        xc = power(self.exp_abun, a) * power(self.exp_mz, b)

        # track back to individual mz
        weighted_exp_dict = dict(zip(self.ms_mz_abun_dict.keys(), xc))

        # weight ref data
        yc = power(self.ref_obj.get(&#34;abundance&#34;), a) * power(self.ref_obj.get(&#34;mz&#34;), b)

        ref_mz_abun_dict = dict(zip(self.ref_obj.get(&#34;mz&#34;), yc))

        # parse to dataframe, easier to zerofill and tranpose
        df = DataFrame([weighted_exp_dict, ref_mz_abun_dict])

        # fill missing mz with weight {abun**a}{m/z**b} to 0
        x, y = self.nan_fill(df, fill_with=nanfill)
        
        # correlation = (1 - cosine(x, y))

        correlation = dot(x, y) / (norm(x) * norm(y))

        return correlation

    def cosine_correlation(self):

        # calculate cosine correlation,
        x = self.zero_filled_u_l[0]
        y = self.zero_filled_u_l[1]

        # correlation = (1 - cosine(x, y))

        correlation = dot(x, y) / (norm(x) * norm(y))

        return correlation

    def stein_scott(self):

        if self.n_x_y == 0: return 0, 0

        # count number of non-zero abundance/peak intensity values
        n_x = sum(a != 0 for a in self.exp_abun)

        s_r_x_y = 0

        a, b = 1, 0

        for i in range(1, self.n_x_y):

            current_value = self.common_mz_values[i]
            previous_value = self.common_mz_values[i - 1]

            y_i = self.ref_mz_abun_dict[current_value]
            y_i_minus1 = self.ref_mz_abun_dict[previous_value]

            lc_current = power(y_i, a) * power(current_value, b)
            lc_previous = power(y_i_minus1, a) * power(previous_value, b)

            x_i = self.ms_mz_abun_dict[current_value]
            x_i_minus1 = self.ms_mz_abun_dict[previous_value]

            uc_current = power(x_i, a) * power(current_value, b)
            uc_previous = power(x_i_minus1, a) * power(previous_value, b)

            T1 = lc_current / lc_previous

            T2 = uc_previous / uc_current

            temp_computation = T1 * T2

            n = 0
            if temp_computation &lt;= 1:
                n = 1
            else:
                n = -1
            s_r_x_y = s_r_x_y + power(temp_computation, n)

        # finish the calculation of S_R(X,Y)

        s_r_x_y = s_r_x_y / self.n_x_y
        # using the existing weighted_cosine_correlation function to get S_WC(X,Y)
        s_wc_x_y = self.weighted_cosine_correlation(a=0.5, b=3, nanfill=0)

        s_ss_x_y = ((n_x * s_wc_x_y) + (self.n_x_y * s_r_x_y)) / (n_x + self.n_x_y)

        s_wc_x_y_nist = self.weighted_cosine_correlation(a=0.5, b=1.3, nanfill=0)

        s_ss_x_y_nist = ((n_x * s_wc_x_y_nist) + (self.n_x_y * s_r_x_y)) / (n_x + self.n_x_y)    
        # final step

        return s_ss_x_y, s_ss_x_y_nist

    def pearson_correlation(self,):

        correlation = pearsonr(self.zero_filled_u_l[0], self.zero_filled_u_l[1])

        return correlation[0]

    def spearman_correlation(self):

        # calculate Spearman correlation
        # ## TODO - Check axis
        correlation = spearmanr(self.zero_filled_u_l[0], self.zero_filled_u_l[1], axis=0)

        return correlation[0]

    def kendall_tau(self):

        # create dict[&#39;mz&#39;] = abundance, for experimental data
        # self.ms_mz_abun_dict = mass_spec.mz_abun_dict

        # create dict[&#39;mz&#39;] = abundance, for experimental data

        # calculate Kendall&#39;s tau
        correlation = kendalltau(self.zero_filled_u_l[0], self.zero_filled_u_l[1])

        return correlation[0]

    def dft_correlation(self):

        if self.n_x_y == 0:
            return 0

        # count number of non-zero abundance/peak intensity values
        n_x = sum(a != 0 for a in self.exp_abun)

        x, y = self.nan_fill(self.df, fill_with=0)
        
        x, y = self.normalize(x, y, norm_func=self.normalize_func)
        
        # get the Fourier transform of x and y
        x_dft = rfft(x).real
        y_dft = rfft(y).real

        s_dft_xy = dot(x_dft, y_dft)/(norm(x_dft)*norm(y_dft))

        # using the existing weighted_cosine_correlation function to get S_WC(X,Y)
        s_wc_x_y = self.weighted_cosine_correlation(nanfill=0)

        # final step
        s_dft = (n_x * s_wc_x_y + self.n_x_y * s_dft_xy) / (n_x + self.n_x_y)

        return s_dft

    def dwt_correlation(self):

        if self.n_x_y == 0:
            return 0

        # count number of non-zero abundance/peak intensity values
        n_x = sum(a != 0 for a in self.exp_abun)

        # calculate cosine correlation,
        x, y = self.nan_fill(self.df, fill_with=0)
        
        x, y = self.normalize(x, y, norm_func=self.normalize_func)

        # Make x and y into an array
        x_a = list(x)
        y_a = list(y)

        # get the wavelet transform of x and y (Daubechies with a filter length of 4. Asymmetric. pywavelets function)
        # Will only use the detail dwt (dwtDd
        x_dwtD = dwt(x_a, &#39;db2&#39;)[1]
        y_dwtD = dwt(y_a, &#39;db2&#39;)[1]

        s_dwt_xy = dot(x_dwtD, y_dwtD) / (norm(x_dwtD) * norm(y_dwtD))

        # using the existing weighted_cosine_correlation function to get S_WC(X,Y)
        s_wc_x_y = self.weighted_cosine_correlation(nanfill=0)

        # final step
        s_dwt = (n_x * s_wc_x_y + self.n_x_y * s_dwt_xy) / (n_x + self.n_x_y)

        return s_dwt

    def euclidean_distance(self):

        # correlation = euclidean_distance_manual(self.zero_filled_u_l[0], self.zero_filled_u_l[1])
        qlist = self.zero_filled_u_l[0]
        rlist = self.zero_filled_u_l[1]

        correlation = sqrt(np_sum(power(qlist - rlist, 2)))

        return correlation

    def manhattan_distance(self):

        qlist = self.zero_filled_u_l[0]
        rlist = self.zero_filled_u_l[1]

        return np_sum(absolute(qlist - rlist))

    def jaccard_distance(self):

        def jaccard_similarity(list1, list2):

            intersection = len(list(set(list1).intersection(list2)))
            union = (len(list1) + len(list2)) - intersection
            return float(intersection) / union

        qlist = self.zero_filled_u_l[0]
        rlist = self.zero_filled_u_l[1]

        return np_sum(power(qlist - rlist, 2)) / (np_sum(power(qlist, 2)) + np_sum(power(rlist, 2)) - np_sum(qlist * rlist))
        # correlation = jaccard_similarity(self.zero_filled_u_l[0], self.zero_filled_u_l[1])
        # @return correlation

    def extra_distances(self):
        from corems.molecular_id.calc import math_distance

        #qlist = self.zero_filled_u_l[2]
        #rlist = self.zero_filled_u_l[3]

        dict_res = {}

        for method in methods_name:
            #function_name = method + &#34;_distance&#34;
            function_name = method
            if hasattr(math_distance, function_name):
                f = getattr(math_distance, function_name)

                if function_name == &#34;canberra_metric&#34;:
                    
                    x, y = self.nan_fill(self.df, fill_with=0)
        
                    qlist, rlist = self.normalize(x, y, norm_func=self.normalize_func)
                    #print(&#34;qlist:&#34;)
                    #print(qlist)
                    #print(&#34;rlist:&#34;)
                    #print(rlist)

                
                else:
                    qlist = self.zero_filled_u_l[0]
                    rlist = self.zero_filled_u_l[1]

                dist = f(qlist, rlist)
                #if method == &#34;Minokowski_3&#34;:
                #    print(&#34;qlist:&#34;)
                #    print(qlist)
                #    print(&#34;rlist&#34;)
                #    print(rlist)
                #    exit()
                # if dist == np.nan or dis == np.inf:
                    # print(self.exp_abun)
                    # print(self.exp_mz)
                    #print(function_name)
                    # print(len(self.exp_abun))
                    # print(len(self.exp_mz))
                    # print(self.zero_filled_u_l[1])
                dict_res[method] = dist

        return dict_res</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity"><code class="flex name class">
<span>class <span class="ident">SpectralSimilarity</span></span>
<span>(</span><span>ms_mz_abun_dict, ref_obj, norm_func=&lt;built-in function sum&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpectralSimilarity():

    def __init__(self, ms_mz_abun_dict, ref_obj, norm_func=sum):

        self.normalize_func = norm_func
        self.ms_mz_abun_dict = ms_mz_abun_dict
        self.ref_obj = ref_obj

        self.exp_abun = list(self.ms_mz_abun_dict.values())
        self.exp_mz = list(self.ms_mz_abun_dict.keys())

        self.ref_mz = self.ref_obj.get(&#34;mz&#34;)
        self.ref_abun = self.ref_obj.get(&#34;abundance&#34;)

        self.ref_mz_abun_dict = dict(zip(self.ref_mz, self.ref_abun))

        # parse to dataframe, easier to zerofill and tranpose
        self.df = DataFrame([self.ms_mz_abun_dict, self.ref_mz_abun_dict])

        # fill missing mz with abundance 0
        x, y = self.nan_fill(self.df, fill_with=1e-10)
        
        self.zero_filled_u_l = self.normalize(x, y, norm_func=self.normalize_func)
        
        # filter out the mass values that have zero intensities in self.exp_abun
        exp_mz_filtered = set([k for k in self.exp_mz if self.ms_mz_abun_dict[k] != 0])

        # filter out the mass values that have zero intensities in self.ref_mz
        ref_mz_filtered = set([k for k in self.ref_mz if self.ref_mz_abun_dict[k] != 0])

        # find the intersection/common mass values of both ref and exp, and sort them
        self.common_mz_values = sorted(list(exp_mz_filtered.intersection(ref_mz_filtered)))

        # find the number of common mass values (after filtering 0s)
        self.n_x_y = len(self.common_mz_values)
        # print(self.n_x_y)

    def nan_fill(self, df, fill_with=0):

        df.fillna(fill_with, inplace=True)
        
        return df.T[0].values, df.T[1].values

    def normalize(self, x, y, norm_func=sum):

        u_l = (x / norm_func(x), y / norm_func(y) )

        return u_l

    def weighted_cosine_correlation(self, a=0.5, b=1.3, nanfill=1e-10):

        # create dict[&#39;mz&#39;] = abundance, for experimental data
        # ms_mz_abun_dict = mass_spec.mz_abun_dict
        # weight exp data

        xc = power(self.exp_abun, a) * power(self.exp_mz, b)

        # track back to individual mz
        weighted_exp_dict = dict(zip(self.ms_mz_abun_dict.keys(), xc))

        # weight ref data
        yc = power(self.ref_obj.get(&#34;abundance&#34;), a) * power(self.ref_obj.get(&#34;mz&#34;), b)

        ref_mz_abun_dict = dict(zip(self.ref_obj.get(&#34;mz&#34;), yc))

        # parse to dataframe, easier to zerofill and tranpose
        df = DataFrame([weighted_exp_dict, ref_mz_abun_dict])

        # fill missing mz with weight {abun**a}{m/z**b} to 0
        x, y = self.nan_fill(df, fill_with=nanfill)
        
        # correlation = (1 - cosine(x, y))

        correlation = dot(x, y) / (norm(x) * norm(y))

        return correlation

    def cosine_correlation(self):

        # calculate cosine correlation,
        x = self.zero_filled_u_l[0]
        y = self.zero_filled_u_l[1]

        # correlation = (1 - cosine(x, y))

        correlation = dot(x, y) / (norm(x) * norm(y))

        return correlation

    def stein_scott(self):

        if self.n_x_y == 0: return 0, 0

        # count number of non-zero abundance/peak intensity values
        n_x = sum(a != 0 for a in self.exp_abun)

        s_r_x_y = 0

        a, b = 1, 0

        for i in range(1, self.n_x_y):

            current_value = self.common_mz_values[i]
            previous_value = self.common_mz_values[i - 1]

            y_i = self.ref_mz_abun_dict[current_value]
            y_i_minus1 = self.ref_mz_abun_dict[previous_value]

            lc_current = power(y_i, a) * power(current_value, b)
            lc_previous = power(y_i_minus1, a) * power(previous_value, b)

            x_i = self.ms_mz_abun_dict[current_value]
            x_i_minus1 = self.ms_mz_abun_dict[previous_value]

            uc_current = power(x_i, a) * power(current_value, b)
            uc_previous = power(x_i_minus1, a) * power(previous_value, b)

            T1 = lc_current / lc_previous

            T2 = uc_previous / uc_current

            temp_computation = T1 * T2

            n = 0
            if temp_computation &lt;= 1:
                n = 1
            else:
                n = -1
            s_r_x_y = s_r_x_y + power(temp_computation, n)

        # finish the calculation of S_R(X,Y)

        s_r_x_y = s_r_x_y / self.n_x_y
        # using the existing weighted_cosine_correlation function to get S_WC(X,Y)
        s_wc_x_y = self.weighted_cosine_correlation(a=0.5, b=3, nanfill=0)

        s_ss_x_y = ((n_x * s_wc_x_y) + (self.n_x_y * s_r_x_y)) / (n_x + self.n_x_y)

        s_wc_x_y_nist = self.weighted_cosine_correlation(a=0.5, b=1.3, nanfill=0)

        s_ss_x_y_nist = ((n_x * s_wc_x_y_nist) + (self.n_x_y * s_r_x_y)) / (n_x + self.n_x_y)    
        # final step

        return s_ss_x_y, s_ss_x_y_nist

    def pearson_correlation(self,):

        correlation = pearsonr(self.zero_filled_u_l[0], self.zero_filled_u_l[1])

        return correlation[0]

    def spearman_correlation(self):

        # calculate Spearman correlation
        # ## TODO - Check axis
        correlation = spearmanr(self.zero_filled_u_l[0], self.zero_filled_u_l[1], axis=0)

        return correlation[0]

    def kendall_tau(self):

        # create dict[&#39;mz&#39;] = abundance, for experimental data
        # self.ms_mz_abun_dict = mass_spec.mz_abun_dict

        # create dict[&#39;mz&#39;] = abundance, for experimental data

        # calculate Kendall&#39;s tau
        correlation = kendalltau(self.zero_filled_u_l[0], self.zero_filled_u_l[1])

        return correlation[0]

    def dft_correlation(self):

        if self.n_x_y == 0:
            return 0

        # count number of non-zero abundance/peak intensity values
        n_x = sum(a != 0 for a in self.exp_abun)

        x, y = self.nan_fill(self.df, fill_with=0)
        
        x, y = self.normalize(x, y, norm_func=self.normalize_func)
        
        # get the Fourier transform of x and y
        x_dft = rfft(x).real
        y_dft = rfft(y).real

        s_dft_xy = dot(x_dft, y_dft)/(norm(x_dft)*norm(y_dft))

        # using the existing weighted_cosine_correlation function to get S_WC(X,Y)
        s_wc_x_y = self.weighted_cosine_correlation(nanfill=0)

        # final step
        s_dft = (n_x * s_wc_x_y + self.n_x_y * s_dft_xy) / (n_x + self.n_x_y)

        return s_dft

    def dwt_correlation(self):

        if self.n_x_y == 0:
            return 0

        # count number of non-zero abundance/peak intensity values
        n_x = sum(a != 0 for a in self.exp_abun)

        # calculate cosine correlation,
        x, y = self.nan_fill(self.df, fill_with=0)
        
        x, y = self.normalize(x, y, norm_func=self.normalize_func)

        # Make x and y into an array
        x_a = list(x)
        y_a = list(y)

        # get the wavelet transform of x and y (Daubechies with a filter length of 4. Asymmetric. pywavelets function)
        # Will only use the detail dwt (dwtDd
        x_dwtD = dwt(x_a, &#39;db2&#39;)[1]
        y_dwtD = dwt(y_a, &#39;db2&#39;)[1]

        s_dwt_xy = dot(x_dwtD, y_dwtD) / (norm(x_dwtD) * norm(y_dwtD))

        # using the existing weighted_cosine_correlation function to get S_WC(X,Y)
        s_wc_x_y = self.weighted_cosine_correlation(nanfill=0)

        # final step
        s_dwt = (n_x * s_wc_x_y + self.n_x_y * s_dwt_xy) / (n_x + self.n_x_y)

        return s_dwt

    def euclidean_distance(self):

        # correlation = euclidean_distance_manual(self.zero_filled_u_l[0], self.zero_filled_u_l[1])
        qlist = self.zero_filled_u_l[0]
        rlist = self.zero_filled_u_l[1]

        correlation = sqrt(np_sum(power(qlist - rlist, 2)))

        return correlation

    def manhattan_distance(self):

        qlist = self.zero_filled_u_l[0]
        rlist = self.zero_filled_u_l[1]

        return np_sum(absolute(qlist - rlist))

    def jaccard_distance(self):

        def jaccard_similarity(list1, list2):

            intersection = len(list(set(list1).intersection(list2)))
            union = (len(list1) + len(list2)) - intersection
            return float(intersection) / union

        qlist = self.zero_filled_u_l[0]
        rlist = self.zero_filled_u_l[1]

        return np_sum(power(qlist - rlist, 2)) / (np_sum(power(qlist, 2)) + np_sum(power(rlist, 2)) - np_sum(qlist * rlist))
        # correlation = jaccard_similarity(self.zero_filled_u_l[0], self.zero_filled_u_l[1])
        # @return correlation

    def extra_distances(self):
        from corems.molecular_id.calc import math_distance

        #qlist = self.zero_filled_u_l[2]
        #rlist = self.zero_filled_u_l[3]

        dict_res = {}

        for method in methods_name:
            #function_name = method + &#34;_distance&#34;
            function_name = method
            if hasattr(math_distance, function_name):
                f = getattr(math_distance, function_name)

                if function_name == &#34;canberra_metric&#34;:
                    
                    x, y = self.nan_fill(self.df, fill_with=0)
        
                    qlist, rlist = self.normalize(x, y, norm_func=self.normalize_func)
                    #print(&#34;qlist:&#34;)
                    #print(qlist)
                    #print(&#34;rlist:&#34;)
                    #print(rlist)

                
                else:
                    qlist = self.zero_filled_u_l[0]
                    rlist = self.zero_filled_u_l[1]

                dist = f(qlist, rlist)
                #if method == &#34;Minokowski_3&#34;:
                #    print(&#34;qlist:&#34;)
                #    print(qlist)
                #    print(&#34;rlist&#34;)
                #    print(rlist)
                #    exit()
                # if dist == np.nan or dis == np.inf:
                    # print(self.exp_abun)
                    # print(self.exp_mz)
                    #print(function_name)
                    # print(len(self.exp_abun))
                    # print(len(self.exp_mz))
                    # print(self.zero_filled_u_l[1])
                dict_res[method] = dist

        return dict_res</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.cosine_correlation"><code class="name flex">
<span>def <span class="ident">cosine_correlation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cosine_correlation(self):

    # calculate cosine correlation,
    x = self.zero_filled_u_l[0]
    y = self.zero_filled_u_l[1]

    # correlation = (1 - cosine(x, y))

    correlation = dot(x, y) / (norm(x) * norm(y))

    return correlation</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.dft_correlation"><code class="name flex">
<span>def <span class="ident">dft_correlation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dft_correlation(self):

    if self.n_x_y == 0:
        return 0

    # count number of non-zero abundance/peak intensity values
    n_x = sum(a != 0 for a in self.exp_abun)

    x, y = self.nan_fill(self.df, fill_with=0)
    
    x, y = self.normalize(x, y, norm_func=self.normalize_func)
    
    # get the Fourier transform of x and y
    x_dft = rfft(x).real
    y_dft = rfft(y).real

    s_dft_xy = dot(x_dft, y_dft)/(norm(x_dft)*norm(y_dft))

    # using the existing weighted_cosine_correlation function to get S_WC(X,Y)
    s_wc_x_y = self.weighted_cosine_correlation(nanfill=0)

    # final step
    s_dft = (n_x * s_wc_x_y + self.n_x_y * s_dft_xy) / (n_x + self.n_x_y)

    return s_dft</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.dwt_correlation"><code class="name flex">
<span>def <span class="ident">dwt_correlation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dwt_correlation(self):

    if self.n_x_y == 0:
        return 0

    # count number of non-zero abundance/peak intensity values
    n_x = sum(a != 0 for a in self.exp_abun)

    # calculate cosine correlation,
    x, y = self.nan_fill(self.df, fill_with=0)
    
    x, y = self.normalize(x, y, norm_func=self.normalize_func)

    # Make x and y into an array
    x_a = list(x)
    y_a = list(y)

    # get the wavelet transform of x and y (Daubechies with a filter length of 4. Asymmetric. pywavelets function)
    # Will only use the detail dwt (dwtDd
    x_dwtD = dwt(x_a, &#39;db2&#39;)[1]
    y_dwtD = dwt(y_a, &#39;db2&#39;)[1]

    s_dwt_xy = dot(x_dwtD, y_dwtD) / (norm(x_dwtD) * norm(y_dwtD))

    # using the existing weighted_cosine_correlation function to get S_WC(X,Y)
    s_wc_x_y = self.weighted_cosine_correlation(nanfill=0)

    # final step
    s_dwt = (n_x * s_wc_x_y + self.n_x_y * s_dwt_xy) / (n_x + self.n_x_y)

    return s_dwt</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.euclidean_distance"><code class="name flex">
<span>def <span class="ident">euclidean_distance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def euclidean_distance(self):

    # correlation = euclidean_distance_manual(self.zero_filled_u_l[0], self.zero_filled_u_l[1])
    qlist = self.zero_filled_u_l[0]
    rlist = self.zero_filled_u_l[1]

    correlation = sqrt(np_sum(power(qlist - rlist, 2)))

    return correlation</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.extra_distances"><code class="name flex">
<span>def <span class="ident">extra_distances</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extra_distances(self):
    from corems.molecular_id.calc import math_distance

    #qlist = self.zero_filled_u_l[2]
    #rlist = self.zero_filled_u_l[3]

    dict_res = {}

    for method in methods_name:
        #function_name = method + &#34;_distance&#34;
        function_name = method
        if hasattr(math_distance, function_name):
            f = getattr(math_distance, function_name)

            if function_name == &#34;canberra_metric&#34;:
                
                x, y = self.nan_fill(self.df, fill_with=0)
    
                qlist, rlist = self.normalize(x, y, norm_func=self.normalize_func)
                #print(&#34;qlist:&#34;)
                #print(qlist)
                #print(&#34;rlist:&#34;)
                #print(rlist)

            
            else:
                qlist = self.zero_filled_u_l[0]
                rlist = self.zero_filled_u_l[1]

            dist = f(qlist, rlist)
            #if method == &#34;Minokowski_3&#34;:
            #    print(&#34;qlist:&#34;)
            #    print(qlist)
            #    print(&#34;rlist&#34;)
            #    print(rlist)
            #    exit()
            # if dist == np.nan or dis == np.inf:
                # print(self.exp_abun)
                # print(self.exp_mz)
                #print(function_name)
                # print(len(self.exp_abun))
                # print(len(self.exp_mz))
                # print(self.zero_filled_u_l[1])
            dict_res[method] = dist

    return dict_res</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.jaccard_distance"><code class="name flex">
<span>def <span class="ident">jaccard_distance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jaccard_distance(self):

    def jaccard_similarity(list1, list2):

        intersection = len(list(set(list1).intersection(list2)))
        union = (len(list1) + len(list2)) - intersection
        return float(intersection) / union

    qlist = self.zero_filled_u_l[0]
    rlist = self.zero_filled_u_l[1]

    return np_sum(power(qlist - rlist, 2)) / (np_sum(power(qlist, 2)) + np_sum(power(rlist, 2)) - np_sum(qlist * rlist))</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.kendall_tau"><code class="name flex">
<span>def <span class="ident">kendall_tau</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kendall_tau(self):

    # create dict[&#39;mz&#39;] = abundance, for experimental data
    # self.ms_mz_abun_dict = mass_spec.mz_abun_dict

    # create dict[&#39;mz&#39;] = abundance, for experimental data

    # calculate Kendall&#39;s tau
    correlation = kendalltau(self.zero_filled_u_l[0], self.zero_filled_u_l[1])

    return correlation[0]</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.manhattan_distance"><code class="name flex">
<span>def <span class="ident">manhattan_distance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def manhattan_distance(self):

    qlist = self.zero_filled_u_l[0]
    rlist = self.zero_filled_u_l[1]

    return np_sum(absolute(qlist - rlist))</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.nan_fill"><code class="name flex">
<span>def <span class="ident">nan_fill</span></span>(<span>self, df, fill_with=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nan_fill(self, df, fill_with=0):

    df.fillna(fill_with, inplace=True)
    
    return df.T[0].values, df.T[1].values</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self, x, y, norm_func=&lt;built-in function sum&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(self, x, y, norm_func=sum):

    u_l = (x / norm_func(x), y / norm_func(y) )

    return u_l</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.pearson_correlation"><code class="name flex">
<span>def <span class="ident">pearson_correlation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pearson_correlation(self,):

    correlation = pearsonr(self.zero_filled_u_l[0], self.zero_filled_u_l[1])

    return correlation[0]</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.spearman_correlation"><code class="name flex">
<span>def <span class="ident">spearman_correlation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spearman_correlation(self):

    # calculate Spearman correlation
    # ## TODO - Check axis
    correlation = spearmanr(self.zero_filled_u_l[0], self.zero_filled_u_l[1], axis=0)

    return correlation[0]</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.stein_scott"><code class="name flex">
<span>def <span class="ident">stein_scott</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stein_scott(self):

    if self.n_x_y == 0: return 0, 0

    # count number of non-zero abundance/peak intensity values
    n_x = sum(a != 0 for a in self.exp_abun)

    s_r_x_y = 0

    a, b = 1, 0

    for i in range(1, self.n_x_y):

        current_value = self.common_mz_values[i]
        previous_value = self.common_mz_values[i - 1]

        y_i = self.ref_mz_abun_dict[current_value]
        y_i_minus1 = self.ref_mz_abun_dict[previous_value]

        lc_current = power(y_i, a) * power(current_value, b)
        lc_previous = power(y_i_minus1, a) * power(previous_value, b)

        x_i = self.ms_mz_abun_dict[current_value]
        x_i_minus1 = self.ms_mz_abun_dict[previous_value]

        uc_current = power(x_i, a) * power(current_value, b)
        uc_previous = power(x_i_minus1, a) * power(previous_value, b)

        T1 = lc_current / lc_previous

        T2 = uc_previous / uc_current

        temp_computation = T1 * T2

        n = 0
        if temp_computation &lt;= 1:
            n = 1
        else:
            n = -1
        s_r_x_y = s_r_x_y + power(temp_computation, n)

    # finish the calculation of S_R(X,Y)

    s_r_x_y = s_r_x_y / self.n_x_y
    # using the existing weighted_cosine_correlation function to get S_WC(X,Y)
    s_wc_x_y = self.weighted_cosine_correlation(a=0.5, b=3, nanfill=0)

    s_ss_x_y = ((n_x * s_wc_x_y) + (self.n_x_y * s_r_x_y)) / (n_x + self.n_x_y)

    s_wc_x_y_nist = self.weighted_cosine_correlation(a=0.5, b=1.3, nanfill=0)

    s_ss_x_y_nist = ((n_x * s_wc_x_y_nist) + (self.n_x_y * s_r_x_y)) / (n_x + self.n_x_y)    
    # final step

    return s_ss_x_y, s_ss_x_y_nist</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.weighted_cosine_correlation"><code class="name flex">
<span>def <span class="ident">weighted_cosine_correlation</span></span>(<span>self, a=0.5, b=1.3, nanfill=1e-10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weighted_cosine_correlation(self, a=0.5, b=1.3, nanfill=1e-10):

    # create dict[&#39;mz&#39;] = abundance, for experimental data
    # ms_mz_abun_dict = mass_spec.mz_abun_dict
    # weight exp data

    xc = power(self.exp_abun, a) * power(self.exp_mz, b)

    # track back to individual mz
    weighted_exp_dict = dict(zip(self.ms_mz_abun_dict.keys(), xc))

    # weight ref data
    yc = power(self.ref_obj.get(&#34;abundance&#34;), a) * power(self.ref_obj.get(&#34;mz&#34;), b)

    ref_mz_abun_dict = dict(zip(self.ref_obj.get(&#34;mz&#34;), yc))

    # parse to dataframe, easier to zerofill and tranpose
    df = DataFrame([weighted_exp_dict, ref_mz_abun_dict])

    # fill missing mz with weight {abun**a}{m/z**b} to 0
    x, y = self.nan_fill(df, fill_with=nanfill)
    
    # correlation = (1 - cosine(x, y))

    correlation = dot(x, y) / (norm(x) * norm(y))

    return correlation</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.molecular_id.calc" href="index.html">corems.molecular_id.calc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity" href="#corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity">SpectralSimilarity</a></code></h4>
<ul class="">
<li><code><a title="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.cosine_correlation" href="#corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.cosine_correlation">cosine_correlation</a></code></li>
<li><code><a title="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.dft_correlation" href="#corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.dft_correlation">dft_correlation</a></code></li>
<li><code><a title="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.dwt_correlation" href="#corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.dwt_correlation">dwt_correlation</a></code></li>
<li><code><a title="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.euclidean_distance" href="#corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.euclidean_distance">euclidean_distance</a></code></li>
<li><code><a title="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.extra_distances" href="#corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.extra_distances">extra_distances</a></code></li>
<li><code><a title="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.jaccard_distance" href="#corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.jaccard_distance">jaccard_distance</a></code></li>
<li><code><a title="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.kendall_tau" href="#corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.kendall_tau">kendall_tau</a></code></li>
<li><code><a title="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.manhattan_distance" href="#corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.manhattan_distance">manhattan_distance</a></code></li>
<li><code><a title="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.nan_fill" href="#corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.nan_fill">nan_fill</a></code></li>
<li><code><a title="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.normalize" href="#corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.normalize">normalize</a></code></li>
<li><code><a title="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.pearson_correlation" href="#corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.pearson_correlation">pearson_correlation</a></code></li>
<li><code><a title="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.spearman_correlation" href="#corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.spearman_correlation">spearman_correlation</a></code></li>
<li><code><a title="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.stein_scott" href="#corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.stein_scott">stein_scott</a></code></li>
<li><code><a title="corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.weighted_cosine_correlation" href="#corems.molecular_id.calc.SpectralSimilarity.SpectralSimilarity.weighted_cosine_correlation">weighted_cosine_correlation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>