<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.transient.input.brukerSolarix API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.transient.input.brukerSolarix</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__author__ = &#34;Yuri E. Corilo&#34;
__date__ = &#34;Jun 12, 2019&#34;
from copy import deepcopy
from pathlib import Path

from numpy import genfromtxt, fromstring, dtype, fromfile, frombuffer
from s3path import S3Path
from xml.dom import minidom


from corems.transient.factory.TransientClasses import Transient
from corems.encapsulation.factory.parameters import default_parameters



class ReadBrukerSolarix(object):
    
    &#34;&#34;&#34;
    A class used to Read a single Transient from Bruker&#39;s FT-MS acquisition station (fid, or ser)
        
    Parameters
    ----------
    d_directory_location : str
        the full path of the .d folder
    
    Methods
    -------
    get_transient()
        Read the data and settings returning a Transient class  
    &#34;&#34;&#34;
    
    def __enter__(self ):
            
            return self.get_transient()
    
    def __exit__(self, exc_type, exc_val, exc_tb):
            
        return False

    def __init__(self, d_directory_location):
        
        if isinstance(d_directory_location, str):
            d_directory_location = Path(d_directory_location)
        
        if not d_directory_location.exists():
            raise FileNotFoundError(&#34;File does not exist: &#34; + str(d_directory_location))

        self.d_directory_location = d_directory_location
        
        self.file_location = d_directory_location
        
        try:

            self.parameter_filename_location = self.locate_file(
                d_directory_location, &#34;apexAcquisition.method&#34;
            )
            self.transient_data_path = d_directory_location / &#34;fid&#34;
            
            if not self.transient_data_path.exists():

                self.transient_data_path = d_directory_location / &#34;ser&#34;

                if not self.transient_data_path.exists():
                    
                    raise FileNotFoundError(&#34;Could not locate transient data&#34;)

                else:
                    # get scan attributes
                    self.scan_attr = d_directory_location / &#34;scan.xml&#34;

        except:
            
            raise FileExistsError(
                &#34;%s does not seem to be a valid Solarix Mass Spectrum&#34;
                % (d_directory_location)
            )

    def get_scan_attr(self):
    
        from bs4 import BeautifulSoup
        
        soup = BeautifulSoup(self.scan_attr.open(),&#39;xml&#39;)

        list_rt = [float(rt.text) for rt in soup.find_all(&#39;minutes&#39;)]
        list_tic = [float(tic.text) for tic in soup.find_all(&#39;tic&#39;)]
        list_scan = [int(scan.text) for scan in soup.find_all(&#39;count&#39;)]

        dict_scan_rt_tic = dict(zip(list_scan, zip(list_rt, list_tic)))
        
        return dict_scan_rt_tic
       
        
    def get_transient(self, scan_number=1):

        file_d_params = self.parse_parameters(self.parameter_filename_location)

        self.fix_freq_limits(file_d_params)

        from sys import platform
        
        if platform == &#34;win32&#34;:
            # Windows...
            dt = dtype(&#34;l&#34;)
        else:
            dt = dtype(&#34;i&#34;)

        # get rt, scan, and tic from scan.xml file, otherwise  using 0 defaults values 
        
        output_parameters = deepcopy(default_parameters(self.d_directory_location))

        if self.transient_data_path.name == &#39;ser&#39;:
            
            if self.scan_attr.exists():
                
                dict_scan_rt_tic = self.get_scan_attr()

                output_parameters[&#34;scan_number&#34;] = scan_number

                output_parameters[&#34;rt&#34;] = dict_scan_rt_tic.get(scan_number)[0]

                output_parameters[&#34;tic&#34;] = dict_scan_rt_tic.get(scan_number)[1]
        
        output_parameters[&#34;analyzer&#34;] = &#34;ICR&#34;

        output_parameters[&#34;label&#34;] = &#34;Bruker_Frequency&#34;

        output_parameters[&#34;Aterm&#34;] = float(file_d_params.get(&#34;ML1&#34;))

        output_parameters[&#34;Bterm&#34;] = float(file_d_params.get(&#34;ML2&#34;))

        output_parameters[&#34;Cterm&#34;] = float(file_d_params.get(&#34;ML3&#34;))

        output_parameters[&#34;exc_high_freq&#34;] = float(file_d_params.get(&#34;EXC_Freq_High&#34;))

        output_parameters[&#34;exc_low_freq&#34;] = float(file_d_params.get(&#34;EXC_Freq_Low&#34;))

        output_parameters[&#34;bandwidth&#34;] = float(file_d_params.get(&#34;SW_h&#34;))

        output_parameters[&#34;number_data_points&#34;] = int(file_d_params.get(&#34;TD&#34;))

        output_parameters[&#34;polarity&#34;] = str(file_d_params.get(&#34;Polarity&#34;))

        data_points = int(file_d_params.get(&#34;TD&#34;))

        scan = output_parameters[&#34;scan_number&#34;]
        from io import BytesIO
        if self.transient_data_path.name == &#39;ser&#39;:
            
            if isinstance(self.transient_data_path, S3Path):
                databin = BytesIO(self.transient_data_path.open(&#39;rb&#39;).read())
            
            else:
                databin = self.transient_data_path.open(&#39;rb&#39;)
               
            databin.seek((scan-1)*4*data_points)
            #read scan data and parse to 32int struct
            data = frombuffer(databin.read(4*data_points), dtype=dt)
        
        else:
            
            if isinstance(self.transient_data_path, S3Path):
                data = frombuffer(self.transient_data_path.open(&#39;rb&#39;).read(), dtype=dt)
            else:
                data = fromfile(self.transient_data_path, dtype=dt)
        
        return Transient(data, output_parameters)

    &#34;&#34;&#34;
        for key, values in default_parameters.items():
            print(key, values)
    &#34;&#34;&#34;
    def fix_freq_limits(self, d_parameters):

        highfreq = float(d_parameters.get(&#34;EXC_Freq_High&#34;))

        lowfreq = float(d_parameters.get(&#34;EXC_Freq_Low&#34;))

        # CR for compatibility with Apex format as there is no EXciteSweep file
        if not highfreq and lowfreq:

            excitation_sweep_filelocation = self.locate_file(
                self.d_directory_location, &#34;ExciteSweep&#34;
            )
            lowfreq, highfreq = self.get_excite_sweep_range(
                excitation_sweep_filelocation
            )
            d_parameters[&#34;EXC_Freq_High&#34;] = highfreq
            d_parameters[&#34;EXC_Freq_Low&#34;] = lowfreq

    @staticmethod
    def get_excite_sweep_range(filename):
        &#34;&#34;&#34;
        Function that returns the lower and higher frequency of the pulse generator
        &#34;&#34;&#34;
        ExciteSweep_lines = genfromtxt(filename, comments=&#34;*&#34;, delimiter=&#34;\n&#34;)
        # CR ready if we need the full array
        highfreq = fromstring(ExciteSweep_lines[0])
        lowfreq = fromstring(ExciteSweep_lines[-1])

        return lowfreq[0], highfreq[0]

    @staticmethod
    def locate_file(folder, type_file_name):
        
        from pathlib import Path
        &#34;&#34;&#34;
            type_of_file = ExciteSweep or apexAcquisition.method
            From the given folder this function return the absolute path to the ExciteSweep file, or the apexAcquisition.method file
            It should always be in a subfolder 
        
            &#39;&#39;&#39; this code is a adaptation/automation of spike library
                https://bitbucket.org/delsuc/spike/
                from Marc Delsuc
            &#39;&#39;&#39;
        &#34;&#34;&#34;
        
        directory_location = folder.glob( &#39;**/*apexAcquisition.method&#39;)
        result = list(directory_location)
        if len(result) &gt; 1:

            raise Exception(
                &#34;You have more than 1 %s file in the %s folder, using the first one&#34;
                % (type_file_name, folder)
            )

        elif len(result) == 0:

            raise Exception(
                &#34;You don&#39;t have any %s file in the  %s folder, please double check the path&#34;
                % (type_file_name, folder)
            )

        return result[0]

    @staticmethod
    def parse_parameters(parameters_filename):
        &#34;&#34;&#34; 
            TODO: change to beautiful soup xml parsing
            Open the given file and retrieve all parameters from apexAcquisition.method
            None is written when no value for value is found

            structure : &lt;param name = &#34;AMS_ActiveExclusion&#34;&gt;&lt;value&gt;0&lt;/value&gt;&lt;/param&gt;

            read_param returns  values in a dictionnary
            xml should be extinct, just a random option

            &#39;&#39;&#39; this code is a adaptation/automation of spike library
                https://bitbucket.org/delsuc/spike/
                from Marc Delsuc
            &#39;&#39;&#39;
        &#34;&#34;&#34;
        xmldoc = minidom.parse(parameters_filename.open())

        x = xmldoc.documentElement
        parameter_dict = {}
        children = x.childNodes
        for child in children:
            # print( child.node)
            if child.nodeName == &#34;reportinfo&#34;:
                sections = child.childNodes
                for section in sections:
                    if section.nodeName == &#34;section&#34;:
                        if section.getAttribute(&#34;title&#34;) == &#34;Main&#34;:
                            for element in section.childNodes:
                                if element.nodeName == &#34;section&#34;:
                                    if element.getAttribute(&#34;title&#34;) == &#34;Polarity&#34;:
                                        if (
                                            str(
                                                element.childNodes[1].getAttribute(
                                                    &#34;value&#34;
                                                )
                                            )
                                            == &#34;Negative&#34;
                                        ):
                                            parameter_dict[&#34;Polarity&#34;] = -1
                                        else:
                                            parameter_dict[&#34;Polarity&#34;] = 1

            if child.nodeName == &#34;paramlist&#34;:
                params = child.childNodes
                for param in params:
                    # print( param.nodeName)
                    if param.nodeName == &#34;param&#34;:
                        paramenter_label = str(param.getAttribute(&#34;name&#34;))
                        for element in param.childNodes:
                            if element.nodeName == &#34;value&#34;:
                                try:
                                    parameter_value = str(element.firstChild.toxml())
                                    # print v
                                except:
                                    parameter_value = None

                            parameter_dict[paramenter_label] = parameter_value

        return parameter_dict</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="corems.transient.input.brukerSolarix.ReadBrukerSolarix"><code class="flex name class">
<span>class <span class="ident">ReadBrukerSolarix</span></span>
<span>(</span><span>d_directory_location)</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to Read a single Transient from Bruker's FT-MS acquisition station (fid, or ser)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>d_directory_location</code></strong> :&ensp;<code>str</code></dt>
<dd>the full path of the .d folder</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>get_transient()
Read the data and settings returning a Transient class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadBrukerSolarix(object):
    
    &#34;&#34;&#34;
    A class used to Read a single Transient from Bruker&#39;s FT-MS acquisition station (fid, or ser)
        
    Parameters
    ----------
    d_directory_location : str
        the full path of the .d folder
    
    Methods
    -------
    get_transient()
        Read the data and settings returning a Transient class  
    &#34;&#34;&#34;
    
    def __enter__(self ):
            
            return self.get_transient()
    
    def __exit__(self, exc_type, exc_val, exc_tb):
            
        return False

    def __init__(self, d_directory_location):
        
        if isinstance(d_directory_location, str):
            d_directory_location = Path(d_directory_location)
        
        if not d_directory_location.exists():
            raise FileNotFoundError(&#34;File does not exist: &#34; + str(d_directory_location))

        self.d_directory_location = d_directory_location
        
        self.file_location = d_directory_location
        
        try:

            self.parameter_filename_location = self.locate_file(
                d_directory_location, &#34;apexAcquisition.method&#34;
            )
            self.transient_data_path = d_directory_location / &#34;fid&#34;
            
            if not self.transient_data_path.exists():

                self.transient_data_path = d_directory_location / &#34;ser&#34;

                if not self.transient_data_path.exists():
                    
                    raise FileNotFoundError(&#34;Could not locate transient data&#34;)

                else:
                    # get scan attributes
                    self.scan_attr = d_directory_location / &#34;scan.xml&#34;

        except:
            
            raise FileExistsError(
                &#34;%s does not seem to be a valid Solarix Mass Spectrum&#34;
                % (d_directory_location)
            )

    def get_scan_attr(self):
    
        from bs4 import BeautifulSoup
        
        soup = BeautifulSoup(self.scan_attr.open(),&#39;xml&#39;)

        list_rt = [float(rt.text) for rt in soup.find_all(&#39;minutes&#39;)]
        list_tic = [float(tic.text) for tic in soup.find_all(&#39;tic&#39;)]
        list_scan = [int(scan.text) for scan in soup.find_all(&#39;count&#39;)]

        dict_scan_rt_tic = dict(zip(list_scan, zip(list_rt, list_tic)))
        
        return dict_scan_rt_tic
       
        
    def get_transient(self, scan_number=1):

        file_d_params = self.parse_parameters(self.parameter_filename_location)

        self.fix_freq_limits(file_d_params)

        from sys import platform
        
        if platform == &#34;win32&#34;:
            # Windows...
            dt = dtype(&#34;l&#34;)
        else:
            dt = dtype(&#34;i&#34;)

        # get rt, scan, and tic from scan.xml file, otherwise  using 0 defaults values 
        
        output_parameters = deepcopy(default_parameters(self.d_directory_location))

        if self.transient_data_path.name == &#39;ser&#39;:
            
            if self.scan_attr.exists():
                
                dict_scan_rt_tic = self.get_scan_attr()

                output_parameters[&#34;scan_number&#34;] = scan_number

                output_parameters[&#34;rt&#34;] = dict_scan_rt_tic.get(scan_number)[0]

                output_parameters[&#34;tic&#34;] = dict_scan_rt_tic.get(scan_number)[1]
        
        output_parameters[&#34;analyzer&#34;] = &#34;ICR&#34;

        output_parameters[&#34;label&#34;] = &#34;Bruker_Frequency&#34;

        output_parameters[&#34;Aterm&#34;] = float(file_d_params.get(&#34;ML1&#34;))

        output_parameters[&#34;Bterm&#34;] = float(file_d_params.get(&#34;ML2&#34;))

        output_parameters[&#34;Cterm&#34;] = float(file_d_params.get(&#34;ML3&#34;))

        output_parameters[&#34;exc_high_freq&#34;] = float(file_d_params.get(&#34;EXC_Freq_High&#34;))

        output_parameters[&#34;exc_low_freq&#34;] = float(file_d_params.get(&#34;EXC_Freq_Low&#34;))

        output_parameters[&#34;bandwidth&#34;] = float(file_d_params.get(&#34;SW_h&#34;))

        output_parameters[&#34;number_data_points&#34;] = int(file_d_params.get(&#34;TD&#34;))

        output_parameters[&#34;polarity&#34;] = str(file_d_params.get(&#34;Polarity&#34;))

        data_points = int(file_d_params.get(&#34;TD&#34;))

        scan = output_parameters[&#34;scan_number&#34;]
        from io import BytesIO
        if self.transient_data_path.name == &#39;ser&#39;:
            
            if isinstance(self.transient_data_path, S3Path):
                databin = BytesIO(self.transient_data_path.open(&#39;rb&#39;).read())
            
            else:
                databin = self.transient_data_path.open(&#39;rb&#39;)
               
            databin.seek((scan-1)*4*data_points)
            #read scan data and parse to 32int struct
            data = frombuffer(databin.read(4*data_points), dtype=dt)
        
        else:
            
            if isinstance(self.transient_data_path, S3Path):
                data = frombuffer(self.transient_data_path.open(&#39;rb&#39;).read(), dtype=dt)
            else:
                data = fromfile(self.transient_data_path, dtype=dt)
        
        return Transient(data, output_parameters)

    &#34;&#34;&#34;
        for key, values in default_parameters.items():
            print(key, values)
    &#34;&#34;&#34;
    def fix_freq_limits(self, d_parameters):

        highfreq = float(d_parameters.get(&#34;EXC_Freq_High&#34;))

        lowfreq = float(d_parameters.get(&#34;EXC_Freq_Low&#34;))

        # CR for compatibility with Apex format as there is no EXciteSweep file
        if not highfreq and lowfreq:

            excitation_sweep_filelocation = self.locate_file(
                self.d_directory_location, &#34;ExciteSweep&#34;
            )
            lowfreq, highfreq = self.get_excite_sweep_range(
                excitation_sweep_filelocation
            )
            d_parameters[&#34;EXC_Freq_High&#34;] = highfreq
            d_parameters[&#34;EXC_Freq_Low&#34;] = lowfreq

    @staticmethod
    def get_excite_sweep_range(filename):
        &#34;&#34;&#34;
        Function that returns the lower and higher frequency of the pulse generator
        &#34;&#34;&#34;
        ExciteSweep_lines = genfromtxt(filename, comments=&#34;*&#34;, delimiter=&#34;\n&#34;)
        # CR ready if we need the full array
        highfreq = fromstring(ExciteSweep_lines[0])
        lowfreq = fromstring(ExciteSweep_lines[-1])

        return lowfreq[0], highfreq[0]

    @staticmethod
    def locate_file(folder, type_file_name):
        
        from pathlib import Path
        &#34;&#34;&#34;
            type_of_file = ExciteSweep or apexAcquisition.method
            From the given folder this function return the absolute path to the ExciteSweep file, or the apexAcquisition.method file
            It should always be in a subfolder 
        
            &#39;&#39;&#39; this code is a adaptation/automation of spike library
                https://bitbucket.org/delsuc/spike/
                from Marc Delsuc
            &#39;&#39;&#39;
        &#34;&#34;&#34;
        
        directory_location = folder.glob( &#39;**/*apexAcquisition.method&#39;)
        result = list(directory_location)
        if len(result) &gt; 1:

            raise Exception(
                &#34;You have more than 1 %s file in the %s folder, using the first one&#34;
                % (type_file_name, folder)
            )

        elif len(result) == 0:

            raise Exception(
                &#34;You don&#39;t have any %s file in the  %s folder, please double check the path&#34;
                % (type_file_name, folder)
            )

        return result[0]

    @staticmethod
    def parse_parameters(parameters_filename):
        &#34;&#34;&#34; 
            TODO: change to beautiful soup xml parsing
            Open the given file and retrieve all parameters from apexAcquisition.method
            None is written when no value for value is found

            structure : &lt;param name = &#34;AMS_ActiveExclusion&#34;&gt;&lt;value&gt;0&lt;/value&gt;&lt;/param&gt;

            read_param returns  values in a dictionnary
            xml should be extinct, just a random option

            &#39;&#39;&#39; this code is a adaptation/automation of spike library
                https://bitbucket.org/delsuc/spike/
                from Marc Delsuc
            &#39;&#39;&#39;
        &#34;&#34;&#34;
        xmldoc = minidom.parse(parameters_filename.open())

        x = xmldoc.documentElement
        parameter_dict = {}
        children = x.childNodes
        for child in children:
            # print( child.node)
            if child.nodeName == &#34;reportinfo&#34;:
                sections = child.childNodes
                for section in sections:
                    if section.nodeName == &#34;section&#34;:
                        if section.getAttribute(&#34;title&#34;) == &#34;Main&#34;:
                            for element in section.childNodes:
                                if element.nodeName == &#34;section&#34;:
                                    if element.getAttribute(&#34;title&#34;) == &#34;Polarity&#34;:
                                        if (
                                            str(
                                                element.childNodes[1].getAttribute(
                                                    &#34;value&#34;
                                                )
                                            )
                                            == &#34;Negative&#34;
                                        ):
                                            parameter_dict[&#34;Polarity&#34;] = -1
                                        else:
                                            parameter_dict[&#34;Polarity&#34;] = 1

            if child.nodeName == &#34;paramlist&#34;:
                params = child.childNodes
                for param in params:
                    # print( param.nodeName)
                    if param.nodeName == &#34;param&#34;:
                        paramenter_label = str(param.getAttribute(&#34;name&#34;))
                        for element in param.childNodes:
                            if element.nodeName == &#34;value&#34;:
                                try:
                                    parameter_value = str(element.firstChild.toxml())
                                    # print v
                                except:
                                    parameter_value = None

                            parameter_dict[paramenter_label] = parameter_value

        return parameter_dict</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="corems.transient.input.brukerSolarix.ReadBrukerSolarix.get_excite_sweep_range"><code class="name flex">
<span>def <span class="ident">get_excite_sweep_range</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns the lower and higher frequency of the pulse generator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_excite_sweep_range(filename):
    &#34;&#34;&#34;
    Function that returns the lower and higher frequency of the pulse generator
    &#34;&#34;&#34;
    ExciteSweep_lines = genfromtxt(filename, comments=&#34;*&#34;, delimiter=&#34;\n&#34;)
    # CR ready if we need the full array
    highfreq = fromstring(ExciteSweep_lines[0])
    lowfreq = fromstring(ExciteSweep_lines[-1])

    return lowfreq[0], highfreq[0]</code></pre>
</details>
</dd>
<dt id="corems.transient.input.brukerSolarix.ReadBrukerSolarix.locate_file"><code class="name flex">
<span>def <span class="ident">locate_file</span></span>(<span>folder, type_file_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def locate_file(folder, type_file_name):
    
    from pathlib import Path
    &#34;&#34;&#34;
        type_of_file = ExciteSweep or apexAcquisition.method
        From the given folder this function return the absolute path to the ExciteSweep file, or the apexAcquisition.method file
        It should always be in a subfolder 
    
        &#39;&#39;&#39; this code is a adaptation/automation of spike library
            https://bitbucket.org/delsuc/spike/
            from Marc Delsuc
        &#39;&#39;&#39;
    &#34;&#34;&#34;
    
    directory_location = folder.glob( &#39;**/*apexAcquisition.method&#39;)
    result = list(directory_location)
    if len(result) &gt; 1:

        raise Exception(
            &#34;You have more than 1 %s file in the %s folder, using the first one&#34;
            % (type_file_name, folder)
        )

    elif len(result) == 0:

        raise Exception(
            &#34;You don&#39;t have any %s file in the  %s folder, please double check the path&#34;
            % (type_file_name, folder)
        )

    return result[0]</code></pre>
</details>
</dd>
<dt id="corems.transient.input.brukerSolarix.ReadBrukerSolarix.parse_parameters"><code class="name flex">
<span>def <span class="ident">parse_parameters</span></span>(<span>parameters_filename)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO: change to beautiful soup xml parsing
Open the given file and retrieve all parameters from apexAcquisition.method
None is written when no value for value is found</p>
<p>structure : <param name = "AMS_ActiveExclusion"><value>0</value></param></p>
<p>read_param returns
values in a dictionnary
xml should be extinct, just a random option</p>
<p>''' this code is a adaptation/automation of spike library
<a href="https://bitbucket.org/delsuc/spike/">https://bitbucket.org/delsuc/spike/</a>
from Marc Delsuc
'''</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_parameters(parameters_filename):
    &#34;&#34;&#34; 
        TODO: change to beautiful soup xml parsing
        Open the given file and retrieve all parameters from apexAcquisition.method
        None is written when no value for value is found

        structure : &lt;param name = &#34;AMS_ActiveExclusion&#34;&gt;&lt;value&gt;0&lt;/value&gt;&lt;/param&gt;

        read_param returns  values in a dictionnary
        xml should be extinct, just a random option

        &#39;&#39;&#39; this code is a adaptation/automation of spike library
            https://bitbucket.org/delsuc/spike/
            from Marc Delsuc
        &#39;&#39;&#39;
    &#34;&#34;&#34;
    xmldoc = minidom.parse(parameters_filename.open())

    x = xmldoc.documentElement
    parameter_dict = {}
    children = x.childNodes
    for child in children:
        # print( child.node)
        if child.nodeName == &#34;reportinfo&#34;:
            sections = child.childNodes
            for section in sections:
                if section.nodeName == &#34;section&#34;:
                    if section.getAttribute(&#34;title&#34;) == &#34;Main&#34;:
                        for element in section.childNodes:
                            if element.nodeName == &#34;section&#34;:
                                if element.getAttribute(&#34;title&#34;) == &#34;Polarity&#34;:
                                    if (
                                        str(
                                            element.childNodes[1].getAttribute(
                                                &#34;value&#34;
                                            )
                                        )
                                        == &#34;Negative&#34;
                                    ):
                                        parameter_dict[&#34;Polarity&#34;] = -1
                                    else:
                                        parameter_dict[&#34;Polarity&#34;] = 1

        if child.nodeName == &#34;paramlist&#34;:
            params = child.childNodes
            for param in params:
                # print( param.nodeName)
                if param.nodeName == &#34;param&#34;:
                    paramenter_label = str(param.getAttribute(&#34;name&#34;))
                    for element in param.childNodes:
                        if element.nodeName == &#34;value&#34;:
                            try:
                                parameter_value = str(element.firstChild.toxml())
                                # print v
                            except:
                                parameter_value = None

                        parameter_dict[paramenter_label] = parameter_value

    return parameter_dict</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="corems.transient.input.brukerSolarix.ReadBrukerSolarix.fix_freq_limits"><code class="name flex">
<span>def <span class="ident">fix_freq_limits</span></span>(<span>self, d_parameters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fix_freq_limits(self, d_parameters):

    highfreq = float(d_parameters.get(&#34;EXC_Freq_High&#34;))

    lowfreq = float(d_parameters.get(&#34;EXC_Freq_Low&#34;))

    # CR for compatibility with Apex format as there is no EXciteSweep file
    if not highfreq and lowfreq:

        excitation_sweep_filelocation = self.locate_file(
            self.d_directory_location, &#34;ExciteSweep&#34;
        )
        lowfreq, highfreq = self.get_excite_sweep_range(
            excitation_sweep_filelocation
        )
        d_parameters[&#34;EXC_Freq_High&#34;] = highfreq
        d_parameters[&#34;EXC_Freq_Low&#34;] = lowfreq</code></pre>
</details>
</dd>
<dt id="corems.transient.input.brukerSolarix.ReadBrukerSolarix.get_scan_attr"><code class="name flex">
<span>def <span class="ident">get_scan_attr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_scan_attr(self):

    from bs4 import BeautifulSoup
    
    soup = BeautifulSoup(self.scan_attr.open(),&#39;xml&#39;)

    list_rt = [float(rt.text) for rt in soup.find_all(&#39;minutes&#39;)]
    list_tic = [float(tic.text) for tic in soup.find_all(&#39;tic&#39;)]
    list_scan = [int(scan.text) for scan in soup.find_all(&#39;count&#39;)]

    dict_scan_rt_tic = dict(zip(list_scan, zip(list_rt, list_tic)))
    
    return dict_scan_rt_tic</code></pre>
</details>
</dd>
<dt id="corems.transient.input.brukerSolarix.ReadBrukerSolarix.get_transient"><code class="name flex">
<span>def <span class="ident">get_transient</span></span>(<span>self, scan_number=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transient(self, scan_number=1):

    file_d_params = self.parse_parameters(self.parameter_filename_location)

    self.fix_freq_limits(file_d_params)

    from sys import platform
    
    if platform == &#34;win32&#34;:
        # Windows...
        dt = dtype(&#34;l&#34;)
    else:
        dt = dtype(&#34;i&#34;)

    # get rt, scan, and tic from scan.xml file, otherwise  using 0 defaults values 
    
    output_parameters = deepcopy(default_parameters(self.d_directory_location))

    if self.transient_data_path.name == &#39;ser&#39;:
        
        if self.scan_attr.exists():
            
            dict_scan_rt_tic = self.get_scan_attr()

            output_parameters[&#34;scan_number&#34;] = scan_number

            output_parameters[&#34;rt&#34;] = dict_scan_rt_tic.get(scan_number)[0]

            output_parameters[&#34;tic&#34;] = dict_scan_rt_tic.get(scan_number)[1]
    
    output_parameters[&#34;analyzer&#34;] = &#34;ICR&#34;

    output_parameters[&#34;label&#34;] = &#34;Bruker_Frequency&#34;

    output_parameters[&#34;Aterm&#34;] = float(file_d_params.get(&#34;ML1&#34;))

    output_parameters[&#34;Bterm&#34;] = float(file_d_params.get(&#34;ML2&#34;))

    output_parameters[&#34;Cterm&#34;] = float(file_d_params.get(&#34;ML3&#34;))

    output_parameters[&#34;exc_high_freq&#34;] = float(file_d_params.get(&#34;EXC_Freq_High&#34;))

    output_parameters[&#34;exc_low_freq&#34;] = float(file_d_params.get(&#34;EXC_Freq_Low&#34;))

    output_parameters[&#34;bandwidth&#34;] = float(file_d_params.get(&#34;SW_h&#34;))

    output_parameters[&#34;number_data_points&#34;] = int(file_d_params.get(&#34;TD&#34;))

    output_parameters[&#34;polarity&#34;] = str(file_d_params.get(&#34;Polarity&#34;))

    data_points = int(file_d_params.get(&#34;TD&#34;))

    scan = output_parameters[&#34;scan_number&#34;]
    from io import BytesIO
    if self.transient_data_path.name == &#39;ser&#39;:
        
        if isinstance(self.transient_data_path, S3Path):
            databin = BytesIO(self.transient_data_path.open(&#39;rb&#39;).read())
        
        else:
            databin = self.transient_data_path.open(&#39;rb&#39;)
           
        databin.seek((scan-1)*4*data_points)
        #read scan data and parse to 32int struct
        data = frombuffer(databin.read(4*data_points), dtype=dt)
    
    else:
        
        if isinstance(self.transient_data_path, S3Path):
            data = frombuffer(self.transient_data_path.open(&#39;rb&#39;).read(), dtype=dt)
        else:
            data = fromfile(self.transient_data_path, dtype=dt)
    
    return Transient(data, output_parameters)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.transient.input" href="index.html">corems.transient.input</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="corems.transient.input.brukerSolarix.ReadBrukerSolarix" href="#corems.transient.input.brukerSolarix.ReadBrukerSolarix">ReadBrukerSolarix</a></code></h4>
<ul class="">
<li><code><a title="corems.transient.input.brukerSolarix.ReadBrukerSolarix.fix_freq_limits" href="#corems.transient.input.brukerSolarix.ReadBrukerSolarix.fix_freq_limits">fix_freq_limits</a></code></li>
<li><code><a title="corems.transient.input.brukerSolarix.ReadBrukerSolarix.get_excite_sweep_range" href="#corems.transient.input.brukerSolarix.ReadBrukerSolarix.get_excite_sweep_range">get_excite_sweep_range</a></code></li>
<li><code><a title="corems.transient.input.brukerSolarix.ReadBrukerSolarix.get_scan_attr" href="#corems.transient.input.brukerSolarix.ReadBrukerSolarix.get_scan_attr">get_scan_attr</a></code></li>
<li><code><a title="corems.transient.input.brukerSolarix.ReadBrukerSolarix.get_transient" href="#corems.transient.input.brukerSolarix.ReadBrukerSolarix.get_transient">get_transient</a></code></li>
<li><code><a title="corems.transient.input.brukerSolarix.ReadBrukerSolarix.locate_file" href="#corems.transient.input.brukerSolarix.ReadBrukerSolarix.locate_file">locate_file</a></code></li>
<li><code><a title="corems.transient.input.brukerSolarix.ReadBrukerSolarix.parse_parameters" href="#corems.transient.input.brukerSolarix.ReadBrukerSolarix.parse_parameters">parse_parameters</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>