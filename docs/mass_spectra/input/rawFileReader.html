<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.mass_spectra.input.rawFileReader API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.mass_spectra.input.rawFileReader</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy
import multiprocessing
from threading import Thread
import sys
import site
from pathlib import Path
from io import BytesIO

import clr
import pandas as pd
from s3path import S3Path
from tqdm import tqdm


from corems.encapsulation.constant import Labels
from corems.mass_spectrum.factory.MassSpectrumClasses import MassSpecProfile, MassSpecCentroid
from corems.mass_spectra.factory.LC_Class import LCMSBase
from corems.encapsulation.factory.parameters import default_parameters


# do not change the order from the imports statements and reference below
sys.path.append(site.getsitepackages()[0] + &#34;/ext_lib&#34;)
sys.path.append(&#34;ext_lib&#34;)

clr.AddReference(&#34;ThermoFisher.CommonCore.RawFileReader&#34;)
clr.AddReference(&#34;ThermoFisher.CommonCore.Data&#34;)
clr.AddReference(&#34;ThermoFisher.CommonCore.MassPrecisionEstimator&#34;)

from ThermoFisher.CommonCore.RawFileReader import RawFileReaderAdapter
from ThermoFisher.CommonCore.Data import ToleranceUnits, Extensions
from ThermoFisher.CommonCore.Data.Business import MassOptions
from ThermoFisher.CommonCore.Data.FilterEnums import MSOrderType
from System.Collections.Generic import List

class ImportMassSpectraThermoMSFileReader():

    &#34;&#34;&#34;  Collection of methods to import Summed/Averaged mass spectrum from Thermo&#39;s raw file
         Currently only profile mode data are supported
         Returns MassSpecProfile object
    &#34;&#34;&#34;

    def __init__(self, file_location):

        # Thread.__init__(self)
        if isinstance(file_location, str):
            file_path = Path(file_location)

        elif isinstance(file_location, S3Path):

            temp_dir = Path(&#39;tmp/&#39;)
            temp_dir.mkdir(exist_ok=True)

            file_path = temp_dir / file_location.name
            with open(file_path, &#39;wb&#39;) as fh:
                fh.write(file_location.read_bytes())

        else:
            file_path = file_location

        self.iRawDataPlus = RawFileReaderAdapter.FileFactory(str(file_path))

        # removing tmp file

        if isinstance(file_location, S3Path):
            file_path.unlink()

        self.res = self.iRawDataPlus.SelectInstrument(0, 1)

        self._initial_scan_number = self.iRawDataPlus.RunHeaderEx.FirstSpectrum

        self._final_scan_number = self.iRawDataPlus.RunHeaderEx.LastSpectrum

        self.file_location = file_location

    @property
    def initial_scan_number(self):
        return self._initial_scan_number

    @property
    def final_scan_number(self):
        return self._final_scan_number

    def get_filter_for_scan_num(self, scan_number):
        &#34;&#34;&#34;
        Returns the closest matching run time that corresponds to scan_number for the current
        controller. This function is only supported for MS device controllers.
        e.g.  [&#39;FTMS&#39;, &#39;-&#39;, &#39;p&#39;, &#39;NSI&#39;, &#39;Full&#39;, &#39;ms&#39;, &#39;[200.00-1000.00]&#39;]
        &#34;&#34;&#34;
        scan_label = self.iRawDataPlus.GetScanEventStringForScanNumber(
            scan_number)

        return str(scan_label).split()

    def get_all_filters(self):
        &#34;&#34;&#34;
        Get all scan filters.
        This function is only supported for MS device controllers.
        e.g.  [&#39;FTMS&#39;, &#39;-&#39;, &#39;p&#39;, &#39;NSI&#39;, &#39;Full&#39;, &#39;ms&#39;, &#39;[200.00-1000.00]&#39;]
        &#34;&#34;&#34;
        scanrange = range(self._initial_scan_number, self._final_scan_number + 1)
        scanfiltersdic = {}
        scanfilterslist = []
        for scan_number in scanrange:
            scan_label = self.iRawDataPlus.GetScanEventStringForScanNumber(scan_number)
            scanfiltersdic[scan_number] = scan_label
            scanfilterslist.append(scan_label)
        scanfilterset = list(set(scanfilterslist))
        return scanfiltersdic, scanfilterset

    def check_full_scan(self, scan_number):
        # scan_filter.ScanMode 0 = FULL
        scan_filter = self.iRawDataPlus.GetFilterForScanNumber(scan_number)

        return scan_filter.ScanMode == MSOrderType.Ms

    def get_polarity_mode(self, scan_number):

        polarity_symbol = self.get_filter_for_scan_num(scan_number)[1]

        if polarity_symbol == &#34;+&#34;:

            return 1
            # return &#34;POSITIVE_ION_MODE&#34;

        elif polarity_symbol == &#34;-&#34;:

            return -1

        else:

            raise Exception(&#34;Polarity Mode Unknown, please set it manually&#34;)

    def get_scan_header(self, scan):
        &#39;&#39;&#39;
        Get full dictionary of scan header meta data, i.e. AGC status, ion injection time, etc.
        &#39;&#39;&#39;
        header = self.iRawDataPlus.GetTrailerExtraInformation(scan)
        header_dic = {}
        for i in numpy.arange(header.Length):
            header_dic.update({header.Labels[i]: header.Values[i]})
        return header_dic

    def get_icr_transient_times(self, first_scan: int = None, last_scan: int = None):
        &#39;&#39;&#39;
        Return a list for transient time targets for all scans, or selected scans range
        Resolving Power and Transient time targets based on 7T FT-ICR MS system
        &#39;&#39;&#39;

        res_trans_time = {&#34;50&#34;: 0.384,
                          &#34;100000&#34;: 0.768,
                          &#34;200000&#34;: 1.536,
                          &#34;400000&#34;: 3.072,
                          &#34;750000&#34;: 6.144,
                          &#34;1000000&#34;: 12.288
                          }

        firstScanNumber = self._initial_scan_number if first_scan is None else first_scan

        lastScanNumber = self._final_scan_number if last_scan is None else last_scan

        transient_time_list = []

        for scan in range(firstScanNumber, lastScanNumber):

            scan_header = self.get_scan_header(scan)

            rp_target = scan_header[&#39;FT Resolution:&#39;]

            transient_time = res_trans_time.get(rp_target)

            transient_time_list.append(transient_time)

            # print(transient_time, rp_target)

        return transient_time_list

    def get_data(self, scan, d_parameter, scan_type):

        if scan_type == &#34;Centroid&#34;:

            centroidStream = self.iRawDataPlus.GetCentroidStream(scan, False)

            noise = list(centroidStream.Noises)

            baselines = list(centroidStream.Baselines)

            rp = list(centroidStream.Resolutions)

            magnitude = list(centroidStream.Intensities)

            mz = list(centroidStream.Masses)

            # charge = scans_labels[5]
            array_noise_std = (numpy.array(noise) - numpy.array(baselines)) / 3
            l_signal_to_noise = numpy.array(magnitude) / array_noise_std

            d_parameter[&#34;baselise_noise&#34;] = numpy.average(array_noise_std)

            d_parameter[&#34;baselise_noise_std&#34;] = numpy.std(array_noise_std)

            data_dict = {
                Labels.mz: mz,
                Labels.abundance: magnitude,
                Labels.rp: rp,
                Labels.s2n: l_signal_to_noise,
            }

        else:

            scanStatistics = self.iRawDataPlus.GetScanStatsForScanNumber(scan)

            profileStream = self.iRawDataPlus.GetSegmentedScanFromScanNumber(
                scan, scanStatistics)

            magnitude = list(profileStream.Intensities)

            mz = list(profileStream.Positions)

            data_dict = {
                Labels.mz: mz,
                Labels.abundance: magnitude,
            }

        return data_dict

    def set_metadata(self, firstScanNumber=0, lastScanNumber=0, scans_list=False):
        &#34;&#34;&#34;
        Collect metadata to be ingested in the mass spectrum object

        scans_list: list[int] or false
        lastScanNumber: int
        firstScanNumber: int
        &#34;&#34;&#34;

        d_params = default_parameters(self.file_location)

        # assumes scans is full scan or reduced profile scan

        d_params[&#34;label&#34;] = Labels.thermo_profile

        if scans_list:
            d_params[&#39;scan_number&#39;] = scans_list

            d_params[&#34;polarity&#34;] = self.get_polarity_mode(scans_list[0])

        else:

            d_params[&#39;scan_number&#39;] = &#34;{}-{}&#34;.format(firstScanNumber, lastScanNumber)

            d_params[&#34;polarity&#34;] = self.get_polarity_mode(firstScanNumber)

        d_params[&#39;analyzer&#39;] = self.iRawDataPlus.GetInstrumentData().Model

        d_params[&#39;instrument_label&#39;] = self.iRawDataPlus.GetInstrumentData().Name

        return d_params

    def get_average_mass_spectrum_by_scanlist(self, scans_list, auto_process: bool = True, ppm_tolerance: float = 5.0):

        &#34;&#34;&#34;
        Averages selected scans mass spectra using Thermo&#39;s AverageScans method
        scans_list: list[int]
        auto_process: bool
            If true performs peak picking, and noise threshold calculation after creation of mass spectrum object
        Returns:
            MassSpecProfile
        &#34;&#34;&#34;

        d_params = self.set_metadata(scans_list=scans_list)

        # assumes scans is full scan or reduced profile scan

        scans = List[int]()
        for scan in scans_list:
            scans.Add(scan)

        # Create the mass options object that will be used when averaging the scans
        options = MassOptions()
        options.ToleranceUnits = ToleranceUnits.ppm
        options.Tolerance = ppm_tolerance

        # Get the scan filter for the first scan.  This scan filter will be used to located
        # scans within the given scan range of the same type

        averageScan = Extensions.AverageScans(self.iRawDataPlus, scans, options)

        len_data = averageScan.SegmentedScan.Positions.Length

        mz_list = list(averageScan.SegmentedScan.Positions)
        abund_list = list(averageScan.SegmentedScan.Intensities)

        data_dict = {Labels.mz: mz_list,
                     Labels.abundance: abund_list,
                     }

        mass_spec = MassSpecProfile(data_dict, d_params, auto_process=auto_process)

        return mass_spec

    def get_average_mass_spectrum_in_scan_range(self, first_scan: int = None, last_scan: int = None, auto_process: bool = True, ppm_tolerance: float = 5.0, ms_type=MSOrderType.Ms):

        &#34;&#34;&#34;
        Averages mass spectra over a scan range using Thermo&#39;s AverageScansInScanRange method
        first_scan: int
        last_scan: int
        auto_process: bool
            If true performs peak picking, and noise threshold calculation after creation of mass spectrum object
        ms_type: MSOrderType.MS
            Type of mass spectrum scan, default for full scan acquisition
         Returns:
            MassSpecProfile    
        &#34;&#34;&#34;

        firstScanNumber = self._initial_scan_number if first_scan is None else first_scan

        lastScanNumber = self._final_scan_number if last_scan is None else last_scan

        d_params = self.set_metadata(firstScanNumber=firstScanNumber, lastScanNumber=lastScanNumber)

        # Create the mass options object that will be used when averaging the scans
        options = MassOptions()

        options.ToleranceUnits = ToleranceUnits.ppm
        options.Tolerance = ppm_tolerance

        # Get the scan filter for the first scan.  This scan filter will be used to located
        # scans within the given scan range of the same type
        scanFilter = self.iRawDataPlus.GetFilterForScanNumber(firstScanNumber)

        # force it to only look for the MSType
        scanFilter.MSOrder = ms_type

        averageScan = Extensions.AverageScansInScanRange(self.iRawDataPlus, firstScanNumber, lastScanNumber, scanFilter, options)

        if averageScan:
            mz_list = list(averageScan.SegmentedScan.Positions)
            abund_list = list(averageScan.SegmentedScan.Intensities)

            data_dict = {Labels.mz: mz_list,
                         Labels.abundance: abund_list,
                         }

            mass_spec = MassSpecProfile(data_dict, d_params, auto_process=auto_process)

            return mass_spec
        else:
            raise Exception(&#39;no data found for the MSOrderType = {}&#39;.format(ms_type))

    def get_summed_mass_spectrum(self, initial_scan_number, final_scan_number=None,
                                 auto_process=True, pd_method=True, pd_merge_n=100):

        &#34;&#34;&#34;
        Manually sum mass spectrum over a scan range
        initial_scan_number: int
        final_scan_number: int
        auto_process: bool
            If true performs peak picking, and noise threshold calculation after creation of mass spectrum object 
        pd_method: bool
            If true uses pandas to align and sum data
            Else: Assumes data is aligned and sum each data point across all mass spectra
        Returns:
            MassSpecProfile    
        &#34;&#34;&#34;

        d_params = default_parameters(self.file_location)

        # assumes scans is full scan or reduced profile scan

        d_params[&#34;label&#34;] = Labels.thermo_profile

        if type(initial_scan_number) is list:
            d_params[&#34;polarity&#34;] = self.get_polarity_mode(initial_scan_number[0])

            scanrange = initial_scan_number
        else:
            d_params[&#34;polarity&#34;] = self.get_polarity_mode(initial_scan_number)

            if final_scan_number is None:
                final_scan_number = self._final_scan_number

            scanrange = range(initial_scan_number, final_scan_number + 1)

        if pd_method:

            def sort_sum_df(df):
                &#34;&#34;&#34;
                Nested function to sort dataframe and sum rows with exact matching indexes (m/z)
                &#34;&#34;&#34;
                df = df.sort_index()
                df = df.groupby(level=0).sum()
                return df

            # initialise empty Pandas series
            big_df = pd.Series(index=[], dtype=&#39;float64&#39;)

            for scan_number in tqdm(scanrange):
                scanStatistics = self.iRawDataPlus.GetScanStatsForScanNumber(scan_number)
                segmentedScan = self.iRawDataPlus.GetSegmentedScanFromScanNumber(scan_number, scanStatistics)

                tmp_df = pd.Series(index=list(segmentedScan.Positions),
                                   dtype=&#39;float64&#39;, data=list(segmentedScan.Intensities))
                big_df = big_df.append(tmp_df)

                # this allows you to merge/sum the values earlier, however it slows down a lot
                # limited benefit unless running into memory issues
                # for complex data it is necessary to stop the iterations getting too slow
                if scan_number % pd_merge_n == 0:
                    big_df = sort_sum_df(big_df)

            big_df = sort_sum_df(big_df)
            data_dict = {Labels.mz: list(big_df.index.values),
                         Labels.abundance: list(big_df.values),
                         }
        else:
            all_mz = dict()

            for scan_number in tqdm(scanrange):

                scanStatistics = self.iRawDataPlus.GetScanStatsForScanNumber(scan_number)

                segmentedScan = self.iRawDataPlus.GetSegmentedScanFromScanNumber(scan_number, scanStatistics)

                len_data = segmentedScan.Positions.Length

                for i in range(len_data):

                    mz = segmentedScan.Positions[i]
                    abundance = segmentedScan.Intensities[i]

                    if mz in all_mz:
                        all_mz[mz] = all_mz[mz] + abundance
                    else:
                        all_mz[mz] = abundance

            mz_all = []
            abun_all = []

            for mz in sorted(all_mz):
                mz_all.append(mz)
                abun_all.append(all_mz[mz])

            data_dict = {Labels.mz: mz_all,
                         Labels.abundance: abun_all,
                         }

        print(&#39;Summed. Now Processing.&#39;)

        mass_spec = MassSpecProfile(data_dict, d_params, auto_process=auto_process)

        return mass_spec

    def get_tic(self, plot=False):
        &#34;&#34;&#34;
        Reads the TIC values for each scan from the Thermo headers
        Returns a pandas dataframe of Scans, TICs, and Times
        (Optionally) plots the TIC chromatogram.
        &#34;&#34;&#34;
        first_scan = self._initial_scan_number
        final_scan = self._final_scan_number
        scanrange = range(first_scan, final_scan + 1)

        ms_tic = pd.DataFrame(index=scanrange, columns=[&#39;Time&#39;, &#39;TIC&#39;])
        for scan in scanrange:
            scanStatistics = self.iRawDataPlus.GetScanStatsForScanNumber(scan)
            ms_tic.loc[scan, &#39;Time&#39;] = scanStatistics.StartTime
            ms_tic.loc[scan, &#39;TIC&#39;] = scanStatistics.TIC

        if plot:
            import matplotlib.pyplot as plt  # maybe better in top of file?
            fig, ax = plt.subplots(figsize=(6, 3))
            ax.plot(ms_tic[&#39;Time&#39;], ms_tic[&#39;TIC&#39;], label=&#39;TIC&#39;)
            ax.set_xlabel(&#39;Time (min)&#39;)
            ax.set_ylabel(&#39;a.u.&#39;)
            plt.legend()
            # plt.show()
            return ms_tic, fig

        return ms_tic

    def get_best_scans_idx(self, stdevs=2, method=&#39;mean&#39;, plot=False):
        &#39;&#39;&#39;
        Method to determine the best scan indexes for selective co-addition
        Based on calculating the mean (default) of the TIC values
        and setting an upper limit above/below that within X standard deviations.
        Mean or median makes limited difference, it seems.
        Empirically, 1-2 stdevs enough to filter out the worst datapoints.
        Optionally, plot the TIC with horizontal lines for the standard dev cutoffs.
        &#39;&#39;&#39;
        tic = self.get_tic()

        if method == &#39;median&#39;:
            tic_median = tic[&#39;TIC&#39;].median()
        elif method == &#39;mean&#39;:
            tic_median = tic[&#39;TIC&#39;].mean()
        else:
            print(&#34;Method &#34; + str(method) + &#34; undefined&#34;)

        tic_std = tic[&#39;TIC&#39;].std()

        upperlimit = tic_median - (stdevs * tic_std)
        lowerlimit = tic_median + (stdevs * tic_std)

        tic_filtered = tic[(tic[&#39;TIC&#39;] &gt; upperlimit) &amp; (tic[&#39;TIC&#39;] &lt; lowerlimit)]
        scans = list(tic_filtered.index.values)

        if plot:
            import matplotlib.pyplot as plt
            fig, ax = plt.subplots(figsize=(8, 4))
            ax.plot(tic[&#39;Time&#39;], tic[&#39;TIC&#39;])
            ax.axhline(y=upperlimit, c=&#39;r&#39;)
            ax.axhline(y=lowerlimit, c=&#39;r&#39;)
            return fig, scans
        else:
            return scans</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader"><code class="flex name class">
<span>class <span class="ident">ImportMassSpectraThermoMSFileReader</span></span>
<span>(</span><span>file_location)</span>
</code></dt>
<dd>
<div class="desc"><p>Collection of methods to import Summed/Averaged mass spectrum from Thermo's raw file
Currently only profile mode data are supported
Returns MassSpecProfile object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImportMassSpectraThermoMSFileReader():

    &#34;&#34;&#34;  Collection of methods to import Summed/Averaged mass spectrum from Thermo&#39;s raw file
         Currently only profile mode data are supported
         Returns MassSpecProfile object
    &#34;&#34;&#34;

    def __init__(self, file_location):

        # Thread.__init__(self)
        if isinstance(file_location, str):
            file_path = Path(file_location)

        elif isinstance(file_location, S3Path):

            temp_dir = Path(&#39;tmp/&#39;)
            temp_dir.mkdir(exist_ok=True)

            file_path = temp_dir / file_location.name
            with open(file_path, &#39;wb&#39;) as fh:
                fh.write(file_location.read_bytes())

        else:
            file_path = file_location

        self.iRawDataPlus = RawFileReaderAdapter.FileFactory(str(file_path))

        # removing tmp file

        if isinstance(file_location, S3Path):
            file_path.unlink()

        self.res = self.iRawDataPlus.SelectInstrument(0, 1)

        self._initial_scan_number = self.iRawDataPlus.RunHeaderEx.FirstSpectrum

        self._final_scan_number = self.iRawDataPlus.RunHeaderEx.LastSpectrum

        self.file_location = file_location

    @property
    def initial_scan_number(self):
        return self._initial_scan_number

    @property
    def final_scan_number(self):
        return self._final_scan_number

    def get_filter_for_scan_num(self, scan_number):
        &#34;&#34;&#34;
        Returns the closest matching run time that corresponds to scan_number for the current
        controller. This function is only supported for MS device controllers.
        e.g.  [&#39;FTMS&#39;, &#39;-&#39;, &#39;p&#39;, &#39;NSI&#39;, &#39;Full&#39;, &#39;ms&#39;, &#39;[200.00-1000.00]&#39;]
        &#34;&#34;&#34;
        scan_label = self.iRawDataPlus.GetScanEventStringForScanNumber(
            scan_number)

        return str(scan_label).split()

    def get_all_filters(self):
        &#34;&#34;&#34;
        Get all scan filters.
        This function is only supported for MS device controllers.
        e.g.  [&#39;FTMS&#39;, &#39;-&#39;, &#39;p&#39;, &#39;NSI&#39;, &#39;Full&#39;, &#39;ms&#39;, &#39;[200.00-1000.00]&#39;]
        &#34;&#34;&#34;
        scanrange = range(self._initial_scan_number, self._final_scan_number + 1)
        scanfiltersdic = {}
        scanfilterslist = []
        for scan_number in scanrange:
            scan_label = self.iRawDataPlus.GetScanEventStringForScanNumber(scan_number)
            scanfiltersdic[scan_number] = scan_label
            scanfilterslist.append(scan_label)
        scanfilterset = list(set(scanfilterslist))
        return scanfiltersdic, scanfilterset

    def check_full_scan(self, scan_number):
        # scan_filter.ScanMode 0 = FULL
        scan_filter = self.iRawDataPlus.GetFilterForScanNumber(scan_number)

        return scan_filter.ScanMode == MSOrderType.Ms

    def get_polarity_mode(self, scan_number):

        polarity_symbol = self.get_filter_for_scan_num(scan_number)[1]

        if polarity_symbol == &#34;+&#34;:

            return 1
            # return &#34;POSITIVE_ION_MODE&#34;

        elif polarity_symbol == &#34;-&#34;:

            return -1

        else:

            raise Exception(&#34;Polarity Mode Unknown, please set it manually&#34;)

    def get_scan_header(self, scan):
        &#39;&#39;&#39;
        Get full dictionary of scan header meta data, i.e. AGC status, ion injection time, etc.
        &#39;&#39;&#39;
        header = self.iRawDataPlus.GetTrailerExtraInformation(scan)
        header_dic = {}
        for i in numpy.arange(header.Length):
            header_dic.update({header.Labels[i]: header.Values[i]})
        return header_dic

    def get_icr_transient_times(self, first_scan: int = None, last_scan: int = None):
        &#39;&#39;&#39;
        Return a list for transient time targets for all scans, or selected scans range
        Resolving Power and Transient time targets based on 7T FT-ICR MS system
        &#39;&#39;&#39;

        res_trans_time = {&#34;50&#34;: 0.384,
                          &#34;100000&#34;: 0.768,
                          &#34;200000&#34;: 1.536,
                          &#34;400000&#34;: 3.072,
                          &#34;750000&#34;: 6.144,
                          &#34;1000000&#34;: 12.288
                          }

        firstScanNumber = self._initial_scan_number if first_scan is None else first_scan

        lastScanNumber = self._final_scan_number if last_scan is None else last_scan

        transient_time_list = []

        for scan in range(firstScanNumber, lastScanNumber):

            scan_header = self.get_scan_header(scan)

            rp_target = scan_header[&#39;FT Resolution:&#39;]

            transient_time = res_trans_time.get(rp_target)

            transient_time_list.append(transient_time)

            # print(transient_time, rp_target)

        return transient_time_list

    def get_data(self, scan, d_parameter, scan_type):

        if scan_type == &#34;Centroid&#34;:

            centroidStream = self.iRawDataPlus.GetCentroidStream(scan, False)

            noise = list(centroidStream.Noises)

            baselines = list(centroidStream.Baselines)

            rp = list(centroidStream.Resolutions)

            magnitude = list(centroidStream.Intensities)

            mz = list(centroidStream.Masses)

            # charge = scans_labels[5]
            array_noise_std = (numpy.array(noise) - numpy.array(baselines)) / 3
            l_signal_to_noise = numpy.array(magnitude) / array_noise_std

            d_parameter[&#34;baselise_noise&#34;] = numpy.average(array_noise_std)

            d_parameter[&#34;baselise_noise_std&#34;] = numpy.std(array_noise_std)

            data_dict = {
                Labels.mz: mz,
                Labels.abundance: magnitude,
                Labels.rp: rp,
                Labels.s2n: l_signal_to_noise,
            }

        else:

            scanStatistics = self.iRawDataPlus.GetScanStatsForScanNumber(scan)

            profileStream = self.iRawDataPlus.GetSegmentedScanFromScanNumber(
                scan, scanStatistics)

            magnitude = list(profileStream.Intensities)

            mz = list(profileStream.Positions)

            data_dict = {
                Labels.mz: mz,
                Labels.abundance: magnitude,
            }

        return data_dict

    def set_metadata(self, firstScanNumber=0, lastScanNumber=0, scans_list=False):
        &#34;&#34;&#34;
        Collect metadata to be ingested in the mass spectrum object

        scans_list: list[int] or false
        lastScanNumber: int
        firstScanNumber: int
        &#34;&#34;&#34;

        d_params = default_parameters(self.file_location)

        # assumes scans is full scan or reduced profile scan

        d_params[&#34;label&#34;] = Labels.thermo_profile

        if scans_list:
            d_params[&#39;scan_number&#39;] = scans_list

            d_params[&#34;polarity&#34;] = self.get_polarity_mode(scans_list[0])

        else:

            d_params[&#39;scan_number&#39;] = &#34;{}-{}&#34;.format(firstScanNumber, lastScanNumber)

            d_params[&#34;polarity&#34;] = self.get_polarity_mode(firstScanNumber)

        d_params[&#39;analyzer&#39;] = self.iRawDataPlus.GetInstrumentData().Model

        d_params[&#39;instrument_label&#39;] = self.iRawDataPlus.GetInstrumentData().Name

        return d_params

    def get_average_mass_spectrum_by_scanlist(self, scans_list, auto_process: bool = True, ppm_tolerance: float = 5.0):

        &#34;&#34;&#34;
        Averages selected scans mass spectra using Thermo&#39;s AverageScans method
        scans_list: list[int]
        auto_process: bool
            If true performs peak picking, and noise threshold calculation after creation of mass spectrum object
        Returns:
            MassSpecProfile
        &#34;&#34;&#34;

        d_params = self.set_metadata(scans_list=scans_list)

        # assumes scans is full scan or reduced profile scan

        scans = List[int]()
        for scan in scans_list:
            scans.Add(scan)

        # Create the mass options object that will be used when averaging the scans
        options = MassOptions()
        options.ToleranceUnits = ToleranceUnits.ppm
        options.Tolerance = ppm_tolerance

        # Get the scan filter for the first scan.  This scan filter will be used to located
        # scans within the given scan range of the same type

        averageScan = Extensions.AverageScans(self.iRawDataPlus, scans, options)

        len_data = averageScan.SegmentedScan.Positions.Length

        mz_list = list(averageScan.SegmentedScan.Positions)
        abund_list = list(averageScan.SegmentedScan.Intensities)

        data_dict = {Labels.mz: mz_list,
                     Labels.abundance: abund_list,
                     }

        mass_spec = MassSpecProfile(data_dict, d_params, auto_process=auto_process)

        return mass_spec

    def get_average_mass_spectrum_in_scan_range(self, first_scan: int = None, last_scan: int = None, auto_process: bool = True, ppm_tolerance: float = 5.0, ms_type=MSOrderType.Ms):

        &#34;&#34;&#34;
        Averages mass spectra over a scan range using Thermo&#39;s AverageScansInScanRange method
        first_scan: int
        last_scan: int
        auto_process: bool
            If true performs peak picking, and noise threshold calculation after creation of mass spectrum object
        ms_type: MSOrderType.MS
            Type of mass spectrum scan, default for full scan acquisition
         Returns:
            MassSpecProfile    
        &#34;&#34;&#34;

        firstScanNumber = self._initial_scan_number if first_scan is None else first_scan

        lastScanNumber = self._final_scan_number if last_scan is None else last_scan

        d_params = self.set_metadata(firstScanNumber=firstScanNumber, lastScanNumber=lastScanNumber)

        # Create the mass options object that will be used when averaging the scans
        options = MassOptions()

        options.ToleranceUnits = ToleranceUnits.ppm
        options.Tolerance = ppm_tolerance

        # Get the scan filter for the first scan.  This scan filter will be used to located
        # scans within the given scan range of the same type
        scanFilter = self.iRawDataPlus.GetFilterForScanNumber(firstScanNumber)

        # force it to only look for the MSType
        scanFilter.MSOrder = ms_type

        averageScan = Extensions.AverageScansInScanRange(self.iRawDataPlus, firstScanNumber, lastScanNumber, scanFilter, options)

        if averageScan:
            mz_list = list(averageScan.SegmentedScan.Positions)
            abund_list = list(averageScan.SegmentedScan.Intensities)

            data_dict = {Labels.mz: mz_list,
                         Labels.abundance: abund_list,
                         }

            mass_spec = MassSpecProfile(data_dict, d_params, auto_process=auto_process)

            return mass_spec
        else:
            raise Exception(&#39;no data found for the MSOrderType = {}&#39;.format(ms_type))

    def get_summed_mass_spectrum(self, initial_scan_number, final_scan_number=None,
                                 auto_process=True, pd_method=True, pd_merge_n=100):

        &#34;&#34;&#34;
        Manually sum mass spectrum over a scan range
        initial_scan_number: int
        final_scan_number: int
        auto_process: bool
            If true performs peak picking, and noise threshold calculation after creation of mass spectrum object 
        pd_method: bool
            If true uses pandas to align and sum data
            Else: Assumes data is aligned and sum each data point across all mass spectra
        Returns:
            MassSpecProfile    
        &#34;&#34;&#34;

        d_params = default_parameters(self.file_location)

        # assumes scans is full scan or reduced profile scan

        d_params[&#34;label&#34;] = Labels.thermo_profile

        if type(initial_scan_number) is list:
            d_params[&#34;polarity&#34;] = self.get_polarity_mode(initial_scan_number[0])

            scanrange = initial_scan_number
        else:
            d_params[&#34;polarity&#34;] = self.get_polarity_mode(initial_scan_number)

            if final_scan_number is None:
                final_scan_number = self._final_scan_number

            scanrange = range(initial_scan_number, final_scan_number + 1)

        if pd_method:

            def sort_sum_df(df):
                &#34;&#34;&#34;
                Nested function to sort dataframe and sum rows with exact matching indexes (m/z)
                &#34;&#34;&#34;
                df = df.sort_index()
                df = df.groupby(level=0).sum()
                return df

            # initialise empty Pandas series
            big_df = pd.Series(index=[], dtype=&#39;float64&#39;)

            for scan_number in tqdm(scanrange):
                scanStatistics = self.iRawDataPlus.GetScanStatsForScanNumber(scan_number)
                segmentedScan = self.iRawDataPlus.GetSegmentedScanFromScanNumber(scan_number, scanStatistics)

                tmp_df = pd.Series(index=list(segmentedScan.Positions),
                                   dtype=&#39;float64&#39;, data=list(segmentedScan.Intensities))
                big_df = big_df.append(tmp_df)

                # this allows you to merge/sum the values earlier, however it slows down a lot
                # limited benefit unless running into memory issues
                # for complex data it is necessary to stop the iterations getting too slow
                if scan_number % pd_merge_n == 0:
                    big_df = sort_sum_df(big_df)

            big_df = sort_sum_df(big_df)
            data_dict = {Labels.mz: list(big_df.index.values),
                         Labels.abundance: list(big_df.values),
                         }
        else:
            all_mz = dict()

            for scan_number in tqdm(scanrange):

                scanStatistics = self.iRawDataPlus.GetScanStatsForScanNumber(scan_number)

                segmentedScan = self.iRawDataPlus.GetSegmentedScanFromScanNumber(scan_number, scanStatistics)

                len_data = segmentedScan.Positions.Length

                for i in range(len_data):

                    mz = segmentedScan.Positions[i]
                    abundance = segmentedScan.Intensities[i]

                    if mz in all_mz:
                        all_mz[mz] = all_mz[mz] + abundance
                    else:
                        all_mz[mz] = abundance

            mz_all = []
            abun_all = []

            for mz in sorted(all_mz):
                mz_all.append(mz)
                abun_all.append(all_mz[mz])

            data_dict = {Labels.mz: mz_all,
                         Labels.abundance: abun_all,
                         }

        print(&#39;Summed. Now Processing.&#39;)

        mass_spec = MassSpecProfile(data_dict, d_params, auto_process=auto_process)

        return mass_spec

    def get_tic(self, plot=False):
        &#34;&#34;&#34;
        Reads the TIC values for each scan from the Thermo headers
        Returns a pandas dataframe of Scans, TICs, and Times
        (Optionally) plots the TIC chromatogram.
        &#34;&#34;&#34;
        first_scan = self._initial_scan_number
        final_scan = self._final_scan_number
        scanrange = range(first_scan, final_scan + 1)

        ms_tic = pd.DataFrame(index=scanrange, columns=[&#39;Time&#39;, &#39;TIC&#39;])
        for scan in scanrange:
            scanStatistics = self.iRawDataPlus.GetScanStatsForScanNumber(scan)
            ms_tic.loc[scan, &#39;Time&#39;] = scanStatistics.StartTime
            ms_tic.loc[scan, &#39;TIC&#39;] = scanStatistics.TIC

        if plot:
            import matplotlib.pyplot as plt  # maybe better in top of file?
            fig, ax = plt.subplots(figsize=(6, 3))
            ax.plot(ms_tic[&#39;Time&#39;], ms_tic[&#39;TIC&#39;], label=&#39;TIC&#39;)
            ax.set_xlabel(&#39;Time (min)&#39;)
            ax.set_ylabel(&#39;a.u.&#39;)
            plt.legend()
            # plt.show()
            return ms_tic, fig

        return ms_tic

    def get_best_scans_idx(self, stdevs=2, method=&#39;mean&#39;, plot=False):
        &#39;&#39;&#39;
        Method to determine the best scan indexes for selective co-addition
        Based on calculating the mean (default) of the TIC values
        and setting an upper limit above/below that within X standard deviations.
        Mean or median makes limited difference, it seems.
        Empirically, 1-2 stdevs enough to filter out the worst datapoints.
        Optionally, plot the TIC with horizontal lines for the standard dev cutoffs.
        &#39;&#39;&#39;
        tic = self.get_tic()

        if method == &#39;median&#39;:
            tic_median = tic[&#39;TIC&#39;].median()
        elif method == &#39;mean&#39;:
            tic_median = tic[&#39;TIC&#39;].mean()
        else:
            print(&#34;Method &#34; + str(method) + &#34; undefined&#34;)

        tic_std = tic[&#39;TIC&#39;].std()

        upperlimit = tic_median - (stdevs * tic_std)
        lowerlimit = tic_median + (stdevs * tic_std)

        tic_filtered = tic[(tic[&#39;TIC&#39;] &gt; upperlimit) &amp; (tic[&#39;TIC&#39;] &lt; lowerlimit)]
        scans = list(tic_filtered.index.values)

        if plot:
            import matplotlib.pyplot as plt
            fig, ax = plt.subplots(figsize=(8, 4))
            ax.plot(tic[&#39;Time&#39;], tic[&#39;TIC&#39;])
            ax.axhline(y=upperlimit, c=&#39;r&#39;)
            ax.axhline(y=lowerlimit, c=&#39;r&#39;)
            return fig, scans
        else:
            return scans</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.final_scan_number"><code class="name">var <span class="ident">final_scan_number</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def final_scan_number(self):
    return self._final_scan_number</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.initial_scan_number"><code class="name">var <span class="ident">initial_scan_number</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def initial_scan_number(self):
    return self._initial_scan_number</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.check_full_scan"><code class="name flex">
<span>def <span class="ident">check_full_scan</span></span>(<span>self, scan_number)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_full_scan(self, scan_number):
    # scan_filter.ScanMode 0 = FULL
    scan_filter = self.iRawDataPlus.GetFilterForScanNumber(scan_number)

    return scan_filter.ScanMode == MSOrderType.Ms</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_all_filters"><code class="name flex">
<span>def <span class="ident">get_all_filters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all scan filters.
This function is only supported for MS device controllers.
e.g.
['FTMS', '-', 'p', 'NSI', 'Full', 'ms', '[200.00-1000.00]']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_filters(self):
    &#34;&#34;&#34;
    Get all scan filters.
    This function is only supported for MS device controllers.
    e.g.  [&#39;FTMS&#39;, &#39;-&#39;, &#39;p&#39;, &#39;NSI&#39;, &#39;Full&#39;, &#39;ms&#39;, &#39;[200.00-1000.00]&#39;]
    &#34;&#34;&#34;
    scanrange = range(self._initial_scan_number, self._final_scan_number + 1)
    scanfiltersdic = {}
    scanfilterslist = []
    for scan_number in scanrange:
        scan_label = self.iRawDataPlus.GetScanEventStringForScanNumber(scan_number)
        scanfiltersdic[scan_number] = scan_label
        scanfilterslist.append(scan_label)
    scanfilterset = list(set(scanfilterslist))
    return scanfiltersdic, scanfilterset</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_average_mass_spectrum_by_scanlist"><code class="name flex">
<span>def <span class="ident">get_average_mass_spectrum_by_scanlist</span></span>(<span>self, scans_list, auto_process: bool = True, ppm_tolerance: float = 5.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Averages selected scans mass spectra using Thermo's AverageScans method
scans_list: list[int]
auto_process: bool
If true performs peak picking, and noise threshold calculation after creation of mass spectrum object</p>
<h2 id="returns">Returns</h2>
<p>MassSpecProfile</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_average_mass_spectrum_by_scanlist(self, scans_list, auto_process: bool = True, ppm_tolerance: float = 5.0):

    &#34;&#34;&#34;
    Averages selected scans mass spectra using Thermo&#39;s AverageScans method
    scans_list: list[int]
    auto_process: bool
        If true performs peak picking, and noise threshold calculation after creation of mass spectrum object
    Returns:
        MassSpecProfile
    &#34;&#34;&#34;

    d_params = self.set_metadata(scans_list=scans_list)

    # assumes scans is full scan or reduced profile scan

    scans = List[int]()
    for scan in scans_list:
        scans.Add(scan)

    # Create the mass options object that will be used when averaging the scans
    options = MassOptions()
    options.ToleranceUnits = ToleranceUnits.ppm
    options.Tolerance = ppm_tolerance

    # Get the scan filter for the first scan.  This scan filter will be used to located
    # scans within the given scan range of the same type

    averageScan = Extensions.AverageScans(self.iRawDataPlus, scans, options)

    len_data = averageScan.SegmentedScan.Positions.Length

    mz_list = list(averageScan.SegmentedScan.Positions)
    abund_list = list(averageScan.SegmentedScan.Intensities)

    data_dict = {Labels.mz: mz_list,
                 Labels.abundance: abund_list,
                 }

    mass_spec = MassSpecProfile(data_dict, d_params, auto_process=auto_process)

    return mass_spec</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_average_mass_spectrum_in_scan_range"><code class="name flex">
<span>def <span class="ident">get_average_mass_spectrum_in_scan_range</span></span>(<span>self, first_scan: int = None, last_scan: int = None, auto_process: bool = True, ppm_tolerance: float = 5.0, ms_type=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Averages mass spectra over a scan range using Thermo's AverageScansInScanRange method
first_scan: int
last_scan: int
auto_process: bool
If true performs peak picking, and noise threshold calculation after creation of mass spectrum object
ms_type: MSOrderType.MS
Type of mass spectrum scan, default for full scan acquisition
Returns:
MassSpecProfile</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_average_mass_spectrum_in_scan_range(self, first_scan: int = None, last_scan: int = None, auto_process: bool = True, ppm_tolerance: float = 5.0, ms_type=MSOrderType.Ms):

    &#34;&#34;&#34;
    Averages mass spectra over a scan range using Thermo&#39;s AverageScansInScanRange method
    first_scan: int
    last_scan: int
    auto_process: bool
        If true performs peak picking, and noise threshold calculation after creation of mass spectrum object
    ms_type: MSOrderType.MS
        Type of mass spectrum scan, default for full scan acquisition
     Returns:
        MassSpecProfile    
    &#34;&#34;&#34;

    firstScanNumber = self._initial_scan_number if first_scan is None else first_scan

    lastScanNumber = self._final_scan_number if last_scan is None else last_scan

    d_params = self.set_metadata(firstScanNumber=firstScanNumber, lastScanNumber=lastScanNumber)

    # Create the mass options object that will be used when averaging the scans
    options = MassOptions()

    options.ToleranceUnits = ToleranceUnits.ppm
    options.Tolerance = ppm_tolerance

    # Get the scan filter for the first scan.  This scan filter will be used to located
    # scans within the given scan range of the same type
    scanFilter = self.iRawDataPlus.GetFilterForScanNumber(firstScanNumber)

    # force it to only look for the MSType
    scanFilter.MSOrder = ms_type

    averageScan = Extensions.AverageScansInScanRange(self.iRawDataPlus, firstScanNumber, lastScanNumber, scanFilter, options)

    if averageScan:
        mz_list = list(averageScan.SegmentedScan.Positions)
        abund_list = list(averageScan.SegmentedScan.Intensities)

        data_dict = {Labels.mz: mz_list,
                     Labels.abundance: abund_list,
                     }

        mass_spec = MassSpecProfile(data_dict, d_params, auto_process=auto_process)

        return mass_spec
    else:
        raise Exception(&#39;no data found for the MSOrderType = {}&#39;.format(ms_type))</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_best_scans_idx"><code class="name flex">
<span>def <span class="ident">get_best_scans_idx</span></span>(<span>self, stdevs=2, method='mean', plot=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to determine the best scan indexes for selective co-addition
Based on calculating the mean (default) of the TIC values
and setting an upper limit above/below that within X standard deviations.
Mean or median makes limited difference, it seems.
Empirically, 1-2 stdevs enough to filter out the worst datapoints.
Optionally, plot the TIC with horizontal lines for the standard dev cutoffs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_scans_idx(self, stdevs=2, method=&#39;mean&#39;, plot=False):
    &#39;&#39;&#39;
    Method to determine the best scan indexes for selective co-addition
    Based on calculating the mean (default) of the TIC values
    and setting an upper limit above/below that within X standard deviations.
    Mean or median makes limited difference, it seems.
    Empirically, 1-2 stdevs enough to filter out the worst datapoints.
    Optionally, plot the TIC with horizontal lines for the standard dev cutoffs.
    &#39;&#39;&#39;
    tic = self.get_tic()

    if method == &#39;median&#39;:
        tic_median = tic[&#39;TIC&#39;].median()
    elif method == &#39;mean&#39;:
        tic_median = tic[&#39;TIC&#39;].mean()
    else:
        print(&#34;Method &#34; + str(method) + &#34; undefined&#34;)

    tic_std = tic[&#39;TIC&#39;].std()

    upperlimit = tic_median - (stdevs * tic_std)
    lowerlimit = tic_median + (stdevs * tic_std)

    tic_filtered = tic[(tic[&#39;TIC&#39;] &gt; upperlimit) &amp; (tic[&#39;TIC&#39;] &lt; lowerlimit)]
    scans = list(tic_filtered.index.values)

    if plot:
        import matplotlib.pyplot as plt
        fig, ax = plt.subplots(figsize=(8, 4))
        ax.plot(tic[&#39;Time&#39;], tic[&#39;TIC&#39;])
        ax.axhline(y=upperlimit, c=&#39;r&#39;)
        ax.axhline(y=lowerlimit, c=&#39;r&#39;)
        return fig, scans
    else:
        return scans</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self, scan, d_parameter, scan_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self, scan, d_parameter, scan_type):

    if scan_type == &#34;Centroid&#34;:

        centroidStream = self.iRawDataPlus.GetCentroidStream(scan, False)

        noise = list(centroidStream.Noises)

        baselines = list(centroidStream.Baselines)

        rp = list(centroidStream.Resolutions)

        magnitude = list(centroidStream.Intensities)

        mz = list(centroidStream.Masses)

        # charge = scans_labels[5]
        array_noise_std = (numpy.array(noise) - numpy.array(baselines)) / 3
        l_signal_to_noise = numpy.array(magnitude) / array_noise_std

        d_parameter[&#34;baselise_noise&#34;] = numpy.average(array_noise_std)

        d_parameter[&#34;baselise_noise_std&#34;] = numpy.std(array_noise_std)

        data_dict = {
            Labels.mz: mz,
            Labels.abundance: magnitude,
            Labels.rp: rp,
            Labels.s2n: l_signal_to_noise,
        }

    else:

        scanStatistics = self.iRawDataPlus.GetScanStatsForScanNumber(scan)

        profileStream = self.iRawDataPlus.GetSegmentedScanFromScanNumber(
            scan, scanStatistics)

        magnitude = list(profileStream.Intensities)

        mz = list(profileStream.Positions)

        data_dict = {
            Labels.mz: mz,
            Labels.abundance: magnitude,
        }

    return data_dict</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_filter_for_scan_num"><code class="name flex">
<span>def <span class="ident">get_filter_for_scan_num</span></span>(<span>self, scan_number)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the closest matching run time that corresponds to scan_number for the current
controller. This function is only supported for MS device controllers.
e.g.
['FTMS', '-', 'p', 'NSI', 'Full', 'ms', '[200.00-1000.00]']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_filter_for_scan_num(self, scan_number):
    &#34;&#34;&#34;
    Returns the closest matching run time that corresponds to scan_number for the current
    controller. This function is only supported for MS device controllers.
    e.g.  [&#39;FTMS&#39;, &#39;-&#39;, &#39;p&#39;, &#39;NSI&#39;, &#39;Full&#39;, &#39;ms&#39;, &#39;[200.00-1000.00]&#39;]
    &#34;&#34;&#34;
    scan_label = self.iRawDataPlus.GetScanEventStringForScanNumber(
        scan_number)

    return str(scan_label).split()</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_icr_transient_times"><code class="name flex">
<span>def <span class="ident">get_icr_transient_times</span></span>(<span>self, first_scan: int = None, last_scan: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list for transient time targets for all scans, or selected scans range
Resolving Power and Transient time targets based on 7T FT-ICR MS system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_icr_transient_times(self, first_scan: int = None, last_scan: int = None):
    &#39;&#39;&#39;
    Return a list for transient time targets for all scans, or selected scans range
    Resolving Power and Transient time targets based on 7T FT-ICR MS system
    &#39;&#39;&#39;

    res_trans_time = {&#34;50&#34;: 0.384,
                      &#34;100000&#34;: 0.768,
                      &#34;200000&#34;: 1.536,
                      &#34;400000&#34;: 3.072,
                      &#34;750000&#34;: 6.144,
                      &#34;1000000&#34;: 12.288
                      }

    firstScanNumber = self._initial_scan_number if first_scan is None else first_scan

    lastScanNumber = self._final_scan_number if last_scan is None else last_scan

    transient_time_list = []

    for scan in range(firstScanNumber, lastScanNumber):

        scan_header = self.get_scan_header(scan)

        rp_target = scan_header[&#39;FT Resolution:&#39;]

        transient_time = res_trans_time.get(rp_target)

        transient_time_list.append(transient_time)

        # print(transient_time, rp_target)

    return transient_time_list</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_polarity_mode"><code class="name flex">
<span>def <span class="ident">get_polarity_mode</span></span>(<span>self, scan_number)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_polarity_mode(self, scan_number):

    polarity_symbol = self.get_filter_for_scan_num(scan_number)[1]

    if polarity_symbol == &#34;+&#34;:

        return 1
        # return &#34;POSITIVE_ION_MODE&#34;

    elif polarity_symbol == &#34;-&#34;:

        return -1

    else:

        raise Exception(&#34;Polarity Mode Unknown, please set it manually&#34;)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_scan_header"><code class="name flex">
<span>def <span class="ident">get_scan_header</span></span>(<span>self, scan)</span>
</code></dt>
<dd>
<div class="desc"><p>Get full dictionary of scan header meta data, i.e. AGC status, ion injection time, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_scan_header(self, scan):
    &#39;&#39;&#39;
    Get full dictionary of scan header meta data, i.e. AGC status, ion injection time, etc.
    &#39;&#39;&#39;
    header = self.iRawDataPlus.GetTrailerExtraInformation(scan)
    header_dic = {}
    for i in numpy.arange(header.Length):
        header_dic.update({header.Labels[i]: header.Values[i]})
    return header_dic</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_summed_mass_spectrum"><code class="name flex">
<span>def <span class="ident">get_summed_mass_spectrum</span></span>(<span>self, initial_scan_number, final_scan_number=None, auto_process=True, pd_method=True, pd_merge_n=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Manually sum mass spectrum over a scan range
initial_scan_number: int
final_scan_number: int
auto_process: bool
If true performs peak picking, and noise threshold calculation after creation of mass spectrum object
pd_method: bool
If true uses pandas to align and sum data
Else: Assumes data is aligned and sum each data point across all mass spectra</p>
<h2 id="returns">Returns</h2>
<p>MassSpecProfile</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_summed_mass_spectrum(self, initial_scan_number, final_scan_number=None,
                             auto_process=True, pd_method=True, pd_merge_n=100):

    &#34;&#34;&#34;
    Manually sum mass spectrum over a scan range
    initial_scan_number: int
    final_scan_number: int
    auto_process: bool
        If true performs peak picking, and noise threshold calculation after creation of mass spectrum object 
    pd_method: bool
        If true uses pandas to align and sum data
        Else: Assumes data is aligned and sum each data point across all mass spectra
    Returns:
        MassSpecProfile    
    &#34;&#34;&#34;

    d_params = default_parameters(self.file_location)

    # assumes scans is full scan or reduced profile scan

    d_params[&#34;label&#34;] = Labels.thermo_profile

    if type(initial_scan_number) is list:
        d_params[&#34;polarity&#34;] = self.get_polarity_mode(initial_scan_number[0])

        scanrange = initial_scan_number
    else:
        d_params[&#34;polarity&#34;] = self.get_polarity_mode(initial_scan_number)

        if final_scan_number is None:
            final_scan_number = self._final_scan_number

        scanrange = range(initial_scan_number, final_scan_number + 1)

    if pd_method:

        def sort_sum_df(df):
            &#34;&#34;&#34;
            Nested function to sort dataframe and sum rows with exact matching indexes (m/z)
            &#34;&#34;&#34;
            df = df.sort_index()
            df = df.groupby(level=0).sum()
            return df

        # initialise empty Pandas series
        big_df = pd.Series(index=[], dtype=&#39;float64&#39;)

        for scan_number in tqdm(scanrange):
            scanStatistics = self.iRawDataPlus.GetScanStatsForScanNumber(scan_number)
            segmentedScan = self.iRawDataPlus.GetSegmentedScanFromScanNumber(scan_number, scanStatistics)

            tmp_df = pd.Series(index=list(segmentedScan.Positions),
                               dtype=&#39;float64&#39;, data=list(segmentedScan.Intensities))
            big_df = big_df.append(tmp_df)

            # this allows you to merge/sum the values earlier, however it slows down a lot
            # limited benefit unless running into memory issues
            # for complex data it is necessary to stop the iterations getting too slow
            if scan_number % pd_merge_n == 0:
                big_df = sort_sum_df(big_df)

        big_df = sort_sum_df(big_df)
        data_dict = {Labels.mz: list(big_df.index.values),
                     Labels.abundance: list(big_df.values),
                     }
    else:
        all_mz = dict()

        for scan_number in tqdm(scanrange):

            scanStatistics = self.iRawDataPlus.GetScanStatsForScanNumber(scan_number)

            segmentedScan = self.iRawDataPlus.GetSegmentedScanFromScanNumber(scan_number, scanStatistics)

            len_data = segmentedScan.Positions.Length

            for i in range(len_data):

                mz = segmentedScan.Positions[i]
                abundance = segmentedScan.Intensities[i]

                if mz in all_mz:
                    all_mz[mz] = all_mz[mz] + abundance
                else:
                    all_mz[mz] = abundance

        mz_all = []
        abun_all = []

        for mz in sorted(all_mz):
            mz_all.append(mz)
            abun_all.append(all_mz[mz])

        data_dict = {Labels.mz: mz_all,
                     Labels.abundance: abun_all,
                     }

    print(&#39;Summed. Now Processing.&#39;)

    mass_spec = MassSpecProfile(data_dict, d_params, auto_process=auto_process)

    return mass_spec</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_tic"><code class="name flex">
<span>def <span class="ident">get_tic</span></span>(<span>self, plot=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the TIC values for each scan from the Thermo headers
Returns a pandas dataframe of Scans, TICs, and Times
(Optionally) plots the TIC chromatogram.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tic(self, plot=False):
    &#34;&#34;&#34;
    Reads the TIC values for each scan from the Thermo headers
    Returns a pandas dataframe of Scans, TICs, and Times
    (Optionally) plots the TIC chromatogram.
    &#34;&#34;&#34;
    first_scan = self._initial_scan_number
    final_scan = self._final_scan_number
    scanrange = range(first_scan, final_scan + 1)

    ms_tic = pd.DataFrame(index=scanrange, columns=[&#39;Time&#39;, &#39;TIC&#39;])
    for scan in scanrange:
        scanStatistics = self.iRawDataPlus.GetScanStatsForScanNumber(scan)
        ms_tic.loc[scan, &#39;Time&#39;] = scanStatistics.StartTime
        ms_tic.loc[scan, &#39;TIC&#39;] = scanStatistics.TIC

    if plot:
        import matplotlib.pyplot as plt  # maybe better in top of file?
        fig, ax = plt.subplots(figsize=(6, 3))
        ax.plot(ms_tic[&#39;Time&#39;], ms_tic[&#39;TIC&#39;], label=&#39;TIC&#39;)
        ax.set_xlabel(&#39;Time (min)&#39;)
        ax.set_ylabel(&#39;a.u.&#39;)
        plt.legend()
        # plt.show()
        return ms_tic, fig

    return ms_tic</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.set_metadata"><code class="name flex">
<span>def <span class="ident">set_metadata</span></span>(<span>self, firstScanNumber=0, lastScanNumber=0, scans_list=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Collect metadata to be ingested in the mass spectrum object</p>
<p>scans_list: list[int] or false
lastScanNumber: int
firstScanNumber: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_metadata(self, firstScanNumber=0, lastScanNumber=0, scans_list=False):
    &#34;&#34;&#34;
    Collect metadata to be ingested in the mass spectrum object

    scans_list: list[int] or false
    lastScanNumber: int
    firstScanNumber: int
    &#34;&#34;&#34;

    d_params = default_parameters(self.file_location)

    # assumes scans is full scan or reduced profile scan

    d_params[&#34;label&#34;] = Labels.thermo_profile

    if scans_list:
        d_params[&#39;scan_number&#39;] = scans_list

        d_params[&#34;polarity&#34;] = self.get_polarity_mode(scans_list[0])

    else:

        d_params[&#39;scan_number&#39;] = &#34;{}-{}&#34;.format(firstScanNumber, lastScanNumber)

        d_params[&#34;polarity&#34;] = self.get_polarity_mode(firstScanNumber)

    d_params[&#39;analyzer&#39;] = self.iRawDataPlus.GetInstrumentData().Model

    d_params[&#39;instrument_label&#39;] = self.iRawDataPlus.GetInstrumentData().Name

    return d_params</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.mass_spectra.input" href="index.html">corems.mass_spectra.input</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader">ImportMassSpectraThermoMSFileReader</a></code></h4>
<ul class="">
<li><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.check_full_scan" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.check_full_scan">check_full_scan</a></code></li>
<li><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.final_scan_number" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.final_scan_number">final_scan_number</a></code></li>
<li><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_all_filters" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_all_filters">get_all_filters</a></code></li>
<li><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_average_mass_spectrum_by_scanlist" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_average_mass_spectrum_by_scanlist">get_average_mass_spectrum_by_scanlist</a></code></li>
<li><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_average_mass_spectrum_in_scan_range" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_average_mass_spectrum_in_scan_range">get_average_mass_spectrum_in_scan_range</a></code></li>
<li><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_best_scans_idx" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_best_scans_idx">get_best_scans_idx</a></code></li>
<li><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_data" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_data">get_data</a></code></li>
<li><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_filter_for_scan_num" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_filter_for_scan_num">get_filter_for_scan_num</a></code></li>
<li><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_icr_transient_times" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_icr_transient_times">get_icr_transient_times</a></code></li>
<li><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_polarity_mode" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_polarity_mode">get_polarity_mode</a></code></li>
<li><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_scan_header" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_scan_header">get_scan_header</a></code></li>
<li><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_summed_mass_spectrum" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_summed_mass_spectrum">get_summed_mass_spectrum</a></code></li>
<li><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_tic" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.get_tic">get_tic</a></code></li>
<li><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.initial_scan_number" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.initial_scan_number">initial_scan_number</a></code></li>
<li><code><a title="corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.set_metadata" href="#corems.mass_spectra.input.rawFileReader.ImportMassSpectraThermoMSFileReader.set_metadata">set_metadata</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>