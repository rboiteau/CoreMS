<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.mass_spectra.calc.SignalProcessing API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.mass_spectra.calc.SignalProcessing</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np

from pandas import Series, DataFrame

from scipy.signal import savgol_filter, boxcar
from scipy import interpolate
from matplotlib import pyplot as plt
from numpy import abs
from numpy import array, poly1d, polyfit

def peak_detector(tic, max_tic):

    dy = derivate(tic)

    indexes = np.where((np.hstack((dy, 0)) &lt; 0) &amp; (np.hstack((0, dy)) &gt; 0))[0]
    
    for index in indexes:
        
        start_index = find_minima(index, tic, right=False)
        final_index = find_minima(index, tic)

        yield (start_index, index, final_index)

def find_nearest_scan(data, nodes):

    array_data = array(nodes)

    scan_index = (abs(array_data - data)).argmin()

    return nodes[scan_index]

def peak_picking_first_derivative(domain, signal, max_height, max_prominence, max_signal, min_peak_datapoints,
                           signal_threshold=0.2, correct_baseline=True, plot_res=False):
    
    if correct_baseline:
        signal = signal - baseline_detector(signal, domain, max_height, max_prominence)

    domain = np.array(domain)
    signal = np.array(signal)

    # dy_signal = derivate(signal)

    # dydy = derivate(dy_signal)
    
    # where returns a tuple of indexes and data type and we only need  the indexes
    # right_indexes = np.where((np.hstack( (0, dy_signal)) &lt; neg_dy_threshold))[0]
    # left_indexes = np.where((np.hstack( (0, dy_signal)) &gt; pos_dy_threshold))[0]
  
    # dy_left_signal = derivate(left_indexes)  
    # dy_left_signal_zero_filled = np.hstack( (dy_left_signal,0))

    # start_peak = []

    # needs a more efficient way of doing that 
    # for index in range(1,len(dy_left_signal_zero_filled)-1):
    #    delta = dy_left_signal_zero_filled[index]
    #    delta_previous = dy_left_signal_zero_filled[index - 1]
    #    delta_next = dy_left_signal_zero_filled[index + 1]
    #    if delta == 1 and delta_previous != 1:
    #        start_peak.append(left_indexes[index]-1)
    # start_peak = array(start_peak)

    dy = derivate(signal)
    apex_indexes = np.where((np.hstack((dy, 0)) &lt; 0) &amp; (np.hstack((0, dy)) &gt; 0))[0]
    # min_indexes = np.where((np.hstack((dy, 0)) &gt; 0) &amp; (np.hstack((0, dy)) &lt; 0))[0]

    start_peak = []
    end_peak = []

    pos_dy_threshold = max(dy) * 0.0005
    neg_dy_threshold = min(dy) * 0.0005
    len_dy = len(dy)
    # take apex_index and move left to find start
    for index in apex_indexes:
        # catch for starting position
        if index == 0:
            index_start = index
        else:
            index_start = index - 1

        # catch for ending position
        if index == (len(dy) - 1):
            index_end = index
        else:
            index_end = index + 1

        # while dy[index_start-1] &gt; 0 and index_start != 0:
        while dy[index_start - 1] &gt; pos_dy_threshold and index_start &gt; 0:
            index_start = index_start - 1
        start_peak.append(index_start)

        # while dy[index_end] &lt; 0 and index_end != (len(dy) - 1):
        while dy[index_end] &lt; neg_dy_threshold and index_end != (len_dy - 1):
            index_end = index_end + 1
        end_peak.append(index_end)

    start_peak = array(start_peak)
    end_peak = array(end_peak)

    # left_index = []
    # right_index = []

    last_closest_right = 0

    for apex_index in apex_indexes:

        index_gt_apex = np.where(end_peak &gt;= apex_index)[0]
        index_lt_apex = np.where(start_peak &lt;= apex_index)[0]
        # index_gt_apex = np.where(min_indexes &gt;= apex_index)[0]
        # index_lt_apex = np.where(min_indexes &lt;= apex_index)[0]

        if not index_gt_apex.size == 0 and not index_lt_apex.size == 0:

            closest_right = find_nearest_scan(apex_index, end_peak[index_gt_apex])
            closest_left = find_nearest_scan(apex_index,  start_peak[index_lt_apex])
            # closest_right = find_nearest_scan(apex_index, min_indexes[index_gt_apex])
            # closest_left = find_nearest_scan(apex_index, min_indexes[index_lt_apex])

            x = [closest_left, closest_right]
            y = [signal[closest_left], signal[closest_right]]

            pol = poly1d(polyfit(x, y, 1))

            corrected_peak_height = signal[apex_index] - pol(apex_index)

            if (corrected_peak_height / max_signal) * 100 &gt; signal_threshold:

                if (closest_right - closest_left) &gt;= min_peak_datapoints:

                    if plot_res:

                        # plt.plot(domain[closest_left: closest_right+1], dydy[closest_left:closest_right+1], c=&#39;black&#39;)
                        plt.plot(domain[closest_left: closest_right+1], dy[closest_left:closest_right+1], c=&#39;red&#39;)
                        plt.plot(domain[[apex_index, apex_index]], [signal[apex_index], pol(apex_index)], c=&#39;red&#39;)
                        plt.plot(domain[start_peak], signal[start_peak], c=&#39;blue&#39;, linewidth=&#39;0&#39;, marker=&#34;^&#34;)
                        # plt.plot(domain[[closest_left,apex_index,closest_right]], signal[[closest_left,apex_index,closest_right]], c=&#39;blue&#39;, linewidth=&#39;0&#39;, marker=&#34;s&#34;)    
                        # plt.plot(domain[[closest_left,apex_index,closest_right]], pol([closest_left, apex_index, closest_right]), c=&#39;red&#39;)
                        plt.plot(domain[closest_left: closest_right+1], signal[closest_left:closest_right+1], c=&#39;black&#39;)
                        plt.title(str((corrected_peak_height/max_signal)*100))
                        
                        # plt.show()

                    # if not closest_right &lt;= apex_index:
                    #right_index.append(closest_right)
                    #print (closest_right, apex_index)

                    #left_index.append(closest_left)
                    #print (closest_left, apex_index)
                    #plt.show()
                    #if closest_left &lt; last_closest_right:
                    #    closest_left = last_closest_right
                        
                    yield (closest_left, apex_index, closest_right)
                    last_closest_right = closest_right
    
    #plt.plot(domain, dydy, c=&#39;black&#39;)
    #plt.plot(domain, np.hstack((0, dy)), c=&#39;green&#39;)
    #plt.plot(domain, [0 for i in range(len(domain))], c=&#39;blue&#39;)
    #plt.plot(domain[right_index], signal[right_index], c=&#39;blue&#39;, linewidth=&#39;0&#39;, marker=&#34;s&#34;)
    #plt.plot(domain[left_index], signal[left_index], c=&#39;yellow&#39;, linewidth=&#39;0&#39;, marker=&#34;^&#34;)
    #plt.plot(domain[apex_indexes], signal[apex_indexes], c=&#39;red&#39;, linewidth=&#39;0&#39;, marker=&#34;^&#34;)
    #plt.plot(domain[right_indexes], signal[right_indexes], c=&#39;green&#39;, linewidth=&#39;0&#39;, marker=&#34;^&#34;)
    #plt.show()

def find_minima(index, tic, right=True):
            
    j = index
    #apex_abundance = tic[index]
    tic_len = len(tic)

    if right: minima = tic[j] &gt;= tic[j+1]
    else: minima = tic[j] &gt;= tic[j-1]

    while minima:
        
        if j == 1 or j == tic_len -2:
            break
        
        if right: 
            j += 1

            minima = tic[j] &gt;= tic[j+1]

        else: 
            j -= 1
            minima = tic[j] &gt;= tic[j-1]

    if right: return j
    else: return j

def derivate(data_array):

    data_array = np.array(data_array)

    dy = data_array[1:] - data_array[:-1]

    &#39;&#39;&#39;replaces nan for infinity&#39;&#39;&#39;
    indices_nan = np.where(np.isnan(data_array))[0]

    if indices_nan.size:

        data_array[indices_nan] = np.inf
        dy[np.where(np.isnan(dy))[0]] = np.inf

    return dy

def minima_detector(tic, max_tic, peak_height_max_percent, peak_max_prominence_percent):

    peak_height_diff = lambda hi, li : ((tic[hi] - tic[li]) / max_tic )*100

    for start_index, index, final_index in peak_detector(tic, max_tic):

        # abundance max threshold    
        if (tic[index] / max_tic) * 100 &lt; peak_height_max_percent:

            # calculates prominence and filter   
            if peak_height_diff(index, start_index) and peak_height_diff(index, final_index) &lt; peak_max_prominence_percent:
                
                    yield from (start_index, final_index)

def baseline_detector(tic, rt, peak_height_max_percent, peak_max_prominence_percent, do_interpolation=True):

    rt = np.array(rt)

    max_tic = max(tic)

    indexes = sorted(list(set(i for i in minima_detector(tic, max_tic, peak_height_max_percent, peak_max_prominence_percent))))

    y = -tic

    x1 = rt[indexes]

    y1 = y[indexes]

    if len(x1) &lt;= 5:
        return tic

    if not do_interpolation:
  
        y0 = np.zeros(tic.shape)
        y0[indexes] = y[indexes]

        return y0

    else:

        f1 = interpolate.interp1d(x1, y1, kind=&#39;quadratic&#39;,fill_value=&#34;extrapolate&#34;)

        ynew1 = f1(list(rt))

        # from matplotlib import pyplot as plt   
        # if self.deconv_rt_list and  self.deconv_mz == 51:

        #   plt.plot(rt, tic-(-1* ynew1), color=&#39;green&#39;)

        # plt.plot(rt, -1* ynew1, c=&#39;black&#39;)

        # s = self.smooth(s, 10, &#39;blackman&#39;)

        # plt.plot(self.retention_time, -s)

        # plt.show()

        return -1 * ynew1

def peak_detector_generator(tic, stds, method, rt, max_height, min_height, max_prominence, min_datapoints):

    max_tic = max(tic)

    if method == &#39;manual_relative_abundance&#39;:

        tic = tic - baseline_detector(tic, rt, max_height, max_prominence)

        norm_tic = (tic / max_tic) * 100

        remove_indexes = np.where(norm_tic &lt; min_height)[0]

        # if self.deconv_rt_list and  self.deconv_mz == 51:
        #    plt.plot(self.deconv_rt_list, tic, label=self.deconv_mz)

    elif method == &#39;auto_relative_abundance&#39;:

        tic = tic - baseline_detector(tic, rt, max_height, max_prominence)

        baseline = baseline_detector(tic, rt, max_height, max_prominence)

        peak_detect_threshold = ((np.nanmean(baseline) + (stds * np.std(baseline))))

        remove_indexes = np.where(tic &lt; peak_detect_threshold)[0]

    elif method == &#39;second_derivative&#39;:

        remove_indexes = second_derivative_threshold(tic, stds, rt, max_height, max_prominence)

    else:

        NotImplemented(method)

    peak_height_diff = lambda hi, li : ((tic[hi] - tic[li]) / max_tic )*100
    
    dy = derivate(tic)

    include_indexes = np.where((np.hstack((dy, 0)) &lt; 0) &amp; (np.hstack((0, dy)) &gt; 0))[0]

    final_indexes = sorted(set(include_indexes)-set(remove_indexes))

    #from matplotlib import pyplot as plt   
    
    #plt.plot(self.retention_time, tic, color=&#39;black&#39;)
    #plt.scatter(self.retention_time[remove_indexes], tic[remove_indexes], color=&#39;red&#39;)
    #plt.scatter(self.retention_time[include_indexes], tic[include_indexes], color=&#39;blue&#39;)
    #plt.scatter(self.retention_time[final_indexes], tic[final_indexes], color=&#39;blue&#39;)
    
    #plt.show()

    for index in final_indexes:
            
        start_index = find_minima(index, tic, right=False)
        final_index = find_minima(index, tic)
        
        if final_index-start_index &gt; min_datapoints:

            #if min( peak_height_diff(index,start_index), peak_height_diff(index,final_index) )&gt; self.chromatogram_settings.peak_min_prominence_percent :   
                
                yield (start_index, index, final_index)

def smooth_signal(x, window_len, window, pol_order, implemented_smooth_method):
    
    &#34;&#34;&#34;smooth the data using a window with requested size.

    This method is based on the convolution of a scaled window with the signal.
    The signal is prepared by introducing reflected copies of the signal 
    (with the window size) in both ends so that transient parts are minimized
    in the begining and end part of the output signal.

    output:
        the smoothed signal
        
    see also: 

    numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve
    scipy.signal.savgol_filter

    &#34;&#34;&#34;
    x= np.array(x)

    if x.ndim != 1:
        raise ValueError(&#34;smooth only accepts 1 dimension arrays.&#34;)

    if x.size &lt; window_len:
        raise ValueError(&#34;Input array needs to be bigger than window size&#34;)

    #if window_len &lt; 3:
    #    return x

    if not window in implemented_smooth_method:
        raise ValueError(&#34;Window method should be &#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;&#34;)

    s = np.r_[x[window_len - 1:0:-1], x, x[-1:-window_len:-1]]

    if window == &#39;savgol&#39;:
        
        return savgol_filter(x, window_len, pol_order)


    elif window == &#39;boxcar&#39;:  # moving average
        
        w = boxcar(window_len)
        
        y = np.convolve(w, s, mode=&#39;valid&#39;)

        
    elif window == &#39;flat&#39;:  # moving average
        
        w = np.ones(window_len, &#39;d&#39;)

        y = np.convolve(w / w.sum(), s, mode=&#39;valid&#39;)
        
    else:
        
        w = eval( window + &#39;(window_len)&#39;)

        y = np.convolve(w / w.sum(), s, mode=&#39;valid&#39;)

    return y[int(window_len / 2 - 1):int(-window_len / 2)]

def second_derivative_threshold(tic, stds, rt, peak_height_max_percent, peak_max_prominence_percent):
          
    dy = derivate(tic)
    
    dydy = derivate(dy)
    dydy = np.hstack((dydy, 0))
    dydy = np.hstack((0, dydy))

    baseline = baseline_detector(dydy, rt, peak_height_max_percent, peak_max_prominence_percent, do_interpolation=False)
    
    threshold_median = np.median(baseline) - (stds * np.std(baseline))
    
    remove_indexes = np.where(dydy &gt; threshold_median)[0]
    
    return remove_indexes
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="corems.mass_spectra.calc.SignalProcessing.baseline_detector"><code class="name flex">
<span>def <span class="ident">baseline_detector</span></span>(<span>tic, rt, peak_height_max_percent, peak_max_prominence_percent, do_interpolation=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def baseline_detector(tic, rt, peak_height_max_percent, peak_max_prominence_percent, do_interpolation=True):

    rt = np.array(rt)

    max_tic = max(tic)

    indexes = sorted(list(set(i for i in minima_detector(tic, max_tic, peak_height_max_percent, peak_max_prominence_percent))))

    y = -tic

    x1 = rt[indexes]

    y1 = y[indexes]

    if len(x1) &lt;= 5:
        return tic

    if not do_interpolation:
  
        y0 = np.zeros(tic.shape)
        y0[indexes] = y[indexes]

        return y0

    else:

        f1 = interpolate.interp1d(x1, y1, kind=&#39;quadratic&#39;,fill_value=&#34;extrapolate&#34;)

        ynew1 = f1(list(rt))

        # from matplotlib import pyplot as plt   
        # if self.deconv_rt_list and  self.deconv_mz == 51:

        #   plt.plot(rt, tic-(-1* ynew1), color=&#39;green&#39;)

        # plt.plot(rt, -1* ynew1, c=&#39;black&#39;)

        # s = self.smooth(s, 10, &#39;blackman&#39;)

        # plt.plot(self.retention_time, -s)

        # plt.show()

        return -1 * ynew1</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.SignalProcessing.derivate"><code class="name flex">
<span>def <span class="ident">derivate</span></span>(<span>data_array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def derivate(data_array):

    data_array = np.array(data_array)

    dy = data_array[1:] - data_array[:-1]

    &#39;&#39;&#39;replaces nan for infinity&#39;&#39;&#39;
    indices_nan = np.where(np.isnan(data_array))[0]

    if indices_nan.size:

        data_array[indices_nan] = np.inf
        dy[np.where(np.isnan(dy))[0]] = np.inf

    return dy</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.SignalProcessing.find_minima"><code class="name flex">
<span>def <span class="ident">find_minima</span></span>(<span>index, tic, right=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_minima(index, tic, right=True):
            
    j = index
    #apex_abundance = tic[index]
    tic_len = len(tic)

    if right: minima = tic[j] &gt;= tic[j+1]
    else: minima = tic[j] &gt;= tic[j-1]

    while minima:
        
        if j == 1 or j == tic_len -2:
            break
        
        if right: 
            j += 1

            minima = tic[j] &gt;= tic[j+1]

        else: 
            j -= 1
            minima = tic[j] &gt;= tic[j-1]

    if right: return j
    else: return j</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.SignalProcessing.find_nearest_scan"><code class="name flex">
<span>def <span class="ident">find_nearest_scan</span></span>(<span>data, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_nearest_scan(data, nodes):

    array_data = array(nodes)

    scan_index = (abs(array_data - data)).argmin()

    return nodes[scan_index]</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.SignalProcessing.minima_detector"><code class="name flex">
<span>def <span class="ident">minima_detector</span></span>(<span>tic, max_tic, peak_height_max_percent, peak_max_prominence_percent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minima_detector(tic, max_tic, peak_height_max_percent, peak_max_prominence_percent):

    peak_height_diff = lambda hi, li : ((tic[hi] - tic[li]) / max_tic )*100

    for start_index, index, final_index in peak_detector(tic, max_tic):

        # abundance max threshold    
        if (tic[index] / max_tic) * 100 &lt; peak_height_max_percent:

            # calculates prominence and filter   
            if peak_height_diff(index, start_index) and peak_height_diff(index, final_index) &lt; peak_max_prominence_percent:
                
                    yield from (start_index, final_index)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.SignalProcessing.peak_detector"><code class="name flex">
<span>def <span class="ident">peak_detector</span></span>(<span>tic, max_tic)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak_detector(tic, max_tic):

    dy = derivate(tic)

    indexes = np.where((np.hstack((dy, 0)) &lt; 0) &amp; (np.hstack((0, dy)) &gt; 0))[0]
    
    for index in indexes:
        
        start_index = find_minima(index, tic, right=False)
        final_index = find_minima(index, tic)

        yield (start_index, index, final_index)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.SignalProcessing.peak_detector_generator"><code class="name flex">
<span>def <span class="ident">peak_detector_generator</span></span>(<span>tic, stds, method, rt, max_height, min_height, max_prominence, min_datapoints)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak_detector_generator(tic, stds, method, rt, max_height, min_height, max_prominence, min_datapoints):

    max_tic = max(tic)

    if method == &#39;manual_relative_abundance&#39;:

        tic = tic - baseline_detector(tic, rt, max_height, max_prominence)

        norm_tic = (tic / max_tic) * 100

        remove_indexes = np.where(norm_tic &lt; min_height)[0]

        # if self.deconv_rt_list and  self.deconv_mz == 51:
        #    plt.plot(self.deconv_rt_list, tic, label=self.deconv_mz)

    elif method == &#39;auto_relative_abundance&#39;:

        tic = tic - baseline_detector(tic, rt, max_height, max_prominence)

        baseline = baseline_detector(tic, rt, max_height, max_prominence)

        peak_detect_threshold = ((np.nanmean(baseline) + (stds * np.std(baseline))))

        remove_indexes = np.where(tic &lt; peak_detect_threshold)[0]

    elif method == &#39;second_derivative&#39;:

        remove_indexes = second_derivative_threshold(tic, stds, rt, max_height, max_prominence)

    else:

        NotImplemented(method)

    peak_height_diff = lambda hi, li : ((tic[hi] - tic[li]) / max_tic )*100
    
    dy = derivate(tic)

    include_indexes = np.where((np.hstack((dy, 0)) &lt; 0) &amp; (np.hstack((0, dy)) &gt; 0))[0]

    final_indexes = sorted(set(include_indexes)-set(remove_indexes))

    #from matplotlib import pyplot as plt   
    
    #plt.plot(self.retention_time, tic, color=&#39;black&#39;)
    #plt.scatter(self.retention_time[remove_indexes], tic[remove_indexes], color=&#39;red&#39;)
    #plt.scatter(self.retention_time[include_indexes], tic[include_indexes], color=&#39;blue&#39;)
    #plt.scatter(self.retention_time[final_indexes], tic[final_indexes], color=&#39;blue&#39;)
    
    #plt.show()

    for index in final_indexes:
            
        start_index = find_minima(index, tic, right=False)
        final_index = find_minima(index, tic)
        
        if final_index-start_index &gt; min_datapoints:

            #if min( peak_height_diff(index,start_index), peak_height_diff(index,final_index) )&gt; self.chromatogram_settings.peak_min_prominence_percent :   
                
                yield (start_index, index, final_index)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.SignalProcessing.peak_picking_first_derivative"><code class="name flex">
<span>def <span class="ident">peak_picking_first_derivative</span></span>(<span>domain, signal, max_height, max_prominence, max_signal, min_peak_datapoints, signal_threshold=0.2, correct_baseline=True, plot_res=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak_picking_first_derivative(domain, signal, max_height, max_prominence, max_signal, min_peak_datapoints,
                           signal_threshold=0.2, correct_baseline=True, plot_res=False):
    
    if correct_baseline:
        signal = signal - baseline_detector(signal, domain, max_height, max_prominence)

    domain = np.array(domain)
    signal = np.array(signal)

    # dy_signal = derivate(signal)

    # dydy = derivate(dy_signal)
    
    # where returns a tuple of indexes and data type and we only need  the indexes
    # right_indexes = np.where((np.hstack( (0, dy_signal)) &lt; neg_dy_threshold))[0]
    # left_indexes = np.where((np.hstack( (0, dy_signal)) &gt; pos_dy_threshold))[0]
  
    # dy_left_signal = derivate(left_indexes)  
    # dy_left_signal_zero_filled = np.hstack( (dy_left_signal,0))

    # start_peak = []

    # needs a more efficient way of doing that 
    # for index in range(1,len(dy_left_signal_zero_filled)-1):
    #    delta = dy_left_signal_zero_filled[index]
    #    delta_previous = dy_left_signal_zero_filled[index - 1]
    #    delta_next = dy_left_signal_zero_filled[index + 1]
    #    if delta == 1 and delta_previous != 1:
    #        start_peak.append(left_indexes[index]-1)
    # start_peak = array(start_peak)

    dy = derivate(signal)
    apex_indexes = np.where((np.hstack((dy, 0)) &lt; 0) &amp; (np.hstack((0, dy)) &gt; 0))[0]
    # min_indexes = np.where((np.hstack((dy, 0)) &gt; 0) &amp; (np.hstack((0, dy)) &lt; 0))[0]

    start_peak = []
    end_peak = []

    pos_dy_threshold = max(dy) * 0.0005
    neg_dy_threshold = min(dy) * 0.0005
    len_dy = len(dy)
    # take apex_index and move left to find start
    for index in apex_indexes:
        # catch for starting position
        if index == 0:
            index_start = index
        else:
            index_start = index - 1

        # catch for ending position
        if index == (len(dy) - 1):
            index_end = index
        else:
            index_end = index + 1

        # while dy[index_start-1] &gt; 0 and index_start != 0:
        while dy[index_start - 1] &gt; pos_dy_threshold and index_start &gt; 0:
            index_start = index_start - 1
        start_peak.append(index_start)

        # while dy[index_end] &lt; 0 and index_end != (len(dy) - 1):
        while dy[index_end] &lt; neg_dy_threshold and index_end != (len_dy - 1):
            index_end = index_end + 1
        end_peak.append(index_end)

    start_peak = array(start_peak)
    end_peak = array(end_peak)

    # left_index = []
    # right_index = []

    last_closest_right = 0

    for apex_index in apex_indexes:

        index_gt_apex = np.where(end_peak &gt;= apex_index)[0]
        index_lt_apex = np.where(start_peak &lt;= apex_index)[0]
        # index_gt_apex = np.where(min_indexes &gt;= apex_index)[0]
        # index_lt_apex = np.where(min_indexes &lt;= apex_index)[0]

        if not index_gt_apex.size == 0 and not index_lt_apex.size == 0:

            closest_right = find_nearest_scan(apex_index, end_peak[index_gt_apex])
            closest_left = find_nearest_scan(apex_index,  start_peak[index_lt_apex])
            # closest_right = find_nearest_scan(apex_index, min_indexes[index_gt_apex])
            # closest_left = find_nearest_scan(apex_index, min_indexes[index_lt_apex])

            x = [closest_left, closest_right]
            y = [signal[closest_left], signal[closest_right]]

            pol = poly1d(polyfit(x, y, 1))

            corrected_peak_height = signal[apex_index] - pol(apex_index)

            if (corrected_peak_height / max_signal) * 100 &gt; signal_threshold:

                if (closest_right - closest_left) &gt;= min_peak_datapoints:

                    if plot_res:

                        # plt.plot(domain[closest_left: closest_right+1], dydy[closest_left:closest_right+1], c=&#39;black&#39;)
                        plt.plot(domain[closest_left: closest_right+1], dy[closest_left:closest_right+1], c=&#39;red&#39;)
                        plt.plot(domain[[apex_index, apex_index]], [signal[apex_index], pol(apex_index)], c=&#39;red&#39;)
                        plt.plot(domain[start_peak], signal[start_peak], c=&#39;blue&#39;, linewidth=&#39;0&#39;, marker=&#34;^&#34;)
                        # plt.plot(domain[[closest_left,apex_index,closest_right]], signal[[closest_left,apex_index,closest_right]], c=&#39;blue&#39;, linewidth=&#39;0&#39;, marker=&#34;s&#34;)    
                        # plt.plot(domain[[closest_left,apex_index,closest_right]], pol([closest_left, apex_index, closest_right]), c=&#39;red&#39;)
                        plt.plot(domain[closest_left: closest_right+1], signal[closest_left:closest_right+1], c=&#39;black&#39;)
                        plt.title(str((corrected_peak_height/max_signal)*100))
                        
                        # plt.show()

                    # if not closest_right &lt;= apex_index:
                    #right_index.append(closest_right)
                    #print (closest_right, apex_index)

                    #left_index.append(closest_left)
                    #print (closest_left, apex_index)
                    #plt.show()
                    #if closest_left &lt; last_closest_right:
                    #    closest_left = last_closest_right
                        
                    yield (closest_left, apex_index, closest_right)
                    last_closest_right = closest_right</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.SignalProcessing.second_derivative_threshold"><code class="name flex">
<span>def <span class="ident">second_derivative_threshold</span></span>(<span>tic, stds, rt, peak_height_max_percent, peak_max_prominence_percent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def second_derivative_threshold(tic, stds, rt, peak_height_max_percent, peak_max_prominence_percent):
          
    dy = derivate(tic)
    
    dydy = derivate(dy)
    dydy = np.hstack((dydy, 0))
    dydy = np.hstack((0, dydy))

    baseline = baseline_detector(dydy, rt, peak_height_max_percent, peak_max_prominence_percent, do_interpolation=False)
    
    threshold_median = np.median(baseline) - (stds * np.std(baseline))
    
    remove_indexes = np.where(dydy &gt; threshold_median)[0]
    
    return remove_indexes</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.SignalProcessing.smooth_signal"><code class="name flex">
<span>def <span class="ident">smooth_signal</span></span>(<span>x, window_len, window, pol_order, implemented_smooth_method)</span>
</code></dt>
<dd>
<div class="desc"><p>smooth the data using a window with requested size.</p>
<p>This method is based on the convolution of a scaled window with the signal.
The signal is prepared by introducing reflected copies of the signal
(with the window size) in both ends so that transient parts are minimized
in the begining and end part of the output signal.</p>
<p>output:
the smoothed signal</p>
<p>see also: </p>
<p>numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve
scipy.signal.savgol_filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smooth_signal(x, window_len, window, pol_order, implemented_smooth_method):
    
    &#34;&#34;&#34;smooth the data using a window with requested size.

    This method is based on the convolution of a scaled window with the signal.
    The signal is prepared by introducing reflected copies of the signal 
    (with the window size) in both ends so that transient parts are minimized
    in the begining and end part of the output signal.

    output:
        the smoothed signal
        
    see also: 

    numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve
    scipy.signal.savgol_filter

    &#34;&#34;&#34;
    x= np.array(x)

    if x.ndim != 1:
        raise ValueError(&#34;smooth only accepts 1 dimension arrays.&#34;)

    if x.size &lt; window_len:
        raise ValueError(&#34;Input array needs to be bigger than window size&#34;)

    #if window_len &lt; 3:
    #    return x

    if not window in implemented_smooth_method:
        raise ValueError(&#34;Window method should be &#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;&#34;)

    s = np.r_[x[window_len - 1:0:-1], x, x[-1:-window_len:-1]]

    if window == &#39;savgol&#39;:
        
        return savgol_filter(x, window_len, pol_order)


    elif window == &#39;boxcar&#39;:  # moving average
        
        w = boxcar(window_len)
        
        y = np.convolve(w, s, mode=&#39;valid&#39;)

        
    elif window == &#39;flat&#39;:  # moving average
        
        w = np.ones(window_len, &#39;d&#39;)

        y = np.convolve(w / w.sum(), s, mode=&#39;valid&#39;)
        
    else:
        
        w = eval( window + &#39;(window_len)&#39;)

        y = np.convolve(w / w.sum(), s, mode=&#39;valid&#39;)

    return y[int(window_len / 2 - 1):int(-window_len / 2)]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.mass_spectra.calc" href="index.html">corems.mass_spectra.calc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="corems.mass_spectra.calc.SignalProcessing.baseline_detector" href="#corems.mass_spectra.calc.SignalProcessing.baseline_detector">baseline_detector</a></code></li>
<li><code><a title="corems.mass_spectra.calc.SignalProcessing.derivate" href="#corems.mass_spectra.calc.SignalProcessing.derivate">derivate</a></code></li>
<li><code><a title="corems.mass_spectra.calc.SignalProcessing.find_minima" href="#corems.mass_spectra.calc.SignalProcessing.find_minima">find_minima</a></code></li>
<li><code><a title="corems.mass_spectra.calc.SignalProcessing.find_nearest_scan" href="#corems.mass_spectra.calc.SignalProcessing.find_nearest_scan">find_nearest_scan</a></code></li>
<li><code><a title="corems.mass_spectra.calc.SignalProcessing.minima_detector" href="#corems.mass_spectra.calc.SignalProcessing.minima_detector">minima_detector</a></code></li>
<li><code><a title="corems.mass_spectra.calc.SignalProcessing.peak_detector" href="#corems.mass_spectra.calc.SignalProcessing.peak_detector">peak_detector</a></code></li>
<li><code><a title="corems.mass_spectra.calc.SignalProcessing.peak_detector_generator" href="#corems.mass_spectra.calc.SignalProcessing.peak_detector_generator">peak_detector_generator</a></code></li>
<li><code><a title="corems.mass_spectra.calc.SignalProcessing.peak_picking_first_derivative" href="#corems.mass_spectra.calc.SignalProcessing.peak_picking_first_derivative">peak_picking_first_derivative</a></code></li>
<li><code><a title="corems.mass_spectra.calc.SignalProcessing.second_derivative_threshold" href="#corems.mass_spectra.calc.SignalProcessing.second_derivative_threshold">second_derivative_threshold</a></code></li>
<li><code><a title="corems.mass_spectra.calc.SignalProcessing.smooth_signal" href="#corems.mass_spectra.calc.SignalProcessing.smooth_signal">smooth_signal</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>