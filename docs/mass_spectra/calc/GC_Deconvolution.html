<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.mass_spectra.calc.GC_Deconvolution API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.mass_spectra.calc.GC_Deconvolution</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from matplotlib import pyplot as plt
import numpy as np

from corems.encapsulation.constant import Labels
from corems.encapsulation.factory.parameters import default_parameters
from corems.mass_spectrum.factory.MassSpectrumClasses import MassSpecCentroidLowRes
from corems.chroma_peak.factory.ChromaPeakClasses import GCPeakDeconvolved
from corems.mass_spectra.calc import SignalProcessing as sp

class MassDeconvolution:

    def run_deconvolution(self, plot_res=False):

        eic_dict = self.ion_extracted_chroma(self._ms)

        peaks_entity_data = self.find_peaks_entity(eic_dict)

        &#39;&#39;&#39; select model peaks, create Mass Spectrum objs, GCPeak objs, store results in GC_Class gcpeaks obj&#39;&#39;&#39;
        self.deconvolution(peaks_entity_data, plot_res)

    def centroid_detector(self, tic, rt):
        &#39;&#39;&#39; this function has been replaced with sp.peak_picking_first_derivative
            and it not used
        &#39;&#39;&#39;
        noise_std = self.chromatogram_settings.std_noise_threshold

        method = self.chromatogram_settings.noise_threshold_method

        &#39;&#39;&#39; peak picking&#39;&#39;&#39;
        min_height = self.chromatogram_settings.peak_height_min_percent
        min_datapoints = self.chromatogram_settings.min_peak_datapoints

        &#39;&#39;&#39; baseline detection&#39;&#39;&#39;
        max_prominence = self.chromatogram_settings.peak_max_prominence_percent
        max_height = self.chromatogram_settings.peak_height_max_percent

        peak_indexes_generator = sp.peak_detector_generator(tic, noise_std, method, rt, max_height, min_height, max_prominence, min_datapoints)

        return peak_indexes_generator

    def ion_extracted_chroma(self, mass_spectra_obj):

        eic_dict = {}

        for scan_number, ms_obj in mass_spectra_obj.items():

            mz_list = ms_obj.mz_exp
            abundance_list = ms_obj.abundance
            # add list of scan numbers
            for index, mz in enumerate(mz_list):

                # dict of mz and tuple (mass spectrum abundances index, and scan number)
                if mz not in eic_dict.keys():

                    eic_dict[mz] = [[abundance_list[index]], [ms_obj.rt] ]

                else:

                    eic_dict[mz][0].append(ms_obj.abundance[index])
                    eic_dict[mz][1].append(ms_obj.rt)

        return eic_dict

    def hc(self, X, Y, max_rt_distance=0.025):

        from scipy.cluster.hierarchy import dendrogram, linkage
        from scipy.cluster.hierarchy import fcluster
        # from matplotlib import pyplot as plt

        Z = linkage(np.reshape(X, (len(X), 1)), method=&#34;ward&#34;)
        # Z = linkage(X, method  = &#34;ward&#34;)

        max_d = max_rt_distance
        distance_clusters = fcluster(Z, max_d, criterion=&#39;distance&#39;)
        # print(&#34;distance&#34;)
        # print(distance_clusters)

        # inconsistency_cluster = fcluster(Z, 2, depth=2)
        # max_cluster = fcluster(Z, 2, criterion=&#39;maxclust&#39;)

        grouped_rt = {}

        for index_obj, group in enumerate(distance_clusters):

            if group not in grouped_rt.keys():
                grouped_rt[group] = [X[index_obj]]
            else:
                grouped_rt[group].append(X[index_obj])

        # print(distance_clusters, grouped_rt)
        return grouped_rt      

        # plt.figure(figsize=(10, 8))
        # plt.scatter(X, Y, c=distance_clusters, cmap=&#39;prism&#39;)  # plot points with cluster dependent colors
        # plt.show()
        # labelList = range(int(min(X)), int(max(X)))

        # plt.figure(figsize=(10, 7))
        # dendrogram(Z,
        #            orientation=&#39;top&#39;,
        #            distance_sort=&#39;descending&#39;,
        #            show_leaf_counts=True)
        # plt.show()
        # print(Z)

    def find_peaks_entity(self, eic_dict):

        &#39;&#39;&#39; combine eic with mathing rt apexes&#39;&#39;&#39;
        max_prominence = self.chromatogram_settings.peak_max_prominence_percent

        max_height = self.chromatogram_settings.peak_height_max_percent

        signal_threshold = self.chromatogram_settings.eic_signal_threshold

        min_peak_datapoints = self.chromatogram_settings.min_peak_datapoints

        correct_baseline = False
        peaks_entity_data = {}

        max_eic = 0
        for mz, eic_scan_index_rt in eic_dict.items():

            ind_max_eic = max(eic_scan_index_rt[0])
            max_eic = ind_max_eic if ind_max_eic &gt; max_eic else max_eic

        for mz, eic_scan_index_rt in eic_dict.items():

            eic = eic_scan_index_rt[0]
            rt_list = eic_scan_index_rt[1]

            if len(eic) &gt;= min_peak_datapoints:

                smooth_eic = self.smooth_tic(eic)

                include_indexes = sp.peak_picking_first_derivative(rt_list, smooth_eic, max_height, max_prominence, max_eic, min_peak_datapoints,
                                                                   signal_threshold=signal_threshold, correct_baseline=correct_baseline)

                for initial_scan, apex_scan, final_scan in include_indexes:

                    rt_corrected_therm = self.quadratic_interpolation(rt_list, smooth_eic, apex_scan)

                    ref_apex_rt = round(rt_list[apex_scan] + rt_corrected_therm, 4)

                    apex_rt = rt_list[apex_scan]
                    # apex_abundance = smooth_eic[apex_scan]

                    # maximum_tic = apex_abundance if apex_abundance &gt; maximum_tic else maximum_tic

                    for scan_index in range(initial_scan, final_scan):

                        peak_rt = rt_list[scan_index]
                        peak_abundance = smooth_eic[scan_index]

                        if peak_abundance &gt; 0:

                            dict_data = {peak_rt: {&#39;mz&#39;: [mz],
                                                    &#39;abundance&#39;: [peak_abundance],
                                                    &#39;scan_number&#39;: [scan_index]},
                                                    &#39;ref_apex_rt&#39;: ref_apex_rt
                                                    }

                            if apex_rt not in peaks_entity_data.keys():

                                peaks_entity_data[apex_rt] = dict_data

                            else:

                                if peak_rt not in peaks_entity_data[apex_rt].keys():

                                    peaks_entity_data[apex_rt][peak_rt] = dict_data.get(peak_rt)

                                else:

                                    existing_data = peaks_entity_data[apex_rt].get(peak_rt)

                                    existing_data[&#39;mz&#39;].append(mz)
                                    existing_data[&#39;abundance&#39;].append(peak_abundance)
                                    existing_data[&#39;scan_number&#39;].append(scan_index)


        return peaks_entity_data

    def mass_spec_factory(self, rt, datadict):

        # tic = sum(datadict.get(&#39;abundance&#39;))

        scan_index = datadict[&#39;scan_number&#39;][0]

        mz_list, abundance_list = zip(*sorted(zip(datadict[&#39;mz&#39;], datadict[&#39;abundance&#39;])))

        data_dict = {Labels.mz: mz_list, Labels.abundance: abundance_list}

        d_params = default_parameters(self._ms[scan_index]._filename)

        d_params[&#34;rt&#34;] = rt

        d_params[&#34;scan_number&#34;] = scan_index

        d_params[&#39;label&#39;] = Labels.gcms_centroid

        d_params[&#34;polarity&#34;] = self._ms[scan_index].polarity

        d_params[&#39;analyzer&#39;] = self._ms[scan_index].analyzer

        d_params[&#39;instrument_label&#39;] = self._ms[scan_index].instrument_label

        d_params[&#34;filename_path&#34;] = self._ms[scan_index].instrument_label

        ms = MassSpecCentroidLowRes(data_dict, d_params)

        return ms

    def smooth_signal(self, signal):

        implemented_smooth_method = self.chromatogram_settings.implemented_smooth_method

        pol_order = self.chromatogram_settings.savgol_pol_order

        window_len = self.chromatogram_settings.smooth_window

        window = self.chromatogram_settings.smooth_method

        return sp.smooth_signal(signal, window_len, window, pol_order, implemented_smooth_method)

    def add_gcpeak(self, new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, datadict, plot_res):

        if start_rt &lt;= peak_rt[new_apex_index[1]] &lt;= final_rt:

            rt_list = peak_rt[new_apex_index[0]:new_apex_index[2]]
            tic_list = smoothed_tic[new_apex_index[0]:new_apex_index[2]]

            apex_rt = peak_rt[new_apex_index[1]]
            apex_i = rt_list.index(apex_rt)

            &#39;&#39;&#39;workaround for peak picking missing some local minimas&#39;&#39;&#39;
            if not apex_rt in self.processed_appexes:

                self.processed_appexes.append(apex_rt)

                mass_spectra = (self.mass_spec_factory(rt, datadict.get(rt)) for rt in rt_list)

                gc_peak = GCPeakDeconvolved(self, mass_spectra, apex_i, rt_list, tic_list)

                gc_peak.calc_area(tic_list, 1)

                self.gcpeaks.append(gc_peak)

                if plot_res:

                    plt.plot(gc_peak.rt_list, gc_peak.tic_list)
                    plt.plot(gc_peak.rt, gc_peak.tic, c=&#39;black&#39;, marker= &#39;^&#39;, linewidth=0)

    def deconvolution(self, peaks_entity_data, plot_res):

        # plot_res = True 
        domain = self.retention_time
        signal = self._processed_tic
        max_height = self.chromatogram_settings.peak_height_max_percent
        max_prominence = self.chromatogram_settings.peak_max_prominence_percent
        min_peak_datapoints = self.chromatogram_settings.min_peak_datapoints
        signal_threshold = self.chromatogram_settings.peak_height_min_percent
        max_rt_distance = self.chromatogram_settings.max_rt_distance

        max_signal = max(signal)
        correct_baseline = False

        include_indexes = sp.peak_picking_first_derivative(domain, signal, max_height, max_prominence, max_signal, min_peak_datapoints,
                                                           signal_threshold=signal_threshold, correct_baseline=correct_baseline, plot_res=False)

        &#39;&#39;&#39; deconvolution window is defined by the TIC peak region&#39;&#39;&#39;
        all_apexes_rt = np.array(list(peaks_entity_data.keys()))

        &#39;&#39;&#39;workaround for peak picking missing some local minimas&#39;&#39;&#39;
        self.processed_appexes = []

        for indexes_tuple in include_indexes:

            start_rt = self.retention_time[indexes_tuple[0]]
            # apex_rt = self.retention_time[indexes_tuple[1]]
            final_rt = self.retention_time[indexes_tuple[2]]

            &#39;&#39;&#39; find all features within TIC peak window&#39;&#39;&#39;
            peak_features_indexes = np.where((all_apexes_rt &gt; start_rt) &amp; (all_apexes_rt &lt; final_rt))[0]
            peak_features_rts = all_apexes_rt[peak_features_indexes]

            # print(start_rt, apex_rt, final_rt )

            filtered_features_rt = []
            filtered_features_abundance = []

            for each_apex_rt in peak_features_rts:

                apex_data = peaks_entity_data.get(each_apex_rt).get(each_apex_rt)

                peak_features_tic = sum(peaks_entity_data.get(each_apex_rt).get(each_apex_rt).get(&#39;abundance&#39;))

                norm_smooth_tic = (peak_features_tic / max_signal) * 100

                &#39;&#39;&#39; TODO: 
                    Improve Peak Filtering

                    Calculate peaks sharpness here and filter it out (Amax - An /n)?
                    Peak Fit and Calculate Peak Gaussian Similarity?
                    Currentely using flat % tic relative abundance threshold and min 3 m/z per mass spectrum
                &#39;&#39;&#39;
                if norm_smooth_tic &gt; signal_threshold and len(apex_data[&#39;mz&#39;]) &gt; 1:

                    # print(len(apex_data[&#39;mz&#39;]))
                    filtered_features_rt.append(each_apex_rt)
                    filtered_features_abundance.append(peak_features_tic)

            if len(filtered_features_rt) &gt; 1:
                &#39;&#39;&#39; more than one peak feature identified inside a TIC peak  &#39;&#39;&#39;
                # plt.plot(self.retention_time[indexes_tuple[0]:indexes_tuple[2]], signal[indexes_tuple[0]:indexes_tuple[2]], c=&#39;black&#39;)

                # print(filtered_features_rt)
                grouped_rt = self.hc(filtered_features_rt, filtered_features_abundance, max_rt_distance=max_rt_distance)
                # print(grouped_rt)

                for group, apex_rt_list in grouped_rt.items():
                    &#39;&#39;&#39; each group is a peak feature defined by the hierarchical clutter algorithm

                    &#39;&#39;&#39;
                    group_datadict = {}
                    group_datadict[&#39;ref_apex_rt&#39;] = []

                    for each_group_apex_rt in apex_rt_list:

                        datadict = peaks_entity_data.get(each_group_apex_rt)

                        for rt, each_datadict in datadict.items():

                            if rt == &#34;ref_apex_rt&#34;:

                                group_datadict[&#39;ref_apex_rt&#39;].append(each_datadict)

                            else:

                                if rt in group_datadict.keys():

                                    mz_list = each_datadict.get(&#34;mz&#34;)
                                    abundance_list = each_datadict.get(&#34;abundance&#34;)

                                    each_mz_abun = dict(zip(mz_list, abundance_list)) 

                                    for index_mz, mz in enumerate(group_datadict[rt].get(&#34;mz&#34;)):
                                        if mz in each_mz_abun.keys():

                                            each_mz_abun[mz] = each_mz_abun[mz] + group_datadict[rt].get(&#34;abundance&#34;)[index_mz]

                                        else:

                                            each_mz_abun[mz] = group_datadict[rt].get(&#34;abundance&#34;)[index_mz]

                                    group_datadict[rt] = {&#39;mz&#39;: list(each_mz_abun.keys()),
                                                          &#39;abundance&#39;: list(each_mz_abun.values()),
                                                          &#39;scan_number&#39;: each_datadict.get(&#39;scan_number&#39;)}

                                else:

                                    group_datadict[rt] = each_datadict

                    peak_rt = []
                    peak_tic = []

                    # print(group_datadict.get(&#39;ref_apex_rt&#39;))
                    for rt, each_datadict in group_datadict.items():
                        if rt != &#34;ref_apex_rt&#34;:
                            peak_rt.append(rt)
                            peak_tic.append(sum(each_datadict[&#34;abundance&#34;]))

                    peak_rt, peak_tic = zip(*sorted(zip(peak_rt, peak_tic)))

                    smoothed_tic = self.smooth_signal(peak_tic)

                    include_indexes = sp.peak_picking_first_derivative(peak_rt, smoothed_tic,  max_height, max_prominence, max_signal, min_peak_datapoints,
                                                                            signal_threshold=signal_threshold,  correct_baseline=False, plot_res=False)

                    include_indexes = list(include_indexes)

                    if include_indexes:

                        if len(include_indexes) &gt; 1:
                            &#39;&#39;&#39; after sum there are two apexes
                                check if it is inside the deconvolution window, otherwise ignores it
                            &#39;&#39;&#39;

                            for new_apex_index in include_indexes:
                                # pass
                                self.add_gcpeak(new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, group_datadict, plot_res)

                        else:
                            &#39;&#39;&#39; after sum there is on apex
                                save it
                            &#39;&#39;&#39; 
                            new_apex_index = include_indexes[0]
                            # print(include_indexes, group, apex_rt_list)
                            self.add_gcpeak(new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, group_datadict, plot_res)

            elif len(filtered_features_rt) == 1:
                &#39;&#39;&#39; only one peak feature inside deconvolution window &#39;&#39;&#39;

                each_apex_rt = filtered_features_rt[0]

                datadict = peaks_entity_data.get(each_apex_rt)

                peak_rt = []
                peak_tic = []

                for rt, each_datadict in datadict.items():

                    if rt != &#34;ref_apex_rt&#34;:
                        peak_rt.append(rt)
                        peak_tic.append(sum(each_datadict[&#34;abundance&#34;]))

                peak_rt, peak_tic = zip(*sorted(zip(peak_rt, peak_tic)))

                smoothed_tic = self.smooth_signal(peak_tic)

                include_indexes = sp.peak_picking_first_derivative(peak_rt, smoothed_tic,  max_height, max_prominence, max_signal, min_peak_datapoints,
                                                                            signal_threshold=signal_threshold,  correct_baseline=False, plot_res=False)
                include_indexes = list(include_indexes)   

                if include_indexes:

                        &#39;&#39;&#39; after sum there are two apexes
                            check if it is inside the deconvolution window, otherwise ignores it&#39;&#39;&#39;
                        if len(include_indexes) &gt; 1:

                            for new_apex_index in include_indexes:
                                # pass
                                self.add_gcpeak(new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, datadict, plot_res)

                        else:
                            &#39;&#39;&#39; after sum there is one apex
                            save it
                            includes_indexes = (start, apex, final )&#39;&#39;&#39;

                            new_apex_index = include_indexes[0]

                            self.add_gcpeak(new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, datadict, plot_res)

            else:

                # print(&#39;no data after filter&#39;)
                pass
        if plot_res:
            plt.plot(self.retention_time, self._processed_tic, c=&#39;black&#39;)
            plt.show()

    def quadratic_interpolation(self, rt_list, tic_list, apex_index):

        rt_list = np.array(rt_list)
        tic_list = np.array(tic_list)
        three_highest_i = [i for i in range(apex_index - 1, apex_index + 2)]

        z = np.poly1d(np.polyfit(rt_list[three_highest_i], tic_list[three_highest_i], 2))
        a = z[2]
        b = z[1]

        corrected_apex_rt = -b / (2 * a)
        initial_rt = rt_list[apex_index]

        return initial_rt - corrected_apex_rt</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution"><code class="flex name class">
<span>class <span class="ident">MassDeconvolution</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MassDeconvolution:

    def run_deconvolution(self, plot_res=False):

        eic_dict = self.ion_extracted_chroma(self._ms)

        peaks_entity_data = self.find_peaks_entity(eic_dict)

        &#39;&#39;&#39; select model peaks, create Mass Spectrum objs, GCPeak objs, store results in GC_Class gcpeaks obj&#39;&#39;&#39;
        self.deconvolution(peaks_entity_data, plot_res)

    def centroid_detector(self, tic, rt):
        &#39;&#39;&#39; this function has been replaced with sp.peak_picking_first_derivative
            and it not used
        &#39;&#39;&#39;
        noise_std = self.chromatogram_settings.std_noise_threshold

        method = self.chromatogram_settings.noise_threshold_method

        &#39;&#39;&#39; peak picking&#39;&#39;&#39;
        min_height = self.chromatogram_settings.peak_height_min_percent
        min_datapoints = self.chromatogram_settings.min_peak_datapoints

        &#39;&#39;&#39; baseline detection&#39;&#39;&#39;
        max_prominence = self.chromatogram_settings.peak_max_prominence_percent
        max_height = self.chromatogram_settings.peak_height_max_percent

        peak_indexes_generator = sp.peak_detector_generator(tic, noise_std, method, rt, max_height, min_height, max_prominence, min_datapoints)

        return peak_indexes_generator

    def ion_extracted_chroma(self, mass_spectra_obj):

        eic_dict = {}

        for scan_number, ms_obj in mass_spectra_obj.items():

            mz_list = ms_obj.mz_exp
            abundance_list = ms_obj.abundance
            # add list of scan numbers
            for index, mz in enumerate(mz_list):

                # dict of mz and tuple (mass spectrum abundances index, and scan number)
                if mz not in eic_dict.keys():

                    eic_dict[mz] = [[abundance_list[index]], [ms_obj.rt] ]

                else:

                    eic_dict[mz][0].append(ms_obj.abundance[index])
                    eic_dict[mz][1].append(ms_obj.rt)

        return eic_dict

    def hc(self, X, Y, max_rt_distance=0.025):

        from scipy.cluster.hierarchy import dendrogram, linkage
        from scipy.cluster.hierarchy import fcluster
        # from matplotlib import pyplot as plt

        Z = linkage(np.reshape(X, (len(X), 1)), method=&#34;ward&#34;)
        # Z = linkage(X, method  = &#34;ward&#34;)

        max_d = max_rt_distance
        distance_clusters = fcluster(Z, max_d, criterion=&#39;distance&#39;)
        # print(&#34;distance&#34;)
        # print(distance_clusters)

        # inconsistency_cluster = fcluster(Z, 2, depth=2)
        # max_cluster = fcluster(Z, 2, criterion=&#39;maxclust&#39;)

        grouped_rt = {}

        for index_obj, group in enumerate(distance_clusters):

            if group not in grouped_rt.keys():
                grouped_rt[group] = [X[index_obj]]
            else:
                grouped_rt[group].append(X[index_obj])

        # print(distance_clusters, grouped_rt)
        return grouped_rt      

        # plt.figure(figsize=(10, 8))
        # plt.scatter(X, Y, c=distance_clusters, cmap=&#39;prism&#39;)  # plot points with cluster dependent colors
        # plt.show()
        # labelList = range(int(min(X)), int(max(X)))

        # plt.figure(figsize=(10, 7))
        # dendrogram(Z,
        #            orientation=&#39;top&#39;,
        #            distance_sort=&#39;descending&#39;,
        #            show_leaf_counts=True)
        # plt.show()
        # print(Z)

    def find_peaks_entity(self, eic_dict):

        &#39;&#39;&#39; combine eic with mathing rt apexes&#39;&#39;&#39;
        max_prominence = self.chromatogram_settings.peak_max_prominence_percent

        max_height = self.chromatogram_settings.peak_height_max_percent

        signal_threshold = self.chromatogram_settings.eic_signal_threshold

        min_peak_datapoints = self.chromatogram_settings.min_peak_datapoints

        correct_baseline = False
        peaks_entity_data = {}

        max_eic = 0
        for mz, eic_scan_index_rt in eic_dict.items():

            ind_max_eic = max(eic_scan_index_rt[0])
            max_eic = ind_max_eic if ind_max_eic &gt; max_eic else max_eic

        for mz, eic_scan_index_rt in eic_dict.items():

            eic = eic_scan_index_rt[0]
            rt_list = eic_scan_index_rt[1]

            if len(eic) &gt;= min_peak_datapoints:

                smooth_eic = self.smooth_tic(eic)

                include_indexes = sp.peak_picking_first_derivative(rt_list, smooth_eic, max_height, max_prominence, max_eic, min_peak_datapoints,
                                                                   signal_threshold=signal_threshold, correct_baseline=correct_baseline)

                for initial_scan, apex_scan, final_scan in include_indexes:

                    rt_corrected_therm = self.quadratic_interpolation(rt_list, smooth_eic, apex_scan)

                    ref_apex_rt = round(rt_list[apex_scan] + rt_corrected_therm, 4)

                    apex_rt = rt_list[apex_scan]
                    # apex_abundance = smooth_eic[apex_scan]

                    # maximum_tic = apex_abundance if apex_abundance &gt; maximum_tic else maximum_tic

                    for scan_index in range(initial_scan, final_scan):

                        peak_rt = rt_list[scan_index]
                        peak_abundance = smooth_eic[scan_index]

                        if peak_abundance &gt; 0:

                            dict_data = {peak_rt: {&#39;mz&#39;: [mz],
                                                    &#39;abundance&#39;: [peak_abundance],
                                                    &#39;scan_number&#39;: [scan_index]},
                                                    &#39;ref_apex_rt&#39;: ref_apex_rt
                                                    }

                            if apex_rt not in peaks_entity_data.keys():

                                peaks_entity_data[apex_rt] = dict_data

                            else:

                                if peak_rt not in peaks_entity_data[apex_rt].keys():

                                    peaks_entity_data[apex_rt][peak_rt] = dict_data.get(peak_rt)

                                else:

                                    existing_data = peaks_entity_data[apex_rt].get(peak_rt)

                                    existing_data[&#39;mz&#39;].append(mz)
                                    existing_data[&#39;abundance&#39;].append(peak_abundance)
                                    existing_data[&#39;scan_number&#39;].append(scan_index)


        return peaks_entity_data

    def mass_spec_factory(self, rt, datadict):

        # tic = sum(datadict.get(&#39;abundance&#39;))

        scan_index = datadict[&#39;scan_number&#39;][0]

        mz_list, abundance_list = zip(*sorted(zip(datadict[&#39;mz&#39;], datadict[&#39;abundance&#39;])))

        data_dict = {Labels.mz: mz_list, Labels.abundance: abundance_list}

        d_params = default_parameters(self._ms[scan_index]._filename)

        d_params[&#34;rt&#34;] = rt

        d_params[&#34;scan_number&#34;] = scan_index

        d_params[&#39;label&#39;] = Labels.gcms_centroid

        d_params[&#34;polarity&#34;] = self._ms[scan_index].polarity

        d_params[&#39;analyzer&#39;] = self._ms[scan_index].analyzer

        d_params[&#39;instrument_label&#39;] = self._ms[scan_index].instrument_label

        d_params[&#34;filename_path&#34;] = self._ms[scan_index].instrument_label

        ms = MassSpecCentroidLowRes(data_dict, d_params)

        return ms

    def smooth_signal(self, signal):

        implemented_smooth_method = self.chromatogram_settings.implemented_smooth_method

        pol_order = self.chromatogram_settings.savgol_pol_order

        window_len = self.chromatogram_settings.smooth_window

        window = self.chromatogram_settings.smooth_method

        return sp.smooth_signal(signal, window_len, window, pol_order, implemented_smooth_method)

    def add_gcpeak(self, new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, datadict, plot_res):

        if start_rt &lt;= peak_rt[new_apex_index[1]] &lt;= final_rt:

            rt_list = peak_rt[new_apex_index[0]:new_apex_index[2]]
            tic_list = smoothed_tic[new_apex_index[0]:new_apex_index[2]]

            apex_rt = peak_rt[new_apex_index[1]]
            apex_i = rt_list.index(apex_rt)

            &#39;&#39;&#39;workaround for peak picking missing some local minimas&#39;&#39;&#39;
            if not apex_rt in self.processed_appexes:

                self.processed_appexes.append(apex_rt)

                mass_spectra = (self.mass_spec_factory(rt, datadict.get(rt)) for rt in rt_list)

                gc_peak = GCPeakDeconvolved(self, mass_spectra, apex_i, rt_list, tic_list)

                gc_peak.calc_area(tic_list, 1)

                self.gcpeaks.append(gc_peak)

                if plot_res:

                    plt.plot(gc_peak.rt_list, gc_peak.tic_list)
                    plt.plot(gc_peak.rt, gc_peak.tic, c=&#39;black&#39;, marker= &#39;^&#39;, linewidth=0)

    def deconvolution(self, peaks_entity_data, plot_res):

        # plot_res = True 
        domain = self.retention_time
        signal = self._processed_tic
        max_height = self.chromatogram_settings.peak_height_max_percent
        max_prominence = self.chromatogram_settings.peak_max_prominence_percent
        min_peak_datapoints = self.chromatogram_settings.min_peak_datapoints
        signal_threshold = self.chromatogram_settings.peak_height_min_percent
        max_rt_distance = self.chromatogram_settings.max_rt_distance

        max_signal = max(signal)
        correct_baseline = False

        include_indexes = sp.peak_picking_first_derivative(domain, signal, max_height, max_prominence, max_signal, min_peak_datapoints,
                                                           signal_threshold=signal_threshold, correct_baseline=correct_baseline, plot_res=False)

        &#39;&#39;&#39; deconvolution window is defined by the TIC peak region&#39;&#39;&#39;
        all_apexes_rt = np.array(list(peaks_entity_data.keys()))

        &#39;&#39;&#39;workaround for peak picking missing some local minimas&#39;&#39;&#39;
        self.processed_appexes = []

        for indexes_tuple in include_indexes:

            start_rt = self.retention_time[indexes_tuple[0]]
            # apex_rt = self.retention_time[indexes_tuple[1]]
            final_rt = self.retention_time[indexes_tuple[2]]

            &#39;&#39;&#39; find all features within TIC peak window&#39;&#39;&#39;
            peak_features_indexes = np.where((all_apexes_rt &gt; start_rt) &amp; (all_apexes_rt &lt; final_rt))[0]
            peak_features_rts = all_apexes_rt[peak_features_indexes]

            # print(start_rt, apex_rt, final_rt )

            filtered_features_rt = []
            filtered_features_abundance = []

            for each_apex_rt in peak_features_rts:

                apex_data = peaks_entity_data.get(each_apex_rt).get(each_apex_rt)

                peak_features_tic = sum(peaks_entity_data.get(each_apex_rt).get(each_apex_rt).get(&#39;abundance&#39;))

                norm_smooth_tic = (peak_features_tic / max_signal) * 100

                &#39;&#39;&#39; TODO: 
                    Improve Peak Filtering

                    Calculate peaks sharpness here and filter it out (Amax - An /n)?
                    Peak Fit and Calculate Peak Gaussian Similarity?
                    Currentely using flat % tic relative abundance threshold and min 3 m/z per mass spectrum
                &#39;&#39;&#39;
                if norm_smooth_tic &gt; signal_threshold and len(apex_data[&#39;mz&#39;]) &gt; 1:

                    # print(len(apex_data[&#39;mz&#39;]))
                    filtered_features_rt.append(each_apex_rt)
                    filtered_features_abundance.append(peak_features_tic)

            if len(filtered_features_rt) &gt; 1:
                &#39;&#39;&#39; more than one peak feature identified inside a TIC peak  &#39;&#39;&#39;
                # plt.plot(self.retention_time[indexes_tuple[0]:indexes_tuple[2]], signal[indexes_tuple[0]:indexes_tuple[2]], c=&#39;black&#39;)

                # print(filtered_features_rt)
                grouped_rt = self.hc(filtered_features_rt, filtered_features_abundance, max_rt_distance=max_rt_distance)
                # print(grouped_rt)

                for group, apex_rt_list in grouped_rt.items():
                    &#39;&#39;&#39; each group is a peak feature defined by the hierarchical clutter algorithm

                    &#39;&#39;&#39;
                    group_datadict = {}
                    group_datadict[&#39;ref_apex_rt&#39;] = []

                    for each_group_apex_rt in apex_rt_list:

                        datadict = peaks_entity_data.get(each_group_apex_rt)

                        for rt, each_datadict in datadict.items():

                            if rt == &#34;ref_apex_rt&#34;:

                                group_datadict[&#39;ref_apex_rt&#39;].append(each_datadict)

                            else:

                                if rt in group_datadict.keys():

                                    mz_list = each_datadict.get(&#34;mz&#34;)
                                    abundance_list = each_datadict.get(&#34;abundance&#34;)

                                    each_mz_abun = dict(zip(mz_list, abundance_list)) 

                                    for index_mz, mz in enumerate(group_datadict[rt].get(&#34;mz&#34;)):
                                        if mz in each_mz_abun.keys():

                                            each_mz_abun[mz] = each_mz_abun[mz] + group_datadict[rt].get(&#34;abundance&#34;)[index_mz]

                                        else:

                                            each_mz_abun[mz] = group_datadict[rt].get(&#34;abundance&#34;)[index_mz]

                                    group_datadict[rt] = {&#39;mz&#39;: list(each_mz_abun.keys()),
                                                          &#39;abundance&#39;: list(each_mz_abun.values()),
                                                          &#39;scan_number&#39;: each_datadict.get(&#39;scan_number&#39;)}

                                else:

                                    group_datadict[rt] = each_datadict

                    peak_rt = []
                    peak_tic = []

                    # print(group_datadict.get(&#39;ref_apex_rt&#39;))
                    for rt, each_datadict in group_datadict.items():
                        if rt != &#34;ref_apex_rt&#34;:
                            peak_rt.append(rt)
                            peak_tic.append(sum(each_datadict[&#34;abundance&#34;]))

                    peak_rt, peak_tic = zip(*sorted(zip(peak_rt, peak_tic)))

                    smoothed_tic = self.smooth_signal(peak_tic)

                    include_indexes = sp.peak_picking_first_derivative(peak_rt, smoothed_tic,  max_height, max_prominence, max_signal, min_peak_datapoints,
                                                                            signal_threshold=signal_threshold,  correct_baseline=False, plot_res=False)

                    include_indexes = list(include_indexes)

                    if include_indexes:

                        if len(include_indexes) &gt; 1:
                            &#39;&#39;&#39; after sum there are two apexes
                                check if it is inside the deconvolution window, otherwise ignores it
                            &#39;&#39;&#39;

                            for new_apex_index in include_indexes:
                                # pass
                                self.add_gcpeak(new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, group_datadict, plot_res)

                        else:
                            &#39;&#39;&#39; after sum there is on apex
                                save it
                            &#39;&#39;&#39; 
                            new_apex_index = include_indexes[0]
                            # print(include_indexes, group, apex_rt_list)
                            self.add_gcpeak(new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, group_datadict, plot_res)

            elif len(filtered_features_rt) == 1:
                &#39;&#39;&#39; only one peak feature inside deconvolution window &#39;&#39;&#39;

                each_apex_rt = filtered_features_rt[0]

                datadict = peaks_entity_data.get(each_apex_rt)

                peak_rt = []
                peak_tic = []

                for rt, each_datadict in datadict.items():

                    if rt != &#34;ref_apex_rt&#34;:
                        peak_rt.append(rt)
                        peak_tic.append(sum(each_datadict[&#34;abundance&#34;]))

                peak_rt, peak_tic = zip(*sorted(zip(peak_rt, peak_tic)))

                smoothed_tic = self.smooth_signal(peak_tic)

                include_indexes = sp.peak_picking_first_derivative(peak_rt, smoothed_tic,  max_height, max_prominence, max_signal, min_peak_datapoints,
                                                                            signal_threshold=signal_threshold,  correct_baseline=False, plot_res=False)
                include_indexes = list(include_indexes)   

                if include_indexes:

                        &#39;&#39;&#39; after sum there are two apexes
                            check if it is inside the deconvolution window, otherwise ignores it&#39;&#39;&#39;
                        if len(include_indexes) &gt; 1:

                            for new_apex_index in include_indexes:
                                # pass
                                self.add_gcpeak(new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, datadict, plot_res)

                        else:
                            &#39;&#39;&#39; after sum there is one apex
                            save it
                            includes_indexes = (start, apex, final )&#39;&#39;&#39;

                            new_apex_index = include_indexes[0]

                            self.add_gcpeak(new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, datadict, plot_res)

            else:

                # print(&#39;no data after filter&#39;)
                pass
        if plot_res:
            plt.plot(self.retention_time, self._processed_tic, c=&#39;black&#39;)
            plt.show()

    def quadratic_interpolation(self, rt_list, tic_list, apex_index):

        rt_list = np.array(rt_list)
        tic_list = np.array(tic_list)
        three_highest_i = [i for i in range(apex_index - 1, apex_index + 2)]

        z = np.poly1d(np.polyfit(rt_list[three_highest_i], tic_list[three_highest_i], 2))
        a = z[2]
        b = z[1]

        corrected_apex_rt = -b / (2 * a)
        initial_rt = rt_list[apex_index]

        return initial_rt - corrected_apex_rt</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="corems.mass_spectra.factory.GC_Class.GCMSBase" href="../factory/GC_Class.html#corems.mass_spectra.factory.GC_Class.GCMSBase">GCMSBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.add_gcpeak"><code class="name flex">
<span>def <span class="ident">add_gcpeak</span></span>(<span>self, new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, datadict, plot_res)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_gcpeak(self, new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, datadict, plot_res):

    if start_rt &lt;= peak_rt[new_apex_index[1]] &lt;= final_rt:

        rt_list = peak_rt[new_apex_index[0]:new_apex_index[2]]
        tic_list = smoothed_tic[new_apex_index[0]:new_apex_index[2]]

        apex_rt = peak_rt[new_apex_index[1]]
        apex_i = rt_list.index(apex_rt)

        &#39;&#39;&#39;workaround for peak picking missing some local minimas&#39;&#39;&#39;
        if not apex_rt in self.processed_appexes:

            self.processed_appexes.append(apex_rt)

            mass_spectra = (self.mass_spec_factory(rt, datadict.get(rt)) for rt in rt_list)

            gc_peak = GCPeakDeconvolved(self, mass_spectra, apex_i, rt_list, tic_list)

            gc_peak.calc_area(tic_list, 1)

            self.gcpeaks.append(gc_peak)

            if plot_res:

                plt.plot(gc_peak.rt_list, gc_peak.tic_list)
                plt.plot(gc_peak.rt, gc_peak.tic, c=&#39;black&#39;, marker= &#39;^&#39;, linewidth=0)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.centroid_detector"><code class="name flex">
<span>def <span class="ident">centroid_detector</span></span>(<span>self, tic, rt)</span>
</code></dt>
<dd>
<div class="desc"><p>this function has been replaced with sp.peak_picking_first_derivative
and it not used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centroid_detector(self, tic, rt):
    &#39;&#39;&#39; this function has been replaced with sp.peak_picking_first_derivative
        and it not used
    &#39;&#39;&#39;
    noise_std = self.chromatogram_settings.std_noise_threshold

    method = self.chromatogram_settings.noise_threshold_method

    &#39;&#39;&#39; peak picking&#39;&#39;&#39;
    min_height = self.chromatogram_settings.peak_height_min_percent
    min_datapoints = self.chromatogram_settings.min_peak_datapoints

    &#39;&#39;&#39; baseline detection&#39;&#39;&#39;
    max_prominence = self.chromatogram_settings.peak_max_prominence_percent
    max_height = self.chromatogram_settings.peak_height_max_percent

    peak_indexes_generator = sp.peak_detector_generator(tic, noise_std, method, rt, max_height, min_height, max_prominence, min_datapoints)

    return peak_indexes_generator</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.deconvolution"><code class="name flex">
<span>def <span class="ident">deconvolution</span></span>(<span>self, peaks_entity_data, plot_res)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deconvolution(self, peaks_entity_data, plot_res):

    # plot_res = True 
    domain = self.retention_time
    signal = self._processed_tic
    max_height = self.chromatogram_settings.peak_height_max_percent
    max_prominence = self.chromatogram_settings.peak_max_prominence_percent
    min_peak_datapoints = self.chromatogram_settings.min_peak_datapoints
    signal_threshold = self.chromatogram_settings.peak_height_min_percent
    max_rt_distance = self.chromatogram_settings.max_rt_distance

    max_signal = max(signal)
    correct_baseline = False

    include_indexes = sp.peak_picking_first_derivative(domain, signal, max_height, max_prominence, max_signal, min_peak_datapoints,
                                                       signal_threshold=signal_threshold, correct_baseline=correct_baseline, plot_res=False)

    &#39;&#39;&#39; deconvolution window is defined by the TIC peak region&#39;&#39;&#39;
    all_apexes_rt = np.array(list(peaks_entity_data.keys()))

    &#39;&#39;&#39;workaround for peak picking missing some local minimas&#39;&#39;&#39;
    self.processed_appexes = []

    for indexes_tuple in include_indexes:

        start_rt = self.retention_time[indexes_tuple[0]]
        # apex_rt = self.retention_time[indexes_tuple[1]]
        final_rt = self.retention_time[indexes_tuple[2]]

        &#39;&#39;&#39; find all features within TIC peak window&#39;&#39;&#39;
        peak_features_indexes = np.where((all_apexes_rt &gt; start_rt) &amp; (all_apexes_rt &lt; final_rt))[0]
        peak_features_rts = all_apexes_rt[peak_features_indexes]

        # print(start_rt, apex_rt, final_rt )

        filtered_features_rt = []
        filtered_features_abundance = []

        for each_apex_rt in peak_features_rts:

            apex_data = peaks_entity_data.get(each_apex_rt).get(each_apex_rt)

            peak_features_tic = sum(peaks_entity_data.get(each_apex_rt).get(each_apex_rt).get(&#39;abundance&#39;))

            norm_smooth_tic = (peak_features_tic / max_signal) * 100

            &#39;&#39;&#39; TODO: 
                Improve Peak Filtering

                Calculate peaks sharpness here and filter it out (Amax - An /n)?
                Peak Fit and Calculate Peak Gaussian Similarity?
                Currentely using flat % tic relative abundance threshold and min 3 m/z per mass spectrum
            &#39;&#39;&#39;
            if norm_smooth_tic &gt; signal_threshold and len(apex_data[&#39;mz&#39;]) &gt; 1:

                # print(len(apex_data[&#39;mz&#39;]))
                filtered_features_rt.append(each_apex_rt)
                filtered_features_abundance.append(peak_features_tic)

        if len(filtered_features_rt) &gt; 1:
            &#39;&#39;&#39; more than one peak feature identified inside a TIC peak  &#39;&#39;&#39;
            # plt.plot(self.retention_time[indexes_tuple[0]:indexes_tuple[2]], signal[indexes_tuple[0]:indexes_tuple[2]], c=&#39;black&#39;)

            # print(filtered_features_rt)
            grouped_rt = self.hc(filtered_features_rt, filtered_features_abundance, max_rt_distance=max_rt_distance)
            # print(grouped_rt)

            for group, apex_rt_list in grouped_rt.items():
                &#39;&#39;&#39; each group is a peak feature defined by the hierarchical clutter algorithm

                &#39;&#39;&#39;
                group_datadict = {}
                group_datadict[&#39;ref_apex_rt&#39;] = []

                for each_group_apex_rt in apex_rt_list:

                    datadict = peaks_entity_data.get(each_group_apex_rt)

                    for rt, each_datadict in datadict.items():

                        if rt == &#34;ref_apex_rt&#34;:

                            group_datadict[&#39;ref_apex_rt&#39;].append(each_datadict)

                        else:

                            if rt in group_datadict.keys():

                                mz_list = each_datadict.get(&#34;mz&#34;)
                                abundance_list = each_datadict.get(&#34;abundance&#34;)

                                each_mz_abun = dict(zip(mz_list, abundance_list)) 

                                for index_mz, mz in enumerate(group_datadict[rt].get(&#34;mz&#34;)):
                                    if mz in each_mz_abun.keys():

                                        each_mz_abun[mz] = each_mz_abun[mz] + group_datadict[rt].get(&#34;abundance&#34;)[index_mz]

                                    else:

                                        each_mz_abun[mz] = group_datadict[rt].get(&#34;abundance&#34;)[index_mz]

                                group_datadict[rt] = {&#39;mz&#39;: list(each_mz_abun.keys()),
                                                      &#39;abundance&#39;: list(each_mz_abun.values()),
                                                      &#39;scan_number&#39;: each_datadict.get(&#39;scan_number&#39;)}

                            else:

                                group_datadict[rt] = each_datadict

                peak_rt = []
                peak_tic = []

                # print(group_datadict.get(&#39;ref_apex_rt&#39;))
                for rt, each_datadict in group_datadict.items():
                    if rt != &#34;ref_apex_rt&#34;:
                        peak_rt.append(rt)
                        peak_tic.append(sum(each_datadict[&#34;abundance&#34;]))

                peak_rt, peak_tic = zip(*sorted(zip(peak_rt, peak_tic)))

                smoothed_tic = self.smooth_signal(peak_tic)

                include_indexes = sp.peak_picking_first_derivative(peak_rt, smoothed_tic,  max_height, max_prominence, max_signal, min_peak_datapoints,
                                                                        signal_threshold=signal_threshold,  correct_baseline=False, plot_res=False)

                include_indexes = list(include_indexes)

                if include_indexes:

                    if len(include_indexes) &gt; 1:
                        &#39;&#39;&#39; after sum there are two apexes
                            check if it is inside the deconvolution window, otherwise ignores it
                        &#39;&#39;&#39;

                        for new_apex_index in include_indexes:
                            # pass
                            self.add_gcpeak(new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, group_datadict, plot_res)

                    else:
                        &#39;&#39;&#39; after sum there is on apex
                            save it
                        &#39;&#39;&#39; 
                        new_apex_index = include_indexes[0]
                        # print(include_indexes, group, apex_rt_list)
                        self.add_gcpeak(new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, group_datadict, plot_res)

        elif len(filtered_features_rt) == 1:
            &#39;&#39;&#39; only one peak feature inside deconvolution window &#39;&#39;&#39;

            each_apex_rt = filtered_features_rt[0]

            datadict = peaks_entity_data.get(each_apex_rt)

            peak_rt = []
            peak_tic = []

            for rt, each_datadict in datadict.items():

                if rt != &#34;ref_apex_rt&#34;:
                    peak_rt.append(rt)
                    peak_tic.append(sum(each_datadict[&#34;abundance&#34;]))

            peak_rt, peak_tic = zip(*sorted(zip(peak_rt, peak_tic)))

            smoothed_tic = self.smooth_signal(peak_tic)

            include_indexes = sp.peak_picking_first_derivative(peak_rt, smoothed_tic,  max_height, max_prominence, max_signal, min_peak_datapoints,
                                                                        signal_threshold=signal_threshold,  correct_baseline=False, plot_res=False)
            include_indexes = list(include_indexes)   

            if include_indexes:

                    &#39;&#39;&#39; after sum there are two apexes
                        check if it is inside the deconvolution window, otherwise ignores it&#39;&#39;&#39;
                    if len(include_indexes) &gt; 1:

                        for new_apex_index in include_indexes:
                            # pass
                            self.add_gcpeak(new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, datadict, plot_res)

                    else:
                        &#39;&#39;&#39; after sum there is one apex
                        save it
                        includes_indexes = (start, apex, final )&#39;&#39;&#39;

                        new_apex_index = include_indexes[0]

                        self.add_gcpeak(new_apex_index, start_rt, final_rt, peak_rt, smoothed_tic, datadict, plot_res)

        else:

            # print(&#39;no data after filter&#39;)
            pass
    if plot_res:
        plt.plot(self.retention_time, self._processed_tic, c=&#39;black&#39;)
        plt.show()</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.find_peaks_entity"><code class="name flex">
<span>def <span class="ident">find_peaks_entity</span></span>(<span>self, eic_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>combine eic with mathing rt apexes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_peaks_entity(self, eic_dict):

    &#39;&#39;&#39; combine eic with mathing rt apexes&#39;&#39;&#39;
    max_prominence = self.chromatogram_settings.peak_max_prominence_percent

    max_height = self.chromatogram_settings.peak_height_max_percent

    signal_threshold = self.chromatogram_settings.eic_signal_threshold

    min_peak_datapoints = self.chromatogram_settings.min_peak_datapoints

    correct_baseline = False
    peaks_entity_data = {}

    max_eic = 0
    for mz, eic_scan_index_rt in eic_dict.items():

        ind_max_eic = max(eic_scan_index_rt[0])
        max_eic = ind_max_eic if ind_max_eic &gt; max_eic else max_eic

    for mz, eic_scan_index_rt in eic_dict.items():

        eic = eic_scan_index_rt[0]
        rt_list = eic_scan_index_rt[1]

        if len(eic) &gt;= min_peak_datapoints:

            smooth_eic = self.smooth_tic(eic)

            include_indexes = sp.peak_picking_first_derivative(rt_list, smooth_eic, max_height, max_prominence, max_eic, min_peak_datapoints,
                                                               signal_threshold=signal_threshold, correct_baseline=correct_baseline)

            for initial_scan, apex_scan, final_scan in include_indexes:

                rt_corrected_therm = self.quadratic_interpolation(rt_list, smooth_eic, apex_scan)

                ref_apex_rt = round(rt_list[apex_scan] + rt_corrected_therm, 4)

                apex_rt = rt_list[apex_scan]
                # apex_abundance = smooth_eic[apex_scan]

                # maximum_tic = apex_abundance if apex_abundance &gt; maximum_tic else maximum_tic

                for scan_index in range(initial_scan, final_scan):

                    peak_rt = rt_list[scan_index]
                    peak_abundance = smooth_eic[scan_index]

                    if peak_abundance &gt; 0:

                        dict_data = {peak_rt: {&#39;mz&#39;: [mz],
                                                &#39;abundance&#39;: [peak_abundance],
                                                &#39;scan_number&#39;: [scan_index]},
                                                &#39;ref_apex_rt&#39;: ref_apex_rt
                                                }

                        if apex_rt not in peaks_entity_data.keys():

                            peaks_entity_data[apex_rt] = dict_data

                        else:

                            if peak_rt not in peaks_entity_data[apex_rt].keys():

                                peaks_entity_data[apex_rt][peak_rt] = dict_data.get(peak_rt)

                            else:

                                existing_data = peaks_entity_data[apex_rt].get(peak_rt)

                                existing_data[&#39;mz&#39;].append(mz)
                                existing_data[&#39;abundance&#39;].append(peak_abundance)
                                existing_data[&#39;scan_number&#39;].append(scan_index)


    return peaks_entity_data</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.hc"><code class="name flex">
<span>def <span class="ident">hc</span></span>(<span>self, X, Y, max_rt_distance=0.025)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hc(self, X, Y, max_rt_distance=0.025):

    from scipy.cluster.hierarchy import dendrogram, linkage
    from scipy.cluster.hierarchy import fcluster
    # from matplotlib import pyplot as plt

    Z = linkage(np.reshape(X, (len(X), 1)), method=&#34;ward&#34;)
    # Z = linkage(X, method  = &#34;ward&#34;)

    max_d = max_rt_distance
    distance_clusters = fcluster(Z, max_d, criterion=&#39;distance&#39;)
    # print(&#34;distance&#34;)
    # print(distance_clusters)

    # inconsistency_cluster = fcluster(Z, 2, depth=2)
    # max_cluster = fcluster(Z, 2, criterion=&#39;maxclust&#39;)

    grouped_rt = {}

    for index_obj, group in enumerate(distance_clusters):

        if group not in grouped_rt.keys():
            grouped_rt[group] = [X[index_obj]]
        else:
            grouped_rt[group].append(X[index_obj])

    # print(distance_clusters, grouped_rt)
    return grouped_rt      </code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.ion_extracted_chroma"><code class="name flex">
<span>def <span class="ident">ion_extracted_chroma</span></span>(<span>self, mass_spectra_obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ion_extracted_chroma(self, mass_spectra_obj):

    eic_dict = {}

    for scan_number, ms_obj in mass_spectra_obj.items():

        mz_list = ms_obj.mz_exp
        abundance_list = ms_obj.abundance
        # add list of scan numbers
        for index, mz in enumerate(mz_list):

            # dict of mz and tuple (mass spectrum abundances index, and scan number)
            if mz not in eic_dict.keys():

                eic_dict[mz] = [[abundance_list[index]], [ms_obj.rt] ]

            else:

                eic_dict[mz][0].append(ms_obj.abundance[index])
                eic_dict[mz][1].append(ms_obj.rt)

    return eic_dict</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.mass_spec_factory"><code class="name flex">
<span>def <span class="ident">mass_spec_factory</span></span>(<span>self, rt, datadict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mass_spec_factory(self, rt, datadict):

    # tic = sum(datadict.get(&#39;abundance&#39;))

    scan_index = datadict[&#39;scan_number&#39;][0]

    mz_list, abundance_list = zip(*sorted(zip(datadict[&#39;mz&#39;], datadict[&#39;abundance&#39;])))

    data_dict = {Labels.mz: mz_list, Labels.abundance: abundance_list}

    d_params = default_parameters(self._ms[scan_index]._filename)

    d_params[&#34;rt&#34;] = rt

    d_params[&#34;scan_number&#34;] = scan_index

    d_params[&#39;label&#39;] = Labels.gcms_centroid

    d_params[&#34;polarity&#34;] = self._ms[scan_index].polarity

    d_params[&#39;analyzer&#39;] = self._ms[scan_index].analyzer

    d_params[&#39;instrument_label&#39;] = self._ms[scan_index].instrument_label

    d_params[&#34;filename_path&#34;] = self._ms[scan_index].instrument_label

    ms = MassSpecCentroidLowRes(data_dict, d_params)

    return ms</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.quadratic_interpolation"><code class="name flex">
<span>def <span class="ident">quadratic_interpolation</span></span>(<span>self, rt_list, tic_list, apex_index)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quadratic_interpolation(self, rt_list, tic_list, apex_index):

    rt_list = np.array(rt_list)
    tic_list = np.array(tic_list)
    three_highest_i = [i for i in range(apex_index - 1, apex_index + 2)]

    z = np.poly1d(np.polyfit(rt_list[three_highest_i], tic_list[three_highest_i], 2))
    a = z[2]
    b = z[1]

    corrected_apex_rt = -b / (2 * a)
    initial_rt = rt_list[apex_index]

    return initial_rt - corrected_apex_rt</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.run_deconvolution"><code class="name flex">
<span>def <span class="ident">run_deconvolution</span></span>(<span>self, plot_res=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_deconvolution(self, plot_res=False):

    eic_dict = self.ion_extracted_chroma(self._ms)

    peaks_entity_data = self.find_peaks_entity(eic_dict)

    &#39;&#39;&#39; select model peaks, create Mass Spectrum objs, GCPeak objs, store results in GC_Class gcpeaks obj&#39;&#39;&#39;
    self.deconvolution(peaks_entity_data, plot_res)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.smooth_signal"><code class="name flex">
<span>def <span class="ident">smooth_signal</span></span>(<span>self, signal)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smooth_signal(self, signal):

    implemented_smooth_method = self.chromatogram_settings.implemented_smooth_method

    pol_order = self.chromatogram_settings.savgol_pol_order

    window_len = self.chromatogram_settings.smooth_window

    window = self.chromatogram_settings.smooth_method

    return sp.smooth_signal(signal, window_len, window, pol_order, implemented_smooth_method)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.mass_spectra.calc" href="index.html">corems.mass_spectra.calc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution" href="#corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution">MassDeconvolution</a></code></h4>
<ul class="">
<li><code><a title="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.add_gcpeak" href="#corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.add_gcpeak">add_gcpeak</a></code></li>
<li><code><a title="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.centroid_detector" href="#corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.centroid_detector">centroid_detector</a></code></li>
<li><code><a title="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.deconvolution" href="#corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.deconvolution">deconvolution</a></code></li>
<li><code><a title="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.find_peaks_entity" href="#corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.find_peaks_entity">find_peaks_entity</a></code></li>
<li><code><a title="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.hc" href="#corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.hc">hc</a></code></li>
<li><code><a title="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.ion_extracted_chroma" href="#corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.ion_extracted_chroma">ion_extracted_chroma</a></code></li>
<li><code><a title="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.mass_spec_factory" href="#corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.mass_spec_factory">mass_spec_factory</a></code></li>
<li><code><a title="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.quadratic_interpolation" href="#corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.quadratic_interpolation">quadratic_interpolation</a></code></li>
<li><code><a title="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.run_deconvolution" href="#corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.run_deconvolution">run_deconvolution</a></code></li>
<li><code><a title="corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.smooth_signal" href="#corems.mass_spectra.calc.GC_Deconvolution.MassDeconvolution.smooth_signal">smooth_signal</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>