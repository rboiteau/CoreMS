<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.molecular_id.factory.classification API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.molecular_id.factory.classification</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__author__ = &#34;Yuri E. Corilo&#34;
__date__ = &#34;Jan 31, 2020&#34;

from collections.abc import Mapping

from matplotlib import pyplot as plt
from numpy import linspace

from corems.encapsulation.constant import Labels
from corems.encapsulation.constant import Atoms

flatten_list = lambda l: [item for sublist in l for item in sublist]

class HeteroatomsClassification(Mapping):
    
    &#39;&#39;&#39;Group mass spectrum data by heteroatom classes (Nn, Oo, Ss, NnOo, NnSs, etc..)
        
       class obj behaves as a dictionary of classes and return a list of ms_peak obj

    &#39;&#39;&#39;
    
    def __init__(self, mass_spectrum, choose_molecular_formula=True):

        def sort_atoms_method( atom):
            
            return [Atoms.atoms_order.index(atom)]

        self._ms_grouped_class = dict()
        
        self.choose_mf = choose_molecular_formula
        
        #mapping for ms peaks without any molecular formula associated
        self._ms_grouped_class[Labels.unassigned] = list()

        self.total_peaks = 0

        self.sum_abundance = 0

        self.min_max_mz = (mass_spectrum.min_mz_exp, mass_spectrum.max_mz_exp)

        self.min_max_abundance = (mass_spectrum.min_abundance, mass_spectrum.max_abundance)

        self.min_ppm_error = mass_spectrum.molecular_search_settings.min_ppm_error 

        self.max_ppm_error = mass_spectrum.molecular_search_settings.max_ppm_error

        check_assign = False

        all_used_atoms = set()

        for ms_peak in mass_spectrum:
            
            self.total_peaks += 1

            self.sum_abundance += ms_peak.abundance

            if not ms_peak.is_assigned:

                self._ms_grouped_class.get(Labels.unassigned).append(ms_peak)
                
            else:    
                
                check_assign = True    

                if choose_molecular_formula:
                    
                    mf = ms_peak.best_molecular_formula_candidate
                    
                    classes =  [mf.class_label]
                    
                    for atom in mf.atoms:
                        
                        all_used_atoms.add(atom)

                else: 

                    classes = []
                    
                    for mf in ms_peak:
                        
                        classes.append(mf.class_label)
                        
                        for atom in mf.atoms:
                             
                             all_used_atoms.add(atom)

                for classe in classes:
                    
                    if classe in self._ms_grouped_class.keys():

                        self._ms_grouped_class.get(classe).append(ms_peak)
                    
                    else:     

                        self._ms_grouped_class[classe] = [ms_peak]

        self.all_identified_atoms = sorted(all_used_atoms, key=sort_atoms_method)

        if not check_assign:

            raise Exception(&#34;No molecular formula associated with any mspeak objects&#34;)
    

    def __len__(self):
        
        return len(self._ms_grouped_class)
        
    def __getitem__(self, classe):
        
        return self._ms_grouped_class.get(classe)

    def __iter__(self):

         return iter(self._ms_grouped_class) 

    def get_classes(self, threshold_perc=1, isotopologue=True):
        
        classes = list()
        for classe in self.keys():
            if classe != Labels.unassigned:
                if self.abundance_count_percentile(classe) &gt; threshold_perc:
                    
                    if classe != Labels.unassigned:
                        # access first molecular formula inside the first ms peak and check isotopologue
                        if not isotopologue and self.get(classe)[0][0].is_isotopologue: continue
                    
                    classes.append(classe)
        #TODO sort classes chemically here too
        return classes
        
    def molecular_formula_string(self, classe,):

        if self.choose_mf:
            return [mspeak.best_molecular_formula_candidate for mspeak in self[classe]]
        else:
            return [mf for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]

    def molecular_formula(self, classe,):

        if self.choose_mf:
            return [mspeak.best_molecular_formula_candidate for mspeak in self[classe]]
        else:
            return [mf for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]
            
    def carbon_number(self, classe):

        if self.choose_mf:
            return [mspeak.best_molecular_formula_candidate.get(&#34;C&#34;) for mspeak in self[classe]]
        else:
            return [mf.get(&#39;C&#39;) for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]

    def atom_count(self, atom, classe):
        if self.choose_mf:
            return [mspeak.best_molecular_formula_candidate.get(atom) for mspeak in self[classe]]
        else:    
            return [mf.get(atom) for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]

    def dbe(self, classe):
        if self.choose_mf:
            return [mspeak.best_molecular_formula_candidate.dbe for mspeak in self[classe]]
        else:    
            return [mf.dbe for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]
    
    def atoms_ratio(self, classe, numerator, denominator):

        return [mf.get(numerator)/mf.get(denominator) for mf in self.molecular_formula(classe)]
       
    def mz_exp(self, classe):
        
        if self.choose_mf or classe == Labels.unassigned:
            
            return [mspeak.mz_exp for mspeak in self[classe]]
        
        else:
            
            return [mspeak.mz_exp for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]
    
    def abundance(self, classe):

        if self.choose_mf or classe == Labels.unassigned:
            
            return [mspeak.abundance for mspeak in self[classe]]
        
        else:
            
            return [mspeak.abundance for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]

    def mz_error(self, classe):

        if classe != Labels.unassigned:
            
            if self.choose_mf:
                
                return [mspeak.best_molecular_formula_candidate.mz_error for mspeak in self[classe]]
            
            else:
                
                return [mf.mz_error for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]
    
    def mz_calc(self, classe):
        
        if self.choose_mf:
            
            return [mspeak.best_molecular_formula_candidate.mz_calc for mspeak in self[classe]]
        
        else:
            
            return [mf.mz_calc for mspeak in self[classe] for mf in mspeak if mf.class_label == classe] 

    def peaks_count_percentile(self, classe):

        return (len(self[classe])/self.total_peaks)*100

    def abundance_count_percentile(self, classe):

        return (sum([mspeak.abundance for mspeak in self[classe]])/self.sum_abundance)*100

    def mz_exp_assigned(self):

        classes = self.keys()

        return [mspeak.mz_exp for classe in classes for mspeak in self[classe] if classe != Labels.unassigned]
    
    def abundance_assigned(self):

        classes = self.keys()
            
        return [mspeak.abundance for classe in classes for mspeak in self[classe] if classe != Labels.unassigned]

    def mz_exp_all(self):
        
        classes = self.keys()
        
        return flatten_list([self.mz_exp(classe) for classe in classes if classe != Labels.unassigned])
    
    def mz_error_all(self):
        
        classes = self.keys()
        
        return flatten_list([self.mz_error(classe) for classe in classes if classe != Labels.unassigned])
        
    def carbon_number_all(self):

        classes = self.keys()
            
        return flatten_list([self.carbon_number(classe) for classe in classes if classe != Labels.unassigned])

    def dbe_all(self):

        classes = self.keys()
            
        return flatten_list([self.dbe(classe) for classe in classes if classe != Labels.unassigned])

    def atoms_ratio_all(self, numerator, denominator):

        classes = self.keys()
            
        return flatten_list([self.atoms_ratio(classe, numerator, denominator) for classe in classes if classe != Labels.unassigned])

    def to_dataframe(self, incluse_isotopologue=False, abundance_perc_threshold=5, include_unassigned=False):
        
        from pandas import DataFrame
        
        columns_labels = [&#39;mz&#39;, &#39;calibrated_mz&#39;, &#39;calculated_m_z&#39;, &#39;abundance&#39;,
                                &#39;resolving_power&#39;, &#39;sn&#39;, &#39;ion_charge&#39;, &#39;mass_error&#39;,
                                &#39;DBE&#39;, &#39;class&#39;, &#39;HC&#39;, &#39;OC&#39;, &#39;ion_type&#39;,&#39;is_isotopologue&#39;,
                                &#39;class_abundance&#39;, &#39;class_count&#39;]

        dict_data_list = []

        for classe, list_mspeaks in self.items():

            percent_abundance = self.abundance_count_percentile(classe)
            
            #ignores low abundant classes
            if abundance_perc_threshold &lt; abundance_perc_threshold: continue
                
            peaks_count_percentile = self.peaks_count_percentile(classe)

            for ms_peak in list_mspeaks:
                 
                if ms_peak.is_assigned:
                    
                    for m_formula in ms_peak:
                        
                        #ignores isotopologues
                        if not incluse_isotopologue and m_formula.is_isotopologue: continue
                        
                        formula_dict = m_formula.to_dict()

                        dict_result = {&#39;mz&#39;:  ms_peak._mz_exp,
                                &#39;calibrated_mz&#39;: ms_peak.mz_exp,
                                &#39;calculated_mz&#39;: m_formula.mz_calc,
                                &#39;abundance&#39;: ms_peak.abundance,
                                &#39;resolving_power&#39;: ms_peak.resolving_power,
                                &#39;sn&#39;:  ms_peak.signal_to_noise,
                                &#39;ion_charge&#39;: ms_peak.ion_charge,
                                &#39;mass_error&#39;: m_formula.mz_error,
                                &#39;DBE&#39;:  m_formula.dbe,
                                &#39;class&#39;: classe,
                                &#39;HC&#39;:  m_formula.H_C,
                                &#39;OC&#39;:  m_formula.O_C,
                                &#39;ion_type&#39;: str(m_formula.ion_type.lower().encode(&#39;utf-8&#39;)),
                                &#39;is_isotopologue&#39;: int(m_formula.is_isotopologue),
                                &#39;class_abundance&#39;: percent_abundance,
                                &#39;class_count&#39;: peaks_count_percentile
                                }
                        
                        for atom in formula_dict.keys():
                        
                           dict_result[atom] = formula_dict.get(atom)

                    dict_data_list.append(dict_result)

                else:

                    if not include_unassigned: continue

                    dict_result = {&#39;mz&#39;:  ms_peak._mz_exp,
                                &#39;calibrated_mz&#39;: ms_peak.mz_exp,
                                &#39;abundance&#39;: ms_peak.abundance,
                                &#39;resolving_power&#39;: ms_peak.resolving_power,
                                &#39;sn&#39;:  ms_peak.signal_to_noise,
                                &#39;ion_charge&#39;: ms_peak.ion_charge,
                                &#39;class&#39;: classe,
                                &#39;class_abundance&#39;: percent_abundance,
                                &#39;class_count&#39;: percent_abundance
                                }
                
                    dict_data_list.append(dict_result)                

        columns = columns_labels + self.all_identified_atoms

        return DataFrame(dict_data_list, columns=columns)
     
    def plot_ms_assigned_unassigned(self, assigned_color= &#39;b&#39;, unassigned_color = &#39;r&#39;):
        
        mz_assigned = self.mz_exp_assigned()
        abundance_assigned = self.abundance_assigned()
    
        mz_not_assigned = self.mz_exp(Labels.unassigned)
        abundance_not_assigned = self.abundance(Labels.unassigned)
        
        ax = plt.gca()

        for plot_obj in ax.stem(mz_assigned,abundance_assigned, linefmt=&#39;-&#39;,  markerfmt=&#34; &#34;, use_line_collection =True, label=&#34;Assigned&#34;):
        
            plt.setp(plot_obj, &#39;color&#39;, assigned_color, &#39;linewidth&#39;, 2)
        
        for plot_obj in ax.stem(mz_not_assigned, abundance_not_assigned, linefmt=&#39;-&#39;, markerfmt=&#34; &#34;,  use_line_collection =True,label=&#34;Unassigned&#34;):
        
            plt.setp(plot_obj, &#39;color&#39;, unassigned_color, &#39;linewidth&#39;, 2)
        
        ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
        ax.set_ylabel(&#39;Abundance&#39;, fontsize=12)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

        ax.axes.spines[&#39;top&#39;].set_visible(False)
        ax.axes.spines[&#39;right&#39;].set_visible(False)

        ax.get_yaxis().set_visible(False)
        ax.spines[&#39;left&#39;].set_visible(False)
        plt.legend()
        return ax    

    def plot_mz_error(self, color= &#39;g&#39;):
        
        ax = plt.gca()

        mz_assigned = self.mz_exp_all()
        mz_error= self.mz_error_all()
        
        ax.scatter( mz_assigned, mz_error, c=color)
        
        ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
        ax.set_ylabel(&#39;Error (ppm)&#39;, fontsize=12)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

        ax.axes.spines[&#39;top&#39;].set_visible(True)
        ax.axes.spines[&#39;right&#39;].set_visible(True)

        ax.get_yaxis().set_visible(True)
        ax.spines[&#39;left&#39;].set_visible(True)

        ax.set_xlim(self.min_max_mz)
        ax.set_ylim(self.min_ppm_error , self.max_ppm_error)
    
        return ax

    def plot_mz_error_class(self, classe, color= &#39;g&#39;):
        
        if classe != Labels.unassigned:
            ax = plt.gca()
            
            abun_perc = self.abundance_count_percentile(classe)
            mz_assigned = self.mz_exp(classe)
            mz_error= self.mz_error(classe)
            
            ax.scatter( mz_assigned, mz_error, c=color)
            
            title = &#34;%s, %.2f %%&#34; % (classe, abun_perc)
            ax.set_title(title)
            ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
            ax.set_ylabel(&#39;Error (ppm)&#39;, fontsize=12)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

            ax.axes.spines[&#39;top&#39;].set_visible(True)
            ax.axes.spines[&#39;right&#39;].set_visible(True)

            ax.get_yaxis().set_visible(True)
            ax.spines[&#39;left&#39;].set_visible(True)

            ax.set_xlim(self.min_max_mz)
            ax.set_ylim(self.min_ppm_error , self.max_ppm_error)
        
            return ax   
            
    def plot_ms_class(self, classe, color= &#39;g&#39;):
        
        if classe != Labels.unassigned:
            ax = plt.gca()
            
            abun_perc = self.abundance_count_percentile(classe)
            mz_assigned = self.mz_exp(classe)
            abundance_assigned= self.abundance(classe)

            for plot_obj in ax.stem( mz_assigned, abundance_assigned, linefmt=&#39;-&#39;,  markerfmt=&#34; &#34;, use_line_collection =True):
            
                plt.setp(plot_obj, &#39;color&#39;, color, &#39;linewidth&#39;, 2)
            
            title = &#34;%s, %.2f %%&#34; % (classe, abun_perc)
            ax.set_title(title)
            ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
            ax.set_ylabel(&#39;Abundance&#39;, fontsize=12)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

            ax.axes.spines[&#39;top&#39;].set_visible(False)
            ax.axes.spines[&#39;right&#39;].set_visible(False)

            ax.get_yaxis().set_visible(False)
            ax.spines[&#39;left&#39;].set_visible(False)

            ax.set_xlim(self.min_max_mz)
            ax.set_ylim(self.min_max_abundance)
        
            return ax

    def plot_van_krevelen(self, classe, max_hc=2.5, max_oc=2, ticks_number=5, color=&#34;jet&#34;):
        
        if classe != Labels.unassigned:

            # get data 
            abun_perc = self.abundance_count_percentile(classe)
            hc = self.atoms_ratio(classe, &#34;H&#34;, &#34;C&#34;) 
            oc = self.atoms_ratio(classe, &#34;O&#34;, &#34;C&#34;) 
            abundance = self.abundance(classe)
            
            #plot data
            ax = plt.gca()

            ax.scatter(oc, hc, c=abundance, alpha=0.5, cmap=color)

            #ax.scatter(carbon_number, dbe, c=color, alpha=0.5)
            
            title = &#34;%s, %.2f %%&#34; % (classe, abun_perc)
            ax.set_title(title)
            ax.set_xlabel(&#34;O/C&#34;, fontsize=16)
            ax.set_ylabel(&#39;H/C&#39;, fontsize=16)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=18)
            ax.set_xticks(linspace(0, max_oc, ticks_number, endpoint=True))
            ax.set_yticks(linspace(0, max_hc, ticks_number, endpoint=True))

            # returns matplot axes obj and the class percentile of the relative abundance 
            
            return ax, abun_perc 
            
    def plot_dbe_vs_carbon_number(self, classe, max_c=50, max_dbe=40, dbe_incr=5, c_incr=10, color=&#34;jet&#34;):
        
        if classe != Labels.unassigned:

            # get data 
            abun_perc = self.abundance_count_percentile(classe)
            carbon_number = self.carbon_number(classe)
            dbe = self.dbe(classe)
            abundance = self.abundance(classe)
            
            #plot data
            ax = plt.gca()

            ax.scatter(carbon_number, dbe, c=abundance, alpha=0.5, cmap=color)

            #ax.scatter(carbon_number, dbe, c=color, alpha=0.5)
            
            title = &#34;%s, %.2f %%&#34; % (classe, abun_perc)
            ax.set_title(title)
            ax.set_xlabel(&#34;Carbon number&#34;, fontsize=16)
            ax.set_ylabel(&#39;DBE&#39;, fontsize=16)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=18)
            ax.set_xticks(range(0, max_c, c_incr))
            ax.set_yticks(range(0, max_dbe, dbe_incr))

            # returns matplot axes obj and the class percentile of the relative abundance 
            
            return ax, abun_perc </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="corems.molecular_id.factory.classification.flatten_list"><code class="name flex">
<span>def <span class="ident">flatten_list</span></span>(<span>l)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">flatten_list = lambda l: [item for sublist in l for item in sublist]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification"><code class="flex name class">
<span>class <span class="ident">HeteroatomsClassification</span></span>
<span>(</span><span>mass_spectrum, choose_molecular_formula=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Group mass spectrum data by heteroatom classes (Nn, Oo, Ss, NnOo, NnSs, etc..)</p>
<p>class obj behaves as a dictionary of classes and return a list of ms_peak obj</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeteroatomsClassification(Mapping):
    
    &#39;&#39;&#39;Group mass spectrum data by heteroatom classes (Nn, Oo, Ss, NnOo, NnSs, etc..)
        
       class obj behaves as a dictionary of classes and return a list of ms_peak obj

    &#39;&#39;&#39;
    
    def __init__(self, mass_spectrum, choose_molecular_formula=True):

        def sort_atoms_method( atom):
            
            return [Atoms.atoms_order.index(atom)]

        self._ms_grouped_class = dict()
        
        self.choose_mf = choose_molecular_formula
        
        #mapping for ms peaks without any molecular formula associated
        self._ms_grouped_class[Labels.unassigned] = list()

        self.total_peaks = 0

        self.sum_abundance = 0

        self.min_max_mz = (mass_spectrum.min_mz_exp, mass_spectrum.max_mz_exp)

        self.min_max_abundance = (mass_spectrum.min_abundance, mass_spectrum.max_abundance)

        self.min_ppm_error = mass_spectrum.molecular_search_settings.min_ppm_error 

        self.max_ppm_error = mass_spectrum.molecular_search_settings.max_ppm_error

        check_assign = False

        all_used_atoms = set()

        for ms_peak in mass_spectrum:
            
            self.total_peaks += 1

            self.sum_abundance += ms_peak.abundance

            if not ms_peak.is_assigned:

                self._ms_grouped_class.get(Labels.unassigned).append(ms_peak)
                
            else:    
                
                check_assign = True    

                if choose_molecular_formula:
                    
                    mf = ms_peak.best_molecular_formula_candidate
                    
                    classes =  [mf.class_label]
                    
                    for atom in mf.atoms:
                        
                        all_used_atoms.add(atom)

                else: 

                    classes = []
                    
                    for mf in ms_peak:
                        
                        classes.append(mf.class_label)
                        
                        for atom in mf.atoms:
                             
                             all_used_atoms.add(atom)

                for classe in classes:
                    
                    if classe in self._ms_grouped_class.keys():

                        self._ms_grouped_class.get(classe).append(ms_peak)
                    
                    else:     

                        self._ms_grouped_class[classe] = [ms_peak]

        self.all_identified_atoms = sorted(all_used_atoms, key=sort_atoms_method)

        if not check_assign:

            raise Exception(&#34;No molecular formula associated with any mspeak objects&#34;)
    

    def __len__(self):
        
        return len(self._ms_grouped_class)
        
    def __getitem__(self, classe):
        
        return self._ms_grouped_class.get(classe)

    def __iter__(self):

         return iter(self._ms_grouped_class) 

    def get_classes(self, threshold_perc=1, isotopologue=True):
        
        classes = list()
        for classe in self.keys():
            if classe != Labels.unassigned:
                if self.abundance_count_percentile(classe) &gt; threshold_perc:
                    
                    if classe != Labels.unassigned:
                        # access first molecular formula inside the first ms peak and check isotopologue
                        if not isotopologue and self.get(classe)[0][0].is_isotopologue: continue
                    
                    classes.append(classe)
        #TODO sort classes chemically here too
        return classes
        
    def molecular_formula_string(self, classe,):

        if self.choose_mf:
            return [mspeak.best_molecular_formula_candidate for mspeak in self[classe]]
        else:
            return [mf for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]

    def molecular_formula(self, classe,):

        if self.choose_mf:
            return [mspeak.best_molecular_formula_candidate for mspeak in self[classe]]
        else:
            return [mf for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]
            
    def carbon_number(self, classe):

        if self.choose_mf:
            return [mspeak.best_molecular_formula_candidate.get(&#34;C&#34;) for mspeak in self[classe]]
        else:
            return [mf.get(&#39;C&#39;) for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]

    def atom_count(self, atom, classe):
        if self.choose_mf:
            return [mspeak.best_molecular_formula_candidate.get(atom) for mspeak in self[classe]]
        else:    
            return [mf.get(atom) for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]

    def dbe(self, classe):
        if self.choose_mf:
            return [mspeak.best_molecular_formula_candidate.dbe for mspeak in self[classe]]
        else:    
            return [mf.dbe for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]
    
    def atoms_ratio(self, classe, numerator, denominator):

        return [mf.get(numerator)/mf.get(denominator) for mf in self.molecular_formula(classe)]
       
    def mz_exp(self, classe):
        
        if self.choose_mf or classe == Labels.unassigned:
            
            return [mspeak.mz_exp for mspeak in self[classe]]
        
        else:
            
            return [mspeak.mz_exp for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]
    
    def abundance(self, classe):

        if self.choose_mf or classe == Labels.unassigned:
            
            return [mspeak.abundance for mspeak in self[classe]]
        
        else:
            
            return [mspeak.abundance for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]

    def mz_error(self, classe):

        if classe != Labels.unassigned:
            
            if self.choose_mf:
                
                return [mspeak.best_molecular_formula_candidate.mz_error for mspeak in self[classe]]
            
            else:
                
                return [mf.mz_error for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]
    
    def mz_calc(self, classe):
        
        if self.choose_mf:
            
            return [mspeak.best_molecular_formula_candidate.mz_calc for mspeak in self[classe]]
        
        else:
            
            return [mf.mz_calc for mspeak in self[classe] for mf in mspeak if mf.class_label == classe] 

    def peaks_count_percentile(self, classe):

        return (len(self[classe])/self.total_peaks)*100

    def abundance_count_percentile(self, classe):

        return (sum([mspeak.abundance for mspeak in self[classe]])/self.sum_abundance)*100

    def mz_exp_assigned(self):

        classes = self.keys()

        return [mspeak.mz_exp for classe in classes for mspeak in self[classe] if classe != Labels.unassigned]
    
    def abundance_assigned(self):

        classes = self.keys()
            
        return [mspeak.abundance for classe in classes for mspeak in self[classe] if classe != Labels.unassigned]

    def mz_exp_all(self):
        
        classes = self.keys()
        
        return flatten_list([self.mz_exp(classe) for classe in classes if classe != Labels.unassigned])
    
    def mz_error_all(self):
        
        classes = self.keys()
        
        return flatten_list([self.mz_error(classe) for classe in classes if classe != Labels.unassigned])
        
    def carbon_number_all(self):

        classes = self.keys()
            
        return flatten_list([self.carbon_number(classe) for classe in classes if classe != Labels.unassigned])

    def dbe_all(self):

        classes = self.keys()
            
        return flatten_list([self.dbe(classe) for classe in classes if classe != Labels.unassigned])

    def atoms_ratio_all(self, numerator, denominator):

        classes = self.keys()
            
        return flatten_list([self.atoms_ratio(classe, numerator, denominator) for classe in classes if classe != Labels.unassigned])

    def to_dataframe(self, incluse_isotopologue=False, abundance_perc_threshold=5, include_unassigned=False):
        
        from pandas import DataFrame
        
        columns_labels = [&#39;mz&#39;, &#39;calibrated_mz&#39;, &#39;calculated_m_z&#39;, &#39;abundance&#39;,
                                &#39;resolving_power&#39;, &#39;sn&#39;, &#39;ion_charge&#39;, &#39;mass_error&#39;,
                                &#39;DBE&#39;, &#39;class&#39;, &#39;HC&#39;, &#39;OC&#39;, &#39;ion_type&#39;,&#39;is_isotopologue&#39;,
                                &#39;class_abundance&#39;, &#39;class_count&#39;]

        dict_data_list = []

        for classe, list_mspeaks in self.items():

            percent_abundance = self.abundance_count_percentile(classe)
            
            #ignores low abundant classes
            if abundance_perc_threshold &lt; abundance_perc_threshold: continue
                
            peaks_count_percentile = self.peaks_count_percentile(classe)

            for ms_peak in list_mspeaks:
                 
                if ms_peak.is_assigned:
                    
                    for m_formula in ms_peak:
                        
                        #ignores isotopologues
                        if not incluse_isotopologue and m_formula.is_isotopologue: continue
                        
                        formula_dict = m_formula.to_dict()

                        dict_result = {&#39;mz&#39;:  ms_peak._mz_exp,
                                &#39;calibrated_mz&#39;: ms_peak.mz_exp,
                                &#39;calculated_mz&#39;: m_formula.mz_calc,
                                &#39;abundance&#39;: ms_peak.abundance,
                                &#39;resolving_power&#39;: ms_peak.resolving_power,
                                &#39;sn&#39;:  ms_peak.signal_to_noise,
                                &#39;ion_charge&#39;: ms_peak.ion_charge,
                                &#39;mass_error&#39;: m_formula.mz_error,
                                &#39;DBE&#39;:  m_formula.dbe,
                                &#39;class&#39;: classe,
                                &#39;HC&#39;:  m_formula.H_C,
                                &#39;OC&#39;:  m_formula.O_C,
                                &#39;ion_type&#39;: str(m_formula.ion_type.lower().encode(&#39;utf-8&#39;)),
                                &#39;is_isotopologue&#39;: int(m_formula.is_isotopologue),
                                &#39;class_abundance&#39;: percent_abundance,
                                &#39;class_count&#39;: peaks_count_percentile
                                }
                        
                        for atom in formula_dict.keys():
                        
                           dict_result[atom] = formula_dict.get(atom)

                    dict_data_list.append(dict_result)

                else:

                    if not include_unassigned: continue

                    dict_result = {&#39;mz&#39;:  ms_peak._mz_exp,
                                &#39;calibrated_mz&#39;: ms_peak.mz_exp,
                                &#39;abundance&#39;: ms_peak.abundance,
                                &#39;resolving_power&#39;: ms_peak.resolving_power,
                                &#39;sn&#39;:  ms_peak.signal_to_noise,
                                &#39;ion_charge&#39;: ms_peak.ion_charge,
                                &#39;class&#39;: classe,
                                &#39;class_abundance&#39;: percent_abundance,
                                &#39;class_count&#39;: percent_abundance
                                }
                
                    dict_data_list.append(dict_result)                

        columns = columns_labels + self.all_identified_atoms

        return DataFrame(dict_data_list, columns=columns)
     
    def plot_ms_assigned_unassigned(self, assigned_color= &#39;b&#39;, unassigned_color = &#39;r&#39;):
        
        mz_assigned = self.mz_exp_assigned()
        abundance_assigned = self.abundance_assigned()
    
        mz_not_assigned = self.mz_exp(Labels.unassigned)
        abundance_not_assigned = self.abundance(Labels.unassigned)
        
        ax = plt.gca()

        for plot_obj in ax.stem(mz_assigned,abundance_assigned, linefmt=&#39;-&#39;,  markerfmt=&#34; &#34;, use_line_collection =True, label=&#34;Assigned&#34;):
        
            plt.setp(plot_obj, &#39;color&#39;, assigned_color, &#39;linewidth&#39;, 2)
        
        for plot_obj in ax.stem(mz_not_assigned, abundance_not_assigned, linefmt=&#39;-&#39;, markerfmt=&#34; &#34;,  use_line_collection =True,label=&#34;Unassigned&#34;):
        
            plt.setp(plot_obj, &#39;color&#39;, unassigned_color, &#39;linewidth&#39;, 2)
        
        ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
        ax.set_ylabel(&#39;Abundance&#39;, fontsize=12)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

        ax.axes.spines[&#39;top&#39;].set_visible(False)
        ax.axes.spines[&#39;right&#39;].set_visible(False)

        ax.get_yaxis().set_visible(False)
        ax.spines[&#39;left&#39;].set_visible(False)
        plt.legend()
        return ax    

    def plot_mz_error(self, color= &#39;g&#39;):
        
        ax = plt.gca()

        mz_assigned = self.mz_exp_all()
        mz_error= self.mz_error_all()
        
        ax.scatter( mz_assigned, mz_error, c=color)
        
        ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
        ax.set_ylabel(&#39;Error (ppm)&#39;, fontsize=12)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

        ax.axes.spines[&#39;top&#39;].set_visible(True)
        ax.axes.spines[&#39;right&#39;].set_visible(True)

        ax.get_yaxis().set_visible(True)
        ax.spines[&#39;left&#39;].set_visible(True)

        ax.set_xlim(self.min_max_mz)
        ax.set_ylim(self.min_ppm_error , self.max_ppm_error)
    
        return ax

    def plot_mz_error_class(self, classe, color= &#39;g&#39;):
        
        if classe != Labels.unassigned:
            ax = plt.gca()
            
            abun_perc = self.abundance_count_percentile(classe)
            mz_assigned = self.mz_exp(classe)
            mz_error= self.mz_error(classe)
            
            ax.scatter( mz_assigned, mz_error, c=color)
            
            title = &#34;%s, %.2f %%&#34; % (classe, abun_perc)
            ax.set_title(title)
            ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
            ax.set_ylabel(&#39;Error (ppm)&#39;, fontsize=12)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

            ax.axes.spines[&#39;top&#39;].set_visible(True)
            ax.axes.spines[&#39;right&#39;].set_visible(True)

            ax.get_yaxis().set_visible(True)
            ax.spines[&#39;left&#39;].set_visible(True)

            ax.set_xlim(self.min_max_mz)
            ax.set_ylim(self.min_ppm_error , self.max_ppm_error)
        
            return ax   
            
    def plot_ms_class(self, classe, color= &#39;g&#39;):
        
        if classe != Labels.unassigned:
            ax = plt.gca()
            
            abun_perc = self.abundance_count_percentile(classe)
            mz_assigned = self.mz_exp(classe)
            abundance_assigned= self.abundance(classe)

            for plot_obj in ax.stem( mz_assigned, abundance_assigned, linefmt=&#39;-&#39;,  markerfmt=&#34; &#34;, use_line_collection =True):
            
                plt.setp(plot_obj, &#39;color&#39;, color, &#39;linewidth&#39;, 2)
            
            title = &#34;%s, %.2f %%&#34; % (classe, abun_perc)
            ax.set_title(title)
            ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
            ax.set_ylabel(&#39;Abundance&#39;, fontsize=12)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

            ax.axes.spines[&#39;top&#39;].set_visible(False)
            ax.axes.spines[&#39;right&#39;].set_visible(False)

            ax.get_yaxis().set_visible(False)
            ax.spines[&#39;left&#39;].set_visible(False)

            ax.set_xlim(self.min_max_mz)
            ax.set_ylim(self.min_max_abundance)
        
            return ax

    def plot_van_krevelen(self, classe, max_hc=2.5, max_oc=2, ticks_number=5, color=&#34;jet&#34;):
        
        if classe != Labels.unassigned:

            # get data 
            abun_perc = self.abundance_count_percentile(classe)
            hc = self.atoms_ratio(classe, &#34;H&#34;, &#34;C&#34;) 
            oc = self.atoms_ratio(classe, &#34;O&#34;, &#34;C&#34;) 
            abundance = self.abundance(classe)
            
            #plot data
            ax = plt.gca()

            ax.scatter(oc, hc, c=abundance, alpha=0.5, cmap=color)

            #ax.scatter(carbon_number, dbe, c=color, alpha=0.5)
            
            title = &#34;%s, %.2f %%&#34; % (classe, abun_perc)
            ax.set_title(title)
            ax.set_xlabel(&#34;O/C&#34;, fontsize=16)
            ax.set_ylabel(&#39;H/C&#39;, fontsize=16)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=18)
            ax.set_xticks(linspace(0, max_oc, ticks_number, endpoint=True))
            ax.set_yticks(linspace(0, max_hc, ticks_number, endpoint=True))

            # returns matplot axes obj and the class percentile of the relative abundance 
            
            return ax, abun_perc 
            
    def plot_dbe_vs_carbon_number(self, classe, max_c=50, max_dbe=40, dbe_incr=5, c_incr=10, color=&#34;jet&#34;):
        
        if classe != Labels.unassigned:

            # get data 
            abun_perc = self.abundance_count_percentile(classe)
            carbon_number = self.carbon_number(classe)
            dbe = self.dbe(classe)
            abundance = self.abundance(classe)
            
            #plot data
            ax = plt.gca()

            ax.scatter(carbon_number, dbe, c=abundance, alpha=0.5, cmap=color)

            #ax.scatter(carbon_number, dbe, c=color, alpha=0.5)
            
            title = &#34;%s, %.2f %%&#34; % (classe, abun_perc)
            ax.set_title(title)
            ax.set_xlabel(&#34;Carbon number&#34;, fontsize=16)
            ax.set_ylabel(&#39;DBE&#39;, fontsize=16)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=18)
            ax.set_xticks(range(0, max_c, c_incr))
            ax.set_yticks(range(0, max_dbe, dbe_incr))

            # returns matplot axes obj and the class percentile of the relative abundance 
            
            return ax, abun_perc </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.abundance"><code class="name flex">
<span>def <span class="ident">abundance</span></span>(<span>self, classe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abundance(self, classe):

    if self.choose_mf or classe == Labels.unassigned:
        
        return [mspeak.abundance for mspeak in self[classe]]
    
    else:
        
        return [mspeak.abundance for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.abundance_assigned"><code class="name flex">
<span>def <span class="ident">abundance_assigned</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abundance_assigned(self):

    classes = self.keys()
        
    return [mspeak.abundance for classe in classes for mspeak in self[classe] if classe != Labels.unassigned]</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.abundance_count_percentile"><code class="name flex">
<span>def <span class="ident">abundance_count_percentile</span></span>(<span>self, classe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abundance_count_percentile(self, classe):

    return (sum([mspeak.abundance for mspeak in self[classe]])/self.sum_abundance)*100</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.atom_count"><code class="name flex">
<span>def <span class="ident">atom_count</span></span>(<span>self, atom, classe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atom_count(self, atom, classe):
    if self.choose_mf:
        return [mspeak.best_molecular_formula_candidate.get(atom) for mspeak in self[classe]]
    else:    
        return [mf.get(atom) for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.atoms_ratio"><code class="name flex">
<span>def <span class="ident">atoms_ratio</span></span>(<span>self, classe, numerator, denominator)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atoms_ratio(self, classe, numerator, denominator):

    return [mf.get(numerator)/mf.get(denominator) for mf in self.molecular_formula(classe)]</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.atoms_ratio_all"><code class="name flex">
<span>def <span class="ident">atoms_ratio_all</span></span>(<span>self, numerator, denominator)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atoms_ratio_all(self, numerator, denominator):

    classes = self.keys()
        
    return flatten_list([self.atoms_ratio(classe, numerator, denominator) for classe in classes if classe != Labels.unassigned])</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.carbon_number"><code class="name flex">
<span>def <span class="ident">carbon_number</span></span>(<span>self, classe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def carbon_number(self, classe):

    if self.choose_mf:
        return [mspeak.best_molecular_formula_candidate.get(&#34;C&#34;) for mspeak in self[classe]]
    else:
        return [mf.get(&#39;C&#39;) for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.carbon_number_all"><code class="name flex">
<span>def <span class="ident">carbon_number_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def carbon_number_all(self):

    classes = self.keys()
        
    return flatten_list([self.carbon_number(classe) for classe in classes if classe != Labels.unassigned])</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.dbe"><code class="name flex">
<span>def <span class="ident">dbe</span></span>(<span>self, classe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dbe(self, classe):
    if self.choose_mf:
        return [mspeak.best_molecular_formula_candidate.dbe for mspeak in self[classe]]
    else:    
        return [mf.dbe for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.dbe_all"><code class="name flex">
<span>def <span class="ident">dbe_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dbe_all(self):

    classes = self.keys()
        
    return flatten_list([self.dbe(classe) for classe in classes if classe != Labels.unassigned])</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.get_classes"><code class="name flex">
<span>def <span class="ident">get_classes</span></span>(<span>self, threshold_perc=1, isotopologue=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_classes(self, threshold_perc=1, isotopologue=True):
    
    classes = list()
    for classe in self.keys():
        if classe != Labels.unassigned:
            if self.abundance_count_percentile(classe) &gt; threshold_perc:
                
                if classe != Labels.unassigned:
                    # access first molecular formula inside the first ms peak and check isotopologue
                    if not isotopologue and self.get(classe)[0][0].is_isotopologue: continue
                
                classes.append(classe)
    #TODO sort classes chemically here too
    return classes</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.molecular_formula"><code class="name flex">
<span>def <span class="ident">molecular_formula</span></span>(<span>self, classe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def molecular_formula(self, classe,):

    if self.choose_mf:
        return [mspeak.best_molecular_formula_candidate for mspeak in self[classe]]
    else:
        return [mf for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.molecular_formula_string"><code class="name flex">
<span>def <span class="ident">molecular_formula_string</span></span>(<span>self, classe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def molecular_formula_string(self, classe,):

    if self.choose_mf:
        return [mspeak.best_molecular_formula_candidate for mspeak in self[classe]]
    else:
        return [mf for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.mz_calc"><code class="name flex">
<span>def <span class="ident">mz_calc</span></span>(<span>self, classe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mz_calc(self, classe):
    
    if self.choose_mf:
        
        return [mspeak.best_molecular_formula_candidate.mz_calc for mspeak in self[classe]]
    
    else:
        
        return [mf.mz_calc for mspeak in self[classe] for mf in mspeak if mf.class_label == classe] </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.mz_error"><code class="name flex">
<span>def <span class="ident">mz_error</span></span>(<span>self, classe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mz_error(self, classe):

    if classe != Labels.unassigned:
        
        if self.choose_mf:
            
            return [mspeak.best_molecular_formula_candidate.mz_error for mspeak in self[classe]]
        
        else:
            
            return [mf.mz_error for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.mz_error_all"><code class="name flex">
<span>def <span class="ident">mz_error_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mz_error_all(self):
    
    classes = self.keys()
    
    return flatten_list([self.mz_error(classe) for classe in classes if classe != Labels.unassigned])</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.mz_exp"><code class="name flex">
<span>def <span class="ident">mz_exp</span></span>(<span>self, classe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mz_exp(self, classe):
    
    if self.choose_mf or classe == Labels.unassigned:
        
        return [mspeak.mz_exp for mspeak in self[classe]]
    
    else:
        
        return [mspeak.mz_exp for mspeak in self[classe] for mf in mspeak if mf.class_label == classe]</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.mz_exp_all"><code class="name flex">
<span>def <span class="ident">mz_exp_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mz_exp_all(self):
    
    classes = self.keys()
    
    return flatten_list([self.mz_exp(classe) for classe in classes if classe != Labels.unassigned])</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.mz_exp_assigned"><code class="name flex">
<span>def <span class="ident">mz_exp_assigned</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mz_exp_assigned(self):

    classes = self.keys()

    return [mspeak.mz_exp for classe in classes for mspeak in self[classe] if classe != Labels.unassigned]</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.peaks_count_percentile"><code class="name flex">
<span>def <span class="ident">peaks_count_percentile</span></span>(<span>self, classe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peaks_count_percentile(self, classe):

    return (len(self[classe])/self.total_peaks)*100</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.plot_dbe_vs_carbon_number"><code class="name flex">
<span>def <span class="ident">plot_dbe_vs_carbon_number</span></span>(<span>self, classe, max_c=50, max_dbe=40, dbe_incr=5, c_incr=10, color='jet')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_dbe_vs_carbon_number(self, classe, max_c=50, max_dbe=40, dbe_incr=5, c_incr=10, color=&#34;jet&#34;):
    
    if classe != Labels.unassigned:

        # get data 
        abun_perc = self.abundance_count_percentile(classe)
        carbon_number = self.carbon_number(classe)
        dbe = self.dbe(classe)
        abundance = self.abundance(classe)
        
        #plot data
        ax = plt.gca()

        ax.scatter(carbon_number, dbe, c=abundance, alpha=0.5, cmap=color)

        #ax.scatter(carbon_number, dbe, c=color, alpha=0.5)
        
        title = &#34;%s, %.2f %%&#34; % (classe, abun_perc)
        ax.set_title(title)
        ax.set_xlabel(&#34;Carbon number&#34;, fontsize=16)
        ax.set_ylabel(&#39;DBE&#39;, fontsize=16)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=18)
        ax.set_xticks(range(0, max_c, c_incr))
        ax.set_yticks(range(0, max_dbe, dbe_incr))

        # returns matplot axes obj and the class percentile of the relative abundance 
        
        return ax, abun_perc </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.plot_ms_assigned_unassigned"><code class="name flex">
<span>def <span class="ident">plot_ms_assigned_unassigned</span></span>(<span>self, assigned_color='b', unassigned_color='r')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_ms_assigned_unassigned(self, assigned_color= &#39;b&#39;, unassigned_color = &#39;r&#39;):
    
    mz_assigned = self.mz_exp_assigned()
    abundance_assigned = self.abundance_assigned()

    mz_not_assigned = self.mz_exp(Labels.unassigned)
    abundance_not_assigned = self.abundance(Labels.unassigned)
    
    ax = plt.gca()

    for plot_obj in ax.stem(mz_assigned,abundance_assigned, linefmt=&#39;-&#39;,  markerfmt=&#34; &#34;, use_line_collection =True, label=&#34;Assigned&#34;):
    
        plt.setp(plot_obj, &#39;color&#39;, assigned_color, &#39;linewidth&#39;, 2)
    
    for plot_obj in ax.stem(mz_not_assigned, abundance_not_assigned, linefmt=&#39;-&#39;, markerfmt=&#34; &#34;,  use_line_collection =True,label=&#34;Unassigned&#34;):
    
        plt.setp(plot_obj, &#39;color&#39;, unassigned_color, &#39;linewidth&#39;, 2)
    
    ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
    ax.set_ylabel(&#39;Abundance&#39;, fontsize=12)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

    ax.axes.spines[&#39;top&#39;].set_visible(False)
    ax.axes.spines[&#39;right&#39;].set_visible(False)

    ax.get_yaxis().set_visible(False)
    ax.spines[&#39;left&#39;].set_visible(False)
    plt.legend()
    return ax    </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.plot_ms_class"><code class="name flex">
<span>def <span class="ident">plot_ms_class</span></span>(<span>self, classe, color='g')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_ms_class(self, classe, color= &#39;g&#39;):
    
    if classe != Labels.unassigned:
        ax = plt.gca()
        
        abun_perc = self.abundance_count_percentile(classe)
        mz_assigned = self.mz_exp(classe)
        abundance_assigned= self.abundance(classe)

        for plot_obj in ax.stem( mz_assigned, abundance_assigned, linefmt=&#39;-&#39;,  markerfmt=&#34; &#34;, use_line_collection =True):
        
            plt.setp(plot_obj, &#39;color&#39;, color, &#39;linewidth&#39;, 2)
        
        title = &#34;%s, %.2f %%&#34; % (classe, abun_perc)
        ax.set_title(title)
        ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
        ax.set_ylabel(&#39;Abundance&#39;, fontsize=12)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

        ax.axes.spines[&#39;top&#39;].set_visible(False)
        ax.axes.spines[&#39;right&#39;].set_visible(False)

        ax.get_yaxis().set_visible(False)
        ax.spines[&#39;left&#39;].set_visible(False)

        ax.set_xlim(self.min_max_mz)
        ax.set_ylim(self.min_max_abundance)
    
        return ax</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.plot_mz_error"><code class="name flex">
<span>def <span class="ident">plot_mz_error</span></span>(<span>self, color='g')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_mz_error(self, color= &#39;g&#39;):
    
    ax = plt.gca()

    mz_assigned = self.mz_exp_all()
    mz_error= self.mz_error_all()
    
    ax.scatter( mz_assigned, mz_error, c=color)
    
    ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
    ax.set_ylabel(&#39;Error (ppm)&#39;, fontsize=12)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

    ax.axes.spines[&#39;top&#39;].set_visible(True)
    ax.axes.spines[&#39;right&#39;].set_visible(True)

    ax.get_yaxis().set_visible(True)
    ax.spines[&#39;left&#39;].set_visible(True)

    ax.set_xlim(self.min_max_mz)
    ax.set_ylim(self.min_ppm_error , self.max_ppm_error)

    return ax</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.plot_mz_error_class"><code class="name flex">
<span>def <span class="ident">plot_mz_error_class</span></span>(<span>self, classe, color='g')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_mz_error_class(self, classe, color= &#39;g&#39;):
    
    if classe != Labels.unassigned:
        ax = plt.gca()
        
        abun_perc = self.abundance_count_percentile(classe)
        mz_assigned = self.mz_exp(classe)
        mz_error= self.mz_error(classe)
        
        ax.scatter( mz_assigned, mz_error, c=color)
        
        title = &#34;%s, %.2f %%&#34; % (classe, abun_perc)
        ax.set_title(title)
        ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
        ax.set_ylabel(&#39;Error (ppm)&#39;, fontsize=12)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

        ax.axes.spines[&#39;top&#39;].set_visible(True)
        ax.axes.spines[&#39;right&#39;].set_visible(True)

        ax.get_yaxis().set_visible(True)
        ax.spines[&#39;left&#39;].set_visible(True)

        ax.set_xlim(self.min_max_mz)
        ax.set_ylim(self.min_ppm_error , self.max_ppm_error)
    
        return ax   </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.plot_van_krevelen"><code class="name flex">
<span>def <span class="ident">plot_van_krevelen</span></span>(<span>self, classe, max_hc=2.5, max_oc=2, ticks_number=5, color='jet')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_van_krevelen(self, classe, max_hc=2.5, max_oc=2, ticks_number=5, color=&#34;jet&#34;):
    
    if classe != Labels.unassigned:

        # get data 
        abun_perc = self.abundance_count_percentile(classe)
        hc = self.atoms_ratio(classe, &#34;H&#34;, &#34;C&#34;) 
        oc = self.atoms_ratio(classe, &#34;O&#34;, &#34;C&#34;) 
        abundance = self.abundance(classe)
        
        #plot data
        ax = plt.gca()

        ax.scatter(oc, hc, c=abundance, alpha=0.5, cmap=color)

        #ax.scatter(carbon_number, dbe, c=color, alpha=0.5)
        
        title = &#34;%s, %.2f %%&#34; % (classe, abun_perc)
        ax.set_title(title)
        ax.set_xlabel(&#34;O/C&#34;, fontsize=16)
        ax.set_ylabel(&#39;H/C&#39;, fontsize=16)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=18)
        ax.set_xticks(linspace(0, max_oc, ticks_number, endpoint=True))
        ax.set_yticks(linspace(0, max_hc, ticks_number, endpoint=True))

        # returns matplot axes obj and the class percentile of the relative abundance 
        
        return ax, abun_perc </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.classification.HeteroatomsClassification.to_dataframe"><code class="name flex">
<span>def <span class="ident">to_dataframe</span></span>(<span>self, incluse_isotopologue=False, abundance_perc_threshold=5, include_unassigned=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dataframe(self, incluse_isotopologue=False, abundance_perc_threshold=5, include_unassigned=False):
    
    from pandas import DataFrame
    
    columns_labels = [&#39;mz&#39;, &#39;calibrated_mz&#39;, &#39;calculated_m_z&#39;, &#39;abundance&#39;,
                            &#39;resolving_power&#39;, &#39;sn&#39;, &#39;ion_charge&#39;, &#39;mass_error&#39;,
                            &#39;DBE&#39;, &#39;class&#39;, &#39;HC&#39;, &#39;OC&#39;, &#39;ion_type&#39;,&#39;is_isotopologue&#39;,
                            &#39;class_abundance&#39;, &#39;class_count&#39;]

    dict_data_list = []

    for classe, list_mspeaks in self.items():

        percent_abundance = self.abundance_count_percentile(classe)
        
        #ignores low abundant classes
        if abundance_perc_threshold &lt; abundance_perc_threshold: continue
            
        peaks_count_percentile = self.peaks_count_percentile(classe)

        for ms_peak in list_mspeaks:
             
            if ms_peak.is_assigned:
                
                for m_formula in ms_peak:
                    
                    #ignores isotopologues
                    if not incluse_isotopologue and m_formula.is_isotopologue: continue
                    
                    formula_dict = m_formula.to_dict()

                    dict_result = {&#39;mz&#39;:  ms_peak._mz_exp,
                            &#39;calibrated_mz&#39;: ms_peak.mz_exp,
                            &#39;calculated_mz&#39;: m_formula.mz_calc,
                            &#39;abundance&#39;: ms_peak.abundance,
                            &#39;resolving_power&#39;: ms_peak.resolving_power,
                            &#39;sn&#39;:  ms_peak.signal_to_noise,
                            &#39;ion_charge&#39;: ms_peak.ion_charge,
                            &#39;mass_error&#39;: m_formula.mz_error,
                            &#39;DBE&#39;:  m_formula.dbe,
                            &#39;class&#39;: classe,
                            &#39;HC&#39;:  m_formula.H_C,
                            &#39;OC&#39;:  m_formula.O_C,
                            &#39;ion_type&#39;: str(m_formula.ion_type.lower().encode(&#39;utf-8&#39;)),
                            &#39;is_isotopologue&#39;: int(m_formula.is_isotopologue),
                            &#39;class_abundance&#39;: percent_abundance,
                            &#39;class_count&#39;: peaks_count_percentile
                            }
                    
                    for atom in formula_dict.keys():
                    
                       dict_result[atom] = formula_dict.get(atom)

                dict_data_list.append(dict_result)

            else:

                if not include_unassigned: continue

                dict_result = {&#39;mz&#39;:  ms_peak._mz_exp,
                            &#39;calibrated_mz&#39;: ms_peak.mz_exp,
                            &#39;abundance&#39;: ms_peak.abundance,
                            &#39;resolving_power&#39;: ms_peak.resolving_power,
                            &#39;sn&#39;:  ms_peak.signal_to_noise,
                            &#39;ion_charge&#39;: ms_peak.ion_charge,
                            &#39;class&#39;: classe,
                            &#39;class_abundance&#39;: percent_abundance,
                            &#39;class_count&#39;: percent_abundance
                            }
            
                dict_data_list.append(dict_result)                

    columns = columns_labels + self.all_identified_atoms

    return DataFrame(dict_data_list, columns=columns)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.molecular_id.factory" href="index.html">corems.molecular_id.factory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="corems.molecular_id.factory.classification.flatten_list" href="#corems.molecular_id.factory.classification.flatten_list">flatten_list</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification" href="#corems.molecular_id.factory.classification.HeteroatomsClassification">HeteroatomsClassification</a></code></h4>
<ul class="">
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.abundance" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.abundance">abundance</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.abundance_assigned" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.abundance_assigned">abundance_assigned</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.abundance_count_percentile" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.abundance_count_percentile">abundance_count_percentile</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.atom_count" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.atom_count">atom_count</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.atoms_ratio" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.atoms_ratio">atoms_ratio</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.atoms_ratio_all" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.atoms_ratio_all">atoms_ratio_all</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.carbon_number" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.carbon_number">carbon_number</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.carbon_number_all" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.carbon_number_all">carbon_number_all</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.dbe" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.dbe">dbe</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.dbe_all" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.dbe_all">dbe_all</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.get_classes" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.get_classes">get_classes</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.molecular_formula" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.molecular_formula">molecular_formula</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.molecular_formula_string" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.molecular_formula_string">molecular_formula_string</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.mz_calc" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.mz_calc">mz_calc</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.mz_error" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.mz_error">mz_error</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.mz_error_all" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.mz_error_all">mz_error_all</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.mz_exp" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.mz_exp">mz_exp</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.mz_exp_all" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.mz_exp_all">mz_exp_all</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.mz_exp_assigned" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.mz_exp_assigned">mz_exp_assigned</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.peaks_count_percentile" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.peaks_count_percentile">peaks_count_percentile</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.plot_dbe_vs_carbon_number" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.plot_dbe_vs_carbon_number">plot_dbe_vs_carbon_number</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.plot_ms_assigned_unassigned" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.plot_ms_assigned_unassigned">plot_ms_assigned_unassigned</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.plot_ms_class" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.plot_ms_class">plot_ms_class</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.plot_mz_error" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.plot_mz_error">plot_mz_error</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.plot_mz_error_class" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.plot_mz_error_class">plot_mz_error_class</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.plot_van_krevelen" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.plot_van_krevelen">plot_van_krevelen</a></code></li>
<li><code><a title="corems.molecular_id.factory.classification.HeteroatomsClassification.to_dataframe" href="#corems.molecular_id.factory.classification.HeteroatomsClassification.to_dataframe">to_dataframe</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>