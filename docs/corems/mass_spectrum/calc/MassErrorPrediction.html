<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.mass_spectrum.calc.MassErrorPrediction API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.mass_spectrum.calc.MassErrorPrediction</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__author__ = &#39;Yuri E. Corilo&#39;
__date__ = &#34;03/31/2020&#34;

from threading import Thread
from pandas import DataFrame
from numpy import hstack, inf, isnan, where, array
from tqdm import tqdm

class MassErrorPrediction(Thread):
    
    def __init__(self, mass_spectrum, mz_overlay=10, rp_increments=10000, base_line_target=0.01, max_interation=1000, interpolation=&#39;linear&#39;):
        
        Thread.__init__(self)
        
        self.mass_spectrum_obj = mass_spectrum

        self.mz_overlay = mz_overlay

        self.rp_increments = 10000

        self.base_line_target = 0.01 

        self.max_interation = 1000

        self.df = None

        self.interpolation = interpolation
    
    def run(self):
            
        self.df = self.calc_error_dist()

    def get_results(self):

        if not self.df:
            self.run()

        return self.df

    def calc_error_dist(self):
        
        results_list = []
        
        indexes_without_results = list(range(len(self.mass_spectrum_obj)))
        # loop trough mass spectrum

        for peak_obj_idx, peak_obj in enumerate(tqdm(self.mass_spectrum_obj)):
            
            # access ms peaks triplets ( peak_obj_idx -1, peak_obj_idx, and peak_obj_idx + 1)
            # check lower and upper boundaries to not excesses mass spectrum range
            
            if  peak_obj_idx != 0 and peak_obj_idx != len(self.mass_spectrum_obj)-1:
                
                # current peak_obj initialted in the loop expression
                # geting the peak on the left (previous_peak_obj) and the one in the right position (next_peak_obj)
                next_peak_obj = self.mass_spectrum_obj[peak_obj_idx + 1]
                previous_peak_obj = self.mass_spectrum_obj[peak_obj_idx - 1]
                
                # check mz range defined in max_mz variable and check if peaks have same nominal mz
                # keeping same mz for better plotting representation only, remove it for production
                if  peak_obj.nominal_mz_exp == next_peak_obj.nominal_mz_exp and peak_obj.nominal_mz_exp == previous_peak_obj.nominal_mz_exp:
                    
                    #simulate peak shape
                    sim_mz, sim_abun = peak_obj.gaussian(mz_overlay=self.mz_overlay)
                    #update_plot(sim_mz,sim_abun, 0.5)
                    
                    #simulate peak shape
                    next_sim_mz, next_sim_abun = next_peak_obj.gaussian(mz_overlay=self.mz_overlay)
                    #update_plot(next_sim_mz, next_sim_abun, 0.5)
                    
                    
                    #simulate peak shape
                    previous_sim_mz, previous_sim_abun = previous_peak_obj.gaussian(mz_overlay=self.mz_overlay)
                    #update_plot(previous_sim_mz,  previous_sim_abun, 0.5)
                    
                    sim_mz_domain,  summed_peaks_abun = self.sum_data( ((previous_sim_mz,previous_sim_abun),  (sim_mz,sim_abun), (next_sim_mz, next_sim_abun)) )
                    #update_plot(sim_mz_domain,summed_peaks_abun, 0.5)
                    
                    #sum simulated abundances 
                    #summed_peaks_abun = (sim_abun + next_sim_abun + previous_sim_abun) 
                    
                    #normalize abundances to 0-1
                    #summed_peaks_abun = summed_peaks_abun/(max(summed_peaks_abun))

                    #find appexes location (mz) and magnitude
                    mz_centroid, abund_centroid = self.find_peak_apex(sim_mz_domain,summed_peaks_abun)    

                    #find valley location (mz_min_valley) and magnitude (abund_min_valley)
                    mz_min_valley, abund_min_valley = self.find_peak_valley(sim_mz_domain, summed_peaks_abun)  

                    # clear delta_rp (global implementation) and store choose resolving power increments   
                    delta_rp = self.rp_increments
                    
                    # used to limited number of iterations
                    i = 0
                    j = 0
                    
                    # TODO: fit peak shape and decide best fit #gaussian, lorentz and voigt 
                    #plot_triplets(mz_centroid,abund_centroid, mz_min_valley, abund_min_valley, sim_mz_domain, summed_peaks_abun )
                    if len(mz_centroid) == 2 :
                            
                        while len(mz_centroid) &lt; 3 and i &lt;= self.max_interation:
                            
                            previous_sim_mz, previous_sim_abun = previous_peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)
                            
                            sim_mz, sim_abun = peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)
                            
                            next_sim_mz, next_sim_abun = next_peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)

                            sim_mz_domain,  summed_peaks_abun = self.sum_data( ((previous_sim_mz,previous_sim_abun),  (sim_mz,sim_abun), (next_sim_mz, next_sim_abun)) )
                            
                            #update_plot(sim_mz_domain,  summed_peaks_abun, 0.01)

                            mz_centroid, abund_centroid = self.find_peak_apex(sim_mz_domain,summed_peaks_abun)    

                            delta_rp += self.rp_increments
                            
                            i += 1

                        mz_min_valley, abund_min_valley = self.find_peak_valley(sim_mz_domain, summed_peaks_abun)      

                    if len(mz_centroid) == 3 and len(abund_min_valley) == 2:
                        # increase all three peak resolving power until both valley magnitude is bellow the defined target
                        # calculate peak shapes with the needed resolving power to have a baseline resolution for all peaks
                        # calculate mass difference (ppm) between original centroid and the new simulated peak. 
                        
                        while  abund_min_valley[0] &gt; self.base_line_target or abund_min_valley[1] &gt; self.base_line_target and j &lt;= self.max_interation:
                            
                            previous_sim_mz, previous_sim_abun = previous_peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)
                            
                            sim_mz, sim_abun = peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)
                            
                            next_sim_mz, next_sim_abun = next_peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)

                            sim_mz_domain,  summed_peaks_abun = self.sum_data( ((previous_sim_mz,previous_sim_abun),  (sim_mz,sim_abun), (next_sim_mz, next_sim_abun)) )
                            
                            #update_plot(sim_mz_domain,  summed_peaks_abun, 0.001)
                            
                            #summed_peaks_abun = (sim_abun + next_sim_abun + previous_sim_abun) 
                            
                            
                            #find appexes location (mz) and magnitude
                            mz_centroid, abund_centroid = self.find_peak_apex(sim_mz_domain,summed_peaks_abun)    
                            
                            #find valley location (mz_min_valley) and magnitude (abund_min_valley)
                            summed_peaks_abun = summed_peaks_abun/(summed_peaks_abun.max())
                            mz_min_valley, abund_min_valley = self.find_peak_valley(sim_mz_domain, summed_peaks_abun)  

                            if len(abund_min_valley) != 2:
                                break
                            
                            delta_rp += self.rp_increments
                            j += 1
                            
                            #plot_triplets(mz_centroid,abund_centroid, mz_min_valley, abund_min_valley, sim_mz_domain, summed_peaks_abun )
                        
                        
                        #plot_triplets(mz_centroid,abund_centroid, mz_min_valley, abund_min_valley, sim_mz_domain, summed_peaks_abun )

                        mass_shift_ppp = self.calc_error(mz_centroid[1], peak_obj.mz_exp, 1000000)
                        #delta_mz = mz_centroid[1] - peak_obj.mz_exp
                        height_shift_per = self.calc_error(abund_centroid[1], peak_obj.abundance, 100)
                        #excitation_amplitude = str(mass_spectrum_obj.filename.stem).split(&#34;ex&#34;)[1].split(&#34;pc&#34;)[0]
                        #ion_time = str(mass_spectrum_obj.filename.stem).split(&#34;0pt&#34;)[1].split(&#34;s&#34;)[0]
                        peak_obj.predicted_std = mass_shift_ppp
                        
                        results_list.append( {
                        &#34;ms_index_position&#34; : peak_obj_idx,
                        &#34;predicted_std&#34;: mass_shift_ppp,
                        &#34;mz_exp&#34;: peak_obj.mz_exp,
                        &#34;nominal_mz_exp&#34;: peak_obj.nominal_mz_exp,
                        &#34;predicted_mz&#34;: mz_centroid[1],
                        &#34;s2n&#34; : peak_obj.signal_to_noise,
                        &#34;peak_height&#34; : peak_obj.abundance,
                        &#34;predicted_peak_height&#34; : abund_centroid[1],
                        &#34;peak_height_error&#34; : height_shift_per,
                        &#34;resolving_power&#34; : peak_obj.resolving_power,
                        #&#34;excitation_amplitude&#34; : excitation_amplitude,
                        #&#34;ion_time&#34; : ion_time
                        })
                        
                        indexes_without_results.remove(peak_obj_idx)
                    #elif len(mz_centroid) == 3 and len(abund_min_valley) != 2:

        for peak_obj_idx in indexes_without_results:

            results_list.append( {
            &#34;ms_index_position&#34; : peak_obj_idx,
            &#34;mz_exp&#34;: self.mass_spectrum_obj[peak_obj_idx].mz_exp,
            &#34;nominal_mz_exp&#34;: self.mass_spectrum_obj[peak_obj_idx].nominal_mz_exp,
            &#34;s2n&#34; : self.mass_spectrum_obj[peak_obj_idx].signal_to_noise,
            &#34;peak_height&#34; : self.mass_spectrum_obj[peak_obj_idx].abundance,
            &#34;resolving_power&#34; : self.mass_spectrum_obj[peak_obj_idx].resolving_power,
            #&#34;excitation_amplitude&#34; : excitation_amplitude,
            #&#34;ion_time&#34; : ion_time
            } )

        df = DataFrame(results_list).sort_values(&#34;mz_exp&#34;)
        
        df.interpolate(method =&#39;linear&#39;, limit_direction =&#39;backward&#39;,  inplace=True)
        df.interpolate(method =&#39;linear&#39;, limit_direction =&#39;forward&#39;,  inplace=True)

        #TODO improve interpolation for missing data
        #f1 = interpolate.interp1d(x1, y1, kind=&#39;quadratic&#39;,fill_value=&#34;extrapolate&#34;)

        
        for peak_obj_idx in indexes_without_results:

            predicted_std = df.loc[peak_obj_idx].predicted_std
            
            self.mass_spectrum_obj[peak_obj_idx].predicted_std = predicted_std

        return df

    def sum_data(self, tuple_mz_abun_list):

        all_mz = {}

        for mz_list, abun_list in tuple_mz_abun_list:
            
            for index, mz in enumerate(mz_list):

                abundance = abun_list[index]

                if mz in all_mz:
                    all_mz[mz] = all_mz[mz] + abundance    
                else: 
                    all_mz[mz] = abundance
        
        mz_all = []
        abun_all = []

        for mz in sorted (all_mz) : 
            mz_all.append(mz)
            abun_all.append(all_mz[mz])

        return array(mz_all), array(abun_all)    

    def calc_error(self, mass_ref, mass_sim, factor):

        return ((mass_ref-mass_sim)/mass_ref)*factor

    def find_peak_apex(self, mass, abund):

        dy = abund[1:] - abund[:-1]

        &#39;&#39;&#39;replaces nan for infinity&#39;&#39;&#39;
        indices_nan = where(isnan(abund))[0]

        if indices_nan.size:
            
            abund[indices_nan] = inf
            dy[where(isnan(dy))[0]] = inf

        indexes = where((hstack((dy, 0)) &lt; 0) &amp; (hstack((0, dy)) &gt; 0))[0]

        if indexes.size:
            
            return mass[indexes], abund[indexes]

    def find_peak_valley(self, mz, abund):

        dy = abund[1:] - abund[:-1]
        
        &#39;&#39;&#39;replaces nan for infinity&#39;&#39;&#39;
        indices_nan = where(isnan(abund))[0]
        
        if indices_nan.size:
            
            abund[indices_nan] = inf
            dy[where(isnan(dy))[0]] = inf
        
        indexes = where((hstack((dy, 0)) &gt; 0) &amp; (hstack((0, dy)) &lt; 0))[0]

        return mz[indexes], abund[indexes]    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction"><code class="flex name class">
<span>class <span class="ident">MassErrorPrediction</span></span>
<span>(</span><span>mass_spectrum, mz_overlay=10, rp_increments=10000, base_line_target=0.01, max_interation=1000, interpolation='linear')</span>
</code></dt>
<dd>
<div class="desc"><p>A class that represents a thread of control.</p>
<p>This class can be safely subclassed in a limited fashion. There are two ways
to specify the activity: by passing a callable object to the constructor, or
by overriding the run() method in a subclass.</p>
<p>This constructor should always be called with keyword arguments. Arguments are:</p>
<p><em>group</em> should be None; reserved for future extension when a ThreadGroup
class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the run()
method. Defaults to None, meaning nothing is called.</p>
<p><em>name</em> is the thread name. By default, a unique name is constructed of
the form "Thread-N" where N is a small decimal number.</p>
<p><em>args</em> is the argument tuple for the target invocation. Defaults to ().</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target
invocation. Defaults to {}.</p>
<p>If a subclass overrides the constructor, it must make sure to invoke
the base class constructor (Thread.<strong>init</strong>()) before doing anything
else to the thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MassErrorPrediction(Thread):
    
    def __init__(self, mass_spectrum, mz_overlay=10, rp_increments=10000, base_line_target=0.01, max_interation=1000, interpolation=&#39;linear&#39;):
        
        Thread.__init__(self)
        
        self.mass_spectrum_obj = mass_spectrum

        self.mz_overlay = mz_overlay

        self.rp_increments = 10000

        self.base_line_target = 0.01 

        self.max_interation = 1000

        self.df = None

        self.interpolation = interpolation
    
    def run(self):
            
        self.df = self.calc_error_dist()

    def get_results(self):

        if not self.df:
            self.run()

        return self.df

    def calc_error_dist(self):
        
        results_list = []
        
        indexes_without_results = list(range(len(self.mass_spectrum_obj)))
        # loop trough mass spectrum

        for peak_obj_idx, peak_obj in enumerate(tqdm(self.mass_spectrum_obj)):
            
            # access ms peaks triplets ( peak_obj_idx -1, peak_obj_idx, and peak_obj_idx + 1)
            # check lower and upper boundaries to not excesses mass spectrum range
            
            if  peak_obj_idx != 0 and peak_obj_idx != len(self.mass_spectrum_obj)-1:
                
                # current peak_obj initialted in the loop expression
                # geting the peak on the left (previous_peak_obj) and the one in the right position (next_peak_obj)
                next_peak_obj = self.mass_spectrum_obj[peak_obj_idx + 1]
                previous_peak_obj = self.mass_spectrum_obj[peak_obj_idx - 1]
                
                # check mz range defined in max_mz variable and check if peaks have same nominal mz
                # keeping same mz for better plotting representation only, remove it for production
                if  peak_obj.nominal_mz_exp == next_peak_obj.nominal_mz_exp and peak_obj.nominal_mz_exp == previous_peak_obj.nominal_mz_exp:
                    
                    #simulate peak shape
                    sim_mz, sim_abun = peak_obj.gaussian(mz_overlay=self.mz_overlay)
                    #update_plot(sim_mz,sim_abun, 0.5)
                    
                    #simulate peak shape
                    next_sim_mz, next_sim_abun = next_peak_obj.gaussian(mz_overlay=self.mz_overlay)
                    #update_plot(next_sim_mz, next_sim_abun, 0.5)
                    
                    
                    #simulate peak shape
                    previous_sim_mz, previous_sim_abun = previous_peak_obj.gaussian(mz_overlay=self.mz_overlay)
                    #update_plot(previous_sim_mz,  previous_sim_abun, 0.5)
                    
                    sim_mz_domain,  summed_peaks_abun = self.sum_data( ((previous_sim_mz,previous_sim_abun),  (sim_mz,sim_abun), (next_sim_mz, next_sim_abun)) )
                    #update_plot(sim_mz_domain,summed_peaks_abun, 0.5)
                    
                    #sum simulated abundances 
                    #summed_peaks_abun = (sim_abun + next_sim_abun + previous_sim_abun) 
                    
                    #normalize abundances to 0-1
                    #summed_peaks_abun = summed_peaks_abun/(max(summed_peaks_abun))

                    #find appexes location (mz) and magnitude
                    mz_centroid, abund_centroid = self.find_peak_apex(sim_mz_domain,summed_peaks_abun)    

                    #find valley location (mz_min_valley) and magnitude (abund_min_valley)
                    mz_min_valley, abund_min_valley = self.find_peak_valley(sim_mz_domain, summed_peaks_abun)  

                    # clear delta_rp (global implementation) and store choose resolving power increments   
                    delta_rp = self.rp_increments
                    
                    # used to limited number of iterations
                    i = 0
                    j = 0
                    
                    # TODO: fit peak shape and decide best fit #gaussian, lorentz and voigt 
                    #plot_triplets(mz_centroid,abund_centroid, mz_min_valley, abund_min_valley, sim_mz_domain, summed_peaks_abun )
                    if len(mz_centroid) == 2 :
                            
                        while len(mz_centroid) &lt; 3 and i &lt;= self.max_interation:
                            
                            previous_sim_mz, previous_sim_abun = previous_peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)
                            
                            sim_mz, sim_abun = peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)
                            
                            next_sim_mz, next_sim_abun = next_peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)

                            sim_mz_domain,  summed_peaks_abun = self.sum_data( ((previous_sim_mz,previous_sim_abun),  (sim_mz,sim_abun), (next_sim_mz, next_sim_abun)) )
                            
                            #update_plot(sim_mz_domain,  summed_peaks_abun, 0.01)

                            mz_centroid, abund_centroid = self.find_peak_apex(sim_mz_domain,summed_peaks_abun)    

                            delta_rp += self.rp_increments
                            
                            i += 1

                        mz_min_valley, abund_min_valley = self.find_peak_valley(sim_mz_domain, summed_peaks_abun)      

                    if len(mz_centroid) == 3 and len(abund_min_valley) == 2:
                        # increase all three peak resolving power until both valley magnitude is bellow the defined target
                        # calculate peak shapes with the needed resolving power to have a baseline resolution for all peaks
                        # calculate mass difference (ppm) between original centroid and the new simulated peak. 
                        
                        while  abund_min_valley[0] &gt; self.base_line_target or abund_min_valley[1] &gt; self.base_line_target and j &lt;= self.max_interation:
                            
                            previous_sim_mz, previous_sim_abun = previous_peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)
                            
                            sim_mz, sim_abun = peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)
                            
                            next_sim_mz, next_sim_abun = next_peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)

                            sim_mz_domain,  summed_peaks_abun = self.sum_data( ((previous_sim_mz,previous_sim_abun),  (sim_mz,sim_abun), (next_sim_mz, next_sim_abun)) )
                            
                            #update_plot(sim_mz_domain,  summed_peaks_abun, 0.001)
                            
                            #summed_peaks_abun = (sim_abun + next_sim_abun + previous_sim_abun) 
                            
                            
                            #find appexes location (mz) and magnitude
                            mz_centroid, abund_centroid = self.find_peak_apex(sim_mz_domain,summed_peaks_abun)    
                            
                            #find valley location (mz_min_valley) and magnitude (abund_min_valley)
                            summed_peaks_abun = summed_peaks_abun/(summed_peaks_abun.max())
                            mz_min_valley, abund_min_valley = self.find_peak_valley(sim_mz_domain, summed_peaks_abun)  

                            if len(abund_min_valley) != 2:
                                break
                            
                            delta_rp += self.rp_increments
                            j += 1
                            
                            #plot_triplets(mz_centroid,abund_centroid, mz_min_valley, abund_min_valley, sim_mz_domain, summed_peaks_abun )
                        
                        
                        #plot_triplets(mz_centroid,abund_centroid, mz_min_valley, abund_min_valley, sim_mz_domain, summed_peaks_abun )

                        mass_shift_ppp = self.calc_error(mz_centroid[1], peak_obj.mz_exp, 1000000)
                        #delta_mz = mz_centroid[1] - peak_obj.mz_exp
                        height_shift_per = self.calc_error(abund_centroid[1], peak_obj.abundance, 100)
                        #excitation_amplitude = str(mass_spectrum_obj.filename.stem).split(&#34;ex&#34;)[1].split(&#34;pc&#34;)[0]
                        #ion_time = str(mass_spectrum_obj.filename.stem).split(&#34;0pt&#34;)[1].split(&#34;s&#34;)[0]
                        peak_obj.predicted_std = mass_shift_ppp
                        
                        results_list.append( {
                        &#34;ms_index_position&#34; : peak_obj_idx,
                        &#34;predicted_std&#34;: mass_shift_ppp,
                        &#34;mz_exp&#34;: peak_obj.mz_exp,
                        &#34;nominal_mz_exp&#34;: peak_obj.nominal_mz_exp,
                        &#34;predicted_mz&#34;: mz_centroid[1],
                        &#34;s2n&#34; : peak_obj.signal_to_noise,
                        &#34;peak_height&#34; : peak_obj.abundance,
                        &#34;predicted_peak_height&#34; : abund_centroid[1],
                        &#34;peak_height_error&#34; : height_shift_per,
                        &#34;resolving_power&#34; : peak_obj.resolving_power,
                        #&#34;excitation_amplitude&#34; : excitation_amplitude,
                        #&#34;ion_time&#34; : ion_time
                        })
                        
                        indexes_without_results.remove(peak_obj_idx)
                    #elif len(mz_centroid) == 3 and len(abund_min_valley) != 2:

        for peak_obj_idx in indexes_without_results:

            results_list.append( {
            &#34;ms_index_position&#34; : peak_obj_idx,
            &#34;mz_exp&#34;: self.mass_spectrum_obj[peak_obj_idx].mz_exp,
            &#34;nominal_mz_exp&#34;: self.mass_spectrum_obj[peak_obj_idx].nominal_mz_exp,
            &#34;s2n&#34; : self.mass_spectrum_obj[peak_obj_idx].signal_to_noise,
            &#34;peak_height&#34; : self.mass_spectrum_obj[peak_obj_idx].abundance,
            &#34;resolving_power&#34; : self.mass_spectrum_obj[peak_obj_idx].resolving_power,
            #&#34;excitation_amplitude&#34; : excitation_amplitude,
            #&#34;ion_time&#34; : ion_time
            } )

        df = DataFrame(results_list).sort_values(&#34;mz_exp&#34;)
        
        df.interpolate(method =&#39;linear&#39;, limit_direction =&#39;backward&#39;,  inplace=True)
        df.interpolate(method =&#39;linear&#39;, limit_direction =&#39;forward&#39;,  inplace=True)

        #TODO improve interpolation for missing data
        #f1 = interpolate.interp1d(x1, y1, kind=&#39;quadratic&#39;,fill_value=&#34;extrapolate&#34;)

        
        for peak_obj_idx in indexes_without_results:

            predicted_std = df.loc[peak_obj_idx].predicted_std
            
            self.mass_spectrum_obj[peak_obj_idx].predicted_std = predicted_std

        return df

    def sum_data(self, tuple_mz_abun_list):

        all_mz = {}

        for mz_list, abun_list in tuple_mz_abun_list:
            
            for index, mz in enumerate(mz_list):

                abundance = abun_list[index]

                if mz in all_mz:
                    all_mz[mz] = all_mz[mz] + abundance    
                else: 
                    all_mz[mz] = abundance
        
        mz_all = []
        abun_all = []

        for mz in sorted (all_mz) : 
            mz_all.append(mz)
            abun_all.append(all_mz[mz])

        return array(mz_all), array(abun_all)    

    def calc_error(self, mass_ref, mass_sim, factor):

        return ((mass_ref-mass_sim)/mass_ref)*factor

    def find_peak_apex(self, mass, abund):

        dy = abund[1:] - abund[:-1]

        &#39;&#39;&#39;replaces nan for infinity&#39;&#39;&#39;
        indices_nan = where(isnan(abund))[0]

        if indices_nan.size:
            
            abund[indices_nan] = inf
            dy[where(isnan(dy))[0]] = inf

        indexes = where((hstack((dy, 0)) &lt; 0) &amp; (hstack((0, dy)) &gt; 0))[0]

        if indexes.size:
            
            return mass[indexes], abund[indexes]

    def find_peak_valley(self, mz, abund):

        dy = abund[1:] - abund[:-1]
        
        &#39;&#39;&#39;replaces nan for infinity&#39;&#39;&#39;
        indices_nan = where(isnan(abund))[0]
        
        if indices_nan.size:
            
            abund[indices_nan] = inf
            dy[where(isnan(dy))[0]] = inf
        
        indexes = where((hstack((dy, 0)) &gt; 0) &amp; (hstack((0, dy)) &lt; 0))[0]

        return mz[indexes], abund[indexes]    </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.calc_error"><code class="name flex">
<span>def <span class="ident">calc_error</span></span>(<span>self, mass_ref, mass_sim, factor)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_error(self, mass_ref, mass_sim, factor):

    return ((mass_ref-mass_sim)/mass_ref)*factor</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.calc_error_dist"><code class="name flex">
<span>def <span class="ident">calc_error_dist</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_error_dist(self):
    
    results_list = []
    
    indexes_without_results = list(range(len(self.mass_spectrum_obj)))
    # loop trough mass spectrum

    for peak_obj_idx, peak_obj in enumerate(tqdm(self.mass_spectrum_obj)):
        
        # access ms peaks triplets ( peak_obj_idx -1, peak_obj_idx, and peak_obj_idx + 1)
        # check lower and upper boundaries to not excesses mass spectrum range
        
        if  peak_obj_idx != 0 and peak_obj_idx != len(self.mass_spectrum_obj)-1:
            
            # current peak_obj initialted in the loop expression
            # geting the peak on the left (previous_peak_obj) and the one in the right position (next_peak_obj)
            next_peak_obj = self.mass_spectrum_obj[peak_obj_idx + 1]
            previous_peak_obj = self.mass_spectrum_obj[peak_obj_idx - 1]
            
            # check mz range defined in max_mz variable and check if peaks have same nominal mz
            # keeping same mz for better plotting representation only, remove it for production
            if  peak_obj.nominal_mz_exp == next_peak_obj.nominal_mz_exp and peak_obj.nominal_mz_exp == previous_peak_obj.nominal_mz_exp:
                
                #simulate peak shape
                sim_mz, sim_abun = peak_obj.gaussian(mz_overlay=self.mz_overlay)
                #update_plot(sim_mz,sim_abun, 0.5)
                
                #simulate peak shape
                next_sim_mz, next_sim_abun = next_peak_obj.gaussian(mz_overlay=self.mz_overlay)
                #update_plot(next_sim_mz, next_sim_abun, 0.5)
                
                
                #simulate peak shape
                previous_sim_mz, previous_sim_abun = previous_peak_obj.gaussian(mz_overlay=self.mz_overlay)
                #update_plot(previous_sim_mz,  previous_sim_abun, 0.5)
                
                sim_mz_domain,  summed_peaks_abun = self.sum_data( ((previous_sim_mz,previous_sim_abun),  (sim_mz,sim_abun), (next_sim_mz, next_sim_abun)) )
                #update_plot(sim_mz_domain,summed_peaks_abun, 0.5)
                
                #sum simulated abundances 
                #summed_peaks_abun = (sim_abun + next_sim_abun + previous_sim_abun) 
                
                #normalize abundances to 0-1
                #summed_peaks_abun = summed_peaks_abun/(max(summed_peaks_abun))

                #find appexes location (mz) and magnitude
                mz_centroid, abund_centroid = self.find_peak_apex(sim_mz_domain,summed_peaks_abun)    

                #find valley location (mz_min_valley) and magnitude (abund_min_valley)
                mz_min_valley, abund_min_valley = self.find_peak_valley(sim_mz_domain, summed_peaks_abun)  

                # clear delta_rp (global implementation) and store choose resolving power increments   
                delta_rp = self.rp_increments
                
                # used to limited number of iterations
                i = 0
                j = 0
                
                # TODO: fit peak shape and decide best fit #gaussian, lorentz and voigt 
                #plot_triplets(mz_centroid,abund_centroid, mz_min_valley, abund_min_valley, sim_mz_domain, summed_peaks_abun )
                if len(mz_centroid) == 2 :
                        
                    while len(mz_centroid) &lt; 3 and i &lt;= self.max_interation:
                        
                        previous_sim_mz, previous_sim_abun = previous_peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)
                        
                        sim_mz, sim_abun = peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)
                        
                        next_sim_mz, next_sim_abun = next_peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)

                        sim_mz_domain,  summed_peaks_abun = self.sum_data( ((previous_sim_mz,previous_sim_abun),  (sim_mz,sim_abun), (next_sim_mz, next_sim_abun)) )
                        
                        #update_plot(sim_mz_domain,  summed_peaks_abun, 0.01)

                        mz_centroid, abund_centroid = self.find_peak_apex(sim_mz_domain,summed_peaks_abun)    

                        delta_rp += self.rp_increments
                        
                        i += 1

                    mz_min_valley, abund_min_valley = self.find_peak_valley(sim_mz_domain, summed_peaks_abun)      

                if len(mz_centroid) == 3 and len(abund_min_valley) == 2:
                    # increase all three peak resolving power until both valley magnitude is bellow the defined target
                    # calculate peak shapes with the needed resolving power to have a baseline resolution for all peaks
                    # calculate mass difference (ppm) between original centroid and the new simulated peak. 
                    
                    while  abund_min_valley[0] &gt; self.base_line_target or abund_min_valley[1] &gt; self.base_line_target and j &lt;= self.max_interation:
                        
                        previous_sim_mz, previous_sim_abun = previous_peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)
                        
                        sim_mz, sim_abun = peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)
                        
                        next_sim_mz, next_sim_abun = next_peak_obj.gaussian(delta_rp=delta_rp, mz_overlay=self.mz_overlay)

                        sim_mz_domain,  summed_peaks_abun = self.sum_data( ((previous_sim_mz,previous_sim_abun),  (sim_mz,sim_abun), (next_sim_mz, next_sim_abun)) )
                        
                        #update_plot(sim_mz_domain,  summed_peaks_abun, 0.001)
                        
                        #summed_peaks_abun = (sim_abun + next_sim_abun + previous_sim_abun) 
                        
                        
                        #find appexes location (mz) and magnitude
                        mz_centroid, abund_centroid = self.find_peak_apex(sim_mz_domain,summed_peaks_abun)    
                        
                        #find valley location (mz_min_valley) and magnitude (abund_min_valley)
                        summed_peaks_abun = summed_peaks_abun/(summed_peaks_abun.max())
                        mz_min_valley, abund_min_valley = self.find_peak_valley(sim_mz_domain, summed_peaks_abun)  

                        if len(abund_min_valley) != 2:
                            break
                        
                        delta_rp += self.rp_increments
                        j += 1
                        
                        #plot_triplets(mz_centroid,abund_centroid, mz_min_valley, abund_min_valley, sim_mz_domain, summed_peaks_abun )
                    
                    
                    #plot_triplets(mz_centroid,abund_centroid, mz_min_valley, abund_min_valley, sim_mz_domain, summed_peaks_abun )

                    mass_shift_ppp = self.calc_error(mz_centroid[1], peak_obj.mz_exp, 1000000)
                    #delta_mz = mz_centroid[1] - peak_obj.mz_exp
                    height_shift_per = self.calc_error(abund_centroid[1], peak_obj.abundance, 100)
                    #excitation_amplitude = str(mass_spectrum_obj.filename.stem).split(&#34;ex&#34;)[1].split(&#34;pc&#34;)[0]
                    #ion_time = str(mass_spectrum_obj.filename.stem).split(&#34;0pt&#34;)[1].split(&#34;s&#34;)[0]
                    peak_obj.predicted_std = mass_shift_ppp
                    
                    results_list.append( {
                    &#34;ms_index_position&#34; : peak_obj_idx,
                    &#34;predicted_std&#34;: mass_shift_ppp,
                    &#34;mz_exp&#34;: peak_obj.mz_exp,
                    &#34;nominal_mz_exp&#34;: peak_obj.nominal_mz_exp,
                    &#34;predicted_mz&#34;: mz_centroid[1],
                    &#34;s2n&#34; : peak_obj.signal_to_noise,
                    &#34;peak_height&#34; : peak_obj.abundance,
                    &#34;predicted_peak_height&#34; : abund_centroid[1],
                    &#34;peak_height_error&#34; : height_shift_per,
                    &#34;resolving_power&#34; : peak_obj.resolving_power,
                    #&#34;excitation_amplitude&#34; : excitation_amplitude,
                    #&#34;ion_time&#34; : ion_time
                    })
                    
                    indexes_without_results.remove(peak_obj_idx)
                #elif len(mz_centroid) == 3 and len(abund_min_valley) != 2:

    for peak_obj_idx in indexes_without_results:

        results_list.append( {
        &#34;ms_index_position&#34; : peak_obj_idx,
        &#34;mz_exp&#34;: self.mass_spectrum_obj[peak_obj_idx].mz_exp,
        &#34;nominal_mz_exp&#34;: self.mass_spectrum_obj[peak_obj_idx].nominal_mz_exp,
        &#34;s2n&#34; : self.mass_spectrum_obj[peak_obj_idx].signal_to_noise,
        &#34;peak_height&#34; : self.mass_spectrum_obj[peak_obj_idx].abundance,
        &#34;resolving_power&#34; : self.mass_spectrum_obj[peak_obj_idx].resolving_power,
        #&#34;excitation_amplitude&#34; : excitation_amplitude,
        #&#34;ion_time&#34; : ion_time
        } )

    df = DataFrame(results_list).sort_values(&#34;mz_exp&#34;)
    
    df.interpolate(method =&#39;linear&#39;, limit_direction =&#39;backward&#39;,  inplace=True)
    df.interpolate(method =&#39;linear&#39;, limit_direction =&#39;forward&#39;,  inplace=True)

    #TODO improve interpolation for missing data
    #f1 = interpolate.interp1d(x1, y1, kind=&#39;quadratic&#39;,fill_value=&#34;extrapolate&#34;)

    
    for peak_obj_idx in indexes_without_results:

        predicted_std = df.loc[peak_obj_idx].predicted_std
        
        self.mass_spectrum_obj[peak_obj_idx].predicted_std = predicted_std

    return df</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.find_peak_apex"><code class="name flex">
<span>def <span class="ident">find_peak_apex</span></span>(<span>self, mass, abund)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_peak_apex(self, mass, abund):

    dy = abund[1:] - abund[:-1]

    &#39;&#39;&#39;replaces nan for infinity&#39;&#39;&#39;
    indices_nan = where(isnan(abund))[0]

    if indices_nan.size:
        
        abund[indices_nan] = inf
        dy[where(isnan(dy))[0]] = inf

    indexes = where((hstack((dy, 0)) &lt; 0) &amp; (hstack((0, dy)) &gt; 0))[0]

    if indexes.size:
        
        return mass[indexes], abund[indexes]</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.find_peak_valley"><code class="name flex">
<span>def <span class="ident">find_peak_valley</span></span>(<span>self, mz, abund)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_peak_valley(self, mz, abund):

    dy = abund[1:] - abund[:-1]
    
    &#39;&#39;&#39;replaces nan for infinity&#39;&#39;&#39;
    indices_nan = where(isnan(abund))[0]
    
    if indices_nan.size:
        
        abund[indices_nan] = inf
        dy[where(isnan(dy))[0]] = inf
    
    indexes = where((hstack((dy, 0)) &gt; 0) &amp; (hstack((0, dy)) &lt; 0))[0]

    return mz[indexes], abund[indexes]    </code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.get_results"><code class="name flex">
<span>def <span class="ident">get_results</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_results(self):

    if not self.df:
        self.run()

    return self.df</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method representing the thread's activity.</p>
<p>You may override this method in a subclass. The standard run() method
invokes the callable object passed to the object's constructor as the
target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
        
    self.df = self.calc_error_dist()</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.sum_data"><code class="name flex">
<span>def <span class="ident">sum_data</span></span>(<span>self, tuple_mz_abun_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum_data(self, tuple_mz_abun_list):

    all_mz = {}

    for mz_list, abun_list in tuple_mz_abun_list:
        
        for index, mz in enumerate(mz_list):

            abundance = abun_list[index]

            if mz in all_mz:
                all_mz[mz] = all_mz[mz] + abundance    
            else: 
                all_mz[mz] = abundance
    
    mz_all = []
    abun_all = []

    for mz in sorted (all_mz) : 
        mz_all.append(mz)
        abun_all.append(all_mz[mz])

    return array(mz_all), array(abun_all)    </code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.mass_spectrum.calc" href="index.html">corems.mass_spectrum.calc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction" href="#corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction">MassErrorPrediction</a></code></h4>
<ul class="two-column">
<li><code><a title="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.calc_error" href="#corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.calc_error">calc_error</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.calc_error_dist" href="#corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.calc_error_dist">calc_error_dist</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.find_peak_apex" href="#corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.find_peak_apex">find_peak_apex</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.find_peak_valley" href="#corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.find_peak_valley">find_peak_valley</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.get_results" href="#corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.get_results">get_results</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.run" href="#corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.run">run</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.sum_data" href="#corems.mass_spectrum.calc.MassErrorPrediction.MassErrorPrediction.sum_data">sum_data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>