<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.mass_spectrum.calc.CalibrationCalc API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.mass_spectrum.calc.CalibrationCalc</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np

class FreqDomain_Calibration:

    def __init__(self, mass_spectrum, selected_mass_peaks, include_isotopologue=False):

        self.selected_mspeaks = selected_mass_peaks
        error = list()
        freq_exp = list()
        mz_calc = list()
        mz_exp = list()

        for mspeak in selected_mass_peaks:

            if not include_isotopologue:
                molecular_formulas = [
                    formula for formula in mspeak if not formula.is_isotopologue]
            else:
                molecular_formulas = mspeak

            for molecular_formula in molecular_formulas:

                freq_exp.append(mspeak.freq_exp)
                error.append(
                    molecular_formula.mz_error)
                mz_calc.append(molecular_formula.mz_calc)
                mz_exp.append(mspeak.mz_exp)

        self.mz_exp = np.array(mz_exp)
        self.mz_calc = np.array(mz_calc)
        self.freq_exp = np.array(freq_exp)
        self.mass_spectrum = mass_spectrum
        self.freq_exp_ms = np.array(
            [mspeak.freq_exp for mspeak in mass_spectrum])

    def recal_mass_spec(self, mz_domain, Aterm, Bterm, Cterm):

        self.mass_spectrum._calibration_terms = (Aterm, Bterm, 0)
        
        #for indexes, mspeak in enumerate(self.mass_spectrum):
        #    mspeak.mz_cal = mz_domain[indexes] 
        self.mass_spectrum.mz_cal = mz_domain

    def linear(self):

        matrix = np.vstack([1/self.freq_exp, np.ones(len(self.freq_exp))]).T
        Aterm, Bterm = np.linalg.lstsq(matrix, self.mz_calc, rcond=None)[0]
        print(&#34;%.2f Aterm,  %.2f Bterm&#34; %  (Aterm, Bterm))
        print(&#39;Linear Calibration %.2f Aterm,  %.2f Bterm &#39; %(Aterm, Bterm))
        print()
        #mz_domain = Aterm / (self.freq_exp_ms + Bterm)
        mz_domain = (Aterm/self.freq_exp_ms) + Bterm
        self.recal_mass_spec(mz_domain, Aterm, Bterm, 0)

    def quadratic(self, iteration=False):

        mz_calc = self.mz_calc
        freq_exp = self.freq_exp
        mz_exp = self.mz_exp

        error = ((mz_exp-mz_calc)/mz_calc) * 1000000
        last_rms = np.sqrt(np.mean(error**2))
        while True:

            matrix = np.vstack(
                [1/freq_exp, 1/np.power(freq_exp, 2), np.ones(len(freq_exp))]).T
            Aterm, Bterm, Cterm = np.linalg.lstsq(
                matrix, self.mz_calc, rcond=None)[0]
            mz_exp = (Aterm / (freq_exp)) + \
                (Bterm / np.power((freq_exp), 2)) + Cterm
            error = ((mz_exp-mz_calc)/mz_calc)*1000000
            rms = np.sqrt(np.mean(error**2))
            std = np.std(error)
            print(&#34;%.2f Aterm,  %.2f Bterm&#34; %  (Aterm, Bterm))
            print(&#39;Quadratic Calibration %.2f RMS,  %.2f std,  %.2f Aterm,  %.2f Bterm &#39; %(rms, std, Aterm, Bterm))
            print()
            if rms &lt; last_rms:
                last_rms = rms
                freq_exp = (Aterm + np.sqrt(np.power(-Aterm, 2) -
                                            (4*Cterm*(mz_exp-Bterm)))) / (2*mz_exp)

                mz_domain = (Aterm / (self.freq_exp_ms)) + \
                    (Bterm / np.power((self.freq_exp_ms), 2)) + Cterm
                self.recal_mass_spec(mz_domain, Aterm, Bterm, Cterm)
                if not iteration:
                    break
            else:
                break

    def ledford_calibration(self, iteration=False):

        mz_calc = self.mz_calc
        freq_exp = self.freq_exp
        mz_exp = self.mz_exp

        error = ((mz_exp-self.mz_calc)/self.mz_calc) * 1000000
        last_rms = np.sqrt(np.mean(error**2))
        while True:

            matrix = np.vstack([1/freq_exp, 1/np.power(freq_exp, 2)]).T
            Aterm, Bterm = np.linalg.lstsq(matrix, self.mz_calc, rcond=None)[0]

            mz_exp = (Aterm / (freq_exp)) + (Bterm / np.power((freq_exp), 2))
            error = ((mz_exp-mz_calc)/mz_calc)*1000000
            rms = np.sqrt(np.mean(error**2))
            std = np.std(error)
            print(&#34;%.2f Aterm,  %.2f Bterm&#34; %  (Aterm, Bterm))
            print(&#39;Ledford Calibration %.2f RMS,  %.2f std,  %.2f Aterm,  %.2f Bterm &#39; %(rms, std, Aterm, Bterm))
            print()
            if rms &lt; last_rms:
                last_rms = rms
                freq_exp = (Aterm + np.sqrt(np.power(-Aterm, 2) -
                                            (4*mz_exp-Bterm))) / (2*mz_exp)
                mz_domain = (Aterm / (self.freq_exp_ms)) + \
                    (Bterm / np.power((self.freq_exp_ms), 2))
                self.recal_mass_spec(mz_domain, Aterm, Bterm, 0)
                if not iteration:
                    break
            else:
                break

    def step_fit(self, steps=4):

        def f_to_mz(f, A, B, C, a): 
                return (A / f) + (B / np.power(f, 2)) + (C*a / np.power(f, 2))
        
        def mz_to_f(m, A, B, C): return (-A-m/B)
        
        tuple_indexes = [(i, i+steps) for i in range(0, len(self.selected_mspeaks)-steps, steps)]

        for current_index, tuple_index in enumerate(tuple_indexes):
            
            mspeak_ii, mspeak_fi = tuple_index
            freq_exp = list()
            mz_calc = list()
            mz_exp = list()
            abu = list()
            
            for i in range(mspeak_ii, mspeak_fi+1):

                best_formula = self.selected_mspeaks[i].best_molecular_formula_candidate

                freq_exp.append(self.selected_mspeaks[i].freq_exp)
                mz_calc.append(best_formula.mz_calc)
                mz_exp.append(self.selected_mspeaks[i].mz_exp)
                abu.append(self.selected_mspeaks[i].abundance)
                        
            
            freq_exp = np.array(freq_exp)
            mz_calc = np.array(mz_calc)
            mz_exp = np.array(mz_exp)
            abu = np.array(abu)

            if current_index == len(tuple_indexes)-1:
                ms_peaks_indexes = (self.selected_mspeaks[mspeak_ii].index, 0)
            
            elif current_index == 0:
                ms_peaks_indexes = (len(self.mass_spectrum)-1,
                                    self.selected_mspeaks[mspeak_fi].index-1)
            else:
                ms_peaks_indexes = (
                    self.selected_mspeaks[mspeak_ii].index, self.selected_mspeaks[mspeak_fi].index-1)

            final_index, start_index = ms_peaks_indexes
                           
            matrix = np.vstack([1/freq_exp, 1/np.power(freq_exp, 2)]).T
            A, B = np.linalg.lstsq(matrix, mz_calc, rcond=None)[0]
            C = 0
            
            for mspeak in self.mass_spectrum[start_index:final_index]:
                mspeak.mz_cal = f_to_mz(mspeak.freq_exp, A, B, C, 0)
        
        self.mass_spectrum.is_calibrated = True    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration"><code class="flex name class">
<span>class <span class="ident">FreqDomain_Calibration</span></span>
<span>(</span><span>mass_spectrum, selected_mass_peaks, include_isotopologue=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FreqDomain_Calibration:

    def __init__(self, mass_spectrum, selected_mass_peaks, include_isotopologue=False):

        self.selected_mspeaks = selected_mass_peaks
        error = list()
        freq_exp = list()
        mz_calc = list()
        mz_exp = list()

        for mspeak in selected_mass_peaks:

            if not include_isotopologue:
                molecular_formulas = [
                    formula for formula in mspeak if not formula.is_isotopologue]
            else:
                molecular_formulas = mspeak

            for molecular_formula in molecular_formulas:

                freq_exp.append(mspeak.freq_exp)
                error.append(
                    molecular_formula.mz_error)
                mz_calc.append(molecular_formula.mz_calc)
                mz_exp.append(mspeak.mz_exp)

        self.mz_exp = np.array(mz_exp)
        self.mz_calc = np.array(mz_calc)
        self.freq_exp = np.array(freq_exp)
        self.mass_spectrum = mass_spectrum
        self.freq_exp_ms = np.array(
            [mspeak.freq_exp for mspeak in mass_spectrum])

    def recal_mass_spec(self, mz_domain, Aterm, Bterm, Cterm):

        self.mass_spectrum._calibration_terms = (Aterm, Bterm, 0)
        
        #for indexes, mspeak in enumerate(self.mass_spectrum):
        #    mspeak.mz_cal = mz_domain[indexes] 
        self.mass_spectrum.mz_cal = mz_domain

    def linear(self):

        matrix = np.vstack([1/self.freq_exp, np.ones(len(self.freq_exp))]).T
        Aterm, Bterm = np.linalg.lstsq(matrix, self.mz_calc, rcond=None)[0]
        print(&#34;%.2f Aterm,  %.2f Bterm&#34; %  (Aterm, Bterm))
        print(&#39;Linear Calibration %.2f Aterm,  %.2f Bterm &#39; %(Aterm, Bterm))
        print()
        #mz_domain = Aterm / (self.freq_exp_ms + Bterm)
        mz_domain = (Aterm/self.freq_exp_ms) + Bterm
        self.recal_mass_spec(mz_domain, Aterm, Bterm, 0)

    def quadratic(self, iteration=False):

        mz_calc = self.mz_calc
        freq_exp = self.freq_exp
        mz_exp = self.mz_exp

        error = ((mz_exp-mz_calc)/mz_calc) * 1000000
        last_rms = np.sqrt(np.mean(error**2))
        while True:

            matrix = np.vstack(
                [1/freq_exp, 1/np.power(freq_exp, 2), np.ones(len(freq_exp))]).T
            Aterm, Bterm, Cterm = np.linalg.lstsq(
                matrix, self.mz_calc, rcond=None)[0]
            mz_exp = (Aterm / (freq_exp)) + \
                (Bterm / np.power((freq_exp), 2)) + Cterm
            error = ((mz_exp-mz_calc)/mz_calc)*1000000
            rms = np.sqrt(np.mean(error**2))
            std = np.std(error)
            print(&#34;%.2f Aterm,  %.2f Bterm&#34; %  (Aterm, Bterm))
            print(&#39;Quadratic Calibration %.2f RMS,  %.2f std,  %.2f Aterm,  %.2f Bterm &#39; %(rms, std, Aterm, Bterm))
            print()
            if rms &lt; last_rms:
                last_rms = rms
                freq_exp = (Aterm + np.sqrt(np.power(-Aterm, 2) -
                                            (4*Cterm*(mz_exp-Bterm)))) / (2*mz_exp)

                mz_domain = (Aterm / (self.freq_exp_ms)) + \
                    (Bterm / np.power((self.freq_exp_ms), 2)) + Cterm
                self.recal_mass_spec(mz_domain, Aterm, Bterm, Cterm)
                if not iteration:
                    break
            else:
                break

    def ledford_calibration(self, iteration=False):

        mz_calc = self.mz_calc
        freq_exp = self.freq_exp
        mz_exp = self.mz_exp

        error = ((mz_exp-self.mz_calc)/self.mz_calc) * 1000000
        last_rms = np.sqrt(np.mean(error**2))
        while True:

            matrix = np.vstack([1/freq_exp, 1/np.power(freq_exp, 2)]).T
            Aterm, Bterm = np.linalg.lstsq(matrix, self.mz_calc, rcond=None)[0]

            mz_exp = (Aterm / (freq_exp)) + (Bterm / np.power((freq_exp), 2))
            error = ((mz_exp-mz_calc)/mz_calc)*1000000
            rms = np.sqrt(np.mean(error**2))
            std = np.std(error)
            print(&#34;%.2f Aterm,  %.2f Bterm&#34; %  (Aterm, Bterm))
            print(&#39;Ledford Calibration %.2f RMS,  %.2f std,  %.2f Aterm,  %.2f Bterm &#39; %(rms, std, Aterm, Bterm))
            print()
            if rms &lt; last_rms:
                last_rms = rms
                freq_exp = (Aterm + np.sqrt(np.power(-Aterm, 2) -
                                            (4*mz_exp-Bterm))) / (2*mz_exp)
                mz_domain = (Aterm / (self.freq_exp_ms)) + \
                    (Bterm / np.power((self.freq_exp_ms), 2))
                self.recal_mass_spec(mz_domain, Aterm, Bterm, 0)
                if not iteration:
                    break
            else:
                break

    def step_fit(self, steps=4):

        def f_to_mz(f, A, B, C, a): 
                return (A / f) + (B / np.power(f, 2)) + (C*a / np.power(f, 2))
        
        def mz_to_f(m, A, B, C): return (-A-m/B)
        
        tuple_indexes = [(i, i+steps) for i in range(0, len(self.selected_mspeaks)-steps, steps)]

        for current_index, tuple_index in enumerate(tuple_indexes):
            
            mspeak_ii, mspeak_fi = tuple_index
            freq_exp = list()
            mz_calc = list()
            mz_exp = list()
            abu = list()
            
            for i in range(mspeak_ii, mspeak_fi+1):

                best_formula = self.selected_mspeaks[i].best_molecular_formula_candidate

                freq_exp.append(self.selected_mspeaks[i].freq_exp)
                mz_calc.append(best_formula.mz_calc)
                mz_exp.append(self.selected_mspeaks[i].mz_exp)
                abu.append(self.selected_mspeaks[i].abundance)
                        
            
            freq_exp = np.array(freq_exp)
            mz_calc = np.array(mz_calc)
            mz_exp = np.array(mz_exp)
            abu = np.array(abu)

            if current_index == len(tuple_indexes)-1:
                ms_peaks_indexes = (self.selected_mspeaks[mspeak_ii].index, 0)
            
            elif current_index == 0:
                ms_peaks_indexes = (len(self.mass_spectrum)-1,
                                    self.selected_mspeaks[mspeak_fi].index-1)
            else:
                ms_peaks_indexes = (
                    self.selected_mspeaks[mspeak_ii].index, self.selected_mspeaks[mspeak_fi].index-1)

            final_index, start_index = ms_peaks_indexes
                           
            matrix = np.vstack([1/freq_exp, 1/np.power(freq_exp, 2)]).T
            A, B = np.linalg.lstsq(matrix, mz_calc, rcond=None)[0]
            C = 0
            
            for mspeak in self.mass_spectrum[start_index:final_index]:
                mspeak.mz_cal = f_to_mz(mspeak.freq_exp, A, B, C, 0)
        
        self.mass_spectrum.is_calibrated = True    </code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration.ledford_calibration"><code class="name flex">
<span>def <span class="ident">ledford_calibration</span></span>(<span>self, iteration=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ledford_calibration(self, iteration=False):

    mz_calc = self.mz_calc
    freq_exp = self.freq_exp
    mz_exp = self.mz_exp

    error = ((mz_exp-self.mz_calc)/self.mz_calc) * 1000000
    last_rms = np.sqrt(np.mean(error**2))
    while True:

        matrix = np.vstack([1/freq_exp, 1/np.power(freq_exp, 2)]).T
        Aterm, Bterm = np.linalg.lstsq(matrix, self.mz_calc, rcond=None)[0]

        mz_exp = (Aterm / (freq_exp)) + (Bterm / np.power((freq_exp), 2))
        error = ((mz_exp-mz_calc)/mz_calc)*1000000
        rms = np.sqrt(np.mean(error**2))
        std = np.std(error)
        print(&#34;%.2f Aterm,  %.2f Bterm&#34; %  (Aterm, Bterm))
        print(&#39;Ledford Calibration %.2f RMS,  %.2f std,  %.2f Aterm,  %.2f Bterm &#39; %(rms, std, Aterm, Bterm))
        print()
        if rms &lt; last_rms:
            last_rms = rms
            freq_exp = (Aterm + np.sqrt(np.power(-Aterm, 2) -
                                        (4*mz_exp-Bterm))) / (2*mz_exp)
            mz_domain = (Aterm / (self.freq_exp_ms)) + \
                (Bterm / np.power((self.freq_exp_ms), 2))
            self.recal_mass_spec(mz_domain, Aterm, Bterm, 0)
            if not iteration:
                break
        else:
            break</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration.linear"><code class="name flex">
<span>def <span class="ident">linear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linear(self):

    matrix = np.vstack([1/self.freq_exp, np.ones(len(self.freq_exp))]).T
    Aterm, Bterm = np.linalg.lstsq(matrix, self.mz_calc, rcond=None)[0]
    print(&#34;%.2f Aterm,  %.2f Bterm&#34; %  (Aterm, Bterm))
    print(&#39;Linear Calibration %.2f Aterm,  %.2f Bterm &#39; %(Aterm, Bterm))
    print()
    #mz_domain = Aterm / (self.freq_exp_ms + Bterm)
    mz_domain = (Aterm/self.freq_exp_ms) + Bterm
    self.recal_mass_spec(mz_domain, Aterm, Bterm, 0)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration.quadratic"><code class="name flex">
<span>def <span class="ident">quadratic</span></span>(<span>self, iteration=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quadratic(self, iteration=False):

    mz_calc = self.mz_calc
    freq_exp = self.freq_exp
    mz_exp = self.mz_exp

    error = ((mz_exp-mz_calc)/mz_calc) * 1000000
    last_rms = np.sqrt(np.mean(error**2))
    while True:

        matrix = np.vstack(
            [1/freq_exp, 1/np.power(freq_exp, 2), np.ones(len(freq_exp))]).T
        Aterm, Bterm, Cterm = np.linalg.lstsq(
            matrix, self.mz_calc, rcond=None)[0]
        mz_exp = (Aterm / (freq_exp)) + \
            (Bterm / np.power((freq_exp), 2)) + Cterm
        error = ((mz_exp-mz_calc)/mz_calc)*1000000
        rms = np.sqrt(np.mean(error**2))
        std = np.std(error)
        print(&#34;%.2f Aterm,  %.2f Bterm&#34; %  (Aterm, Bterm))
        print(&#39;Quadratic Calibration %.2f RMS,  %.2f std,  %.2f Aterm,  %.2f Bterm &#39; %(rms, std, Aterm, Bterm))
        print()
        if rms &lt; last_rms:
            last_rms = rms
            freq_exp = (Aterm + np.sqrt(np.power(-Aterm, 2) -
                                        (4*Cterm*(mz_exp-Bterm)))) / (2*mz_exp)

            mz_domain = (Aterm / (self.freq_exp_ms)) + \
                (Bterm / np.power((self.freq_exp_ms), 2)) + Cterm
            self.recal_mass_spec(mz_domain, Aterm, Bterm, Cterm)
            if not iteration:
                break
        else:
            break</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration.recal_mass_spec"><code class="name flex">
<span>def <span class="ident">recal_mass_spec</span></span>(<span>self, mz_domain, Aterm, Bterm, Cterm)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recal_mass_spec(self, mz_domain, Aterm, Bterm, Cterm):

    self.mass_spectrum._calibration_terms = (Aterm, Bterm, 0)
    
    #for indexes, mspeak in enumerate(self.mass_spectrum):
    #    mspeak.mz_cal = mz_domain[indexes] 
    self.mass_spectrum.mz_cal = mz_domain</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration.step_fit"><code class="name flex">
<span>def <span class="ident">step_fit</span></span>(<span>self, steps=4)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_fit(self, steps=4):

    def f_to_mz(f, A, B, C, a): 
            return (A / f) + (B / np.power(f, 2)) + (C*a / np.power(f, 2))
    
    def mz_to_f(m, A, B, C): return (-A-m/B)
    
    tuple_indexes = [(i, i+steps) for i in range(0, len(self.selected_mspeaks)-steps, steps)]

    for current_index, tuple_index in enumerate(tuple_indexes):
        
        mspeak_ii, mspeak_fi = tuple_index
        freq_exp = list()
        mz_calc = list()
        mz_exp = list()
        abu = list()
        
        for i in range(mspeak_ii, mspeak_fi+1):

            best_formula = self.selected_mspeaks[i].best_molecular_formula_candidate

            freq_exp.append(self.selected_mspeaks[i].freq_exp)
            mz_calc.append(best_formula.mz_calc)
            mz_exp.append(self.selected_mspeaks[i].mz_exp)
            abu.append(self.selected_mspeaks[i].abundance)
                    
        
        freq_exp = np.array(freq_exp)
        mz_calc = np.array(mz_calc)
        mz_exp = np.array(mz_exp)
        abu = np.array(abu)

        if current_index == len(tuple_indexes)-1:
            ms_peaks_indexes = (self.selected_mspeaks[mspeak_ii].index, 0)
        
        elif current_index == 0:
            ms_peaks_indexes = (len(self.mass_spectrum)-1,
                                self.selected_mspeaks[mspeak_fi].index-1)
        else:
            ms_peaks_indexes = (
                self.selected_mspeaks[mspeak_ii].index, self.selected_mspeaks[mspeak_fi].index-1)

        final_index, start_index = ms_peaks_indexes
                       
        matrix = np.vstack([1/freq_exp, 1/np.power(freq_exp, 2)]).T
        A, B = np.linalg.lstsq(matrix, mz_calc, rcond=None)[0]
        C = 0
        
        for mspeak in self.mass_spectrum[start_index:final_index]:
            mspeak.mz_cal = f_to_mz(mspeak.freq_exp, A, B, C, 0)
    
    self.mass_spectrum.is_calibrated = True    </code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.mass_spectrum.calc" href="index.html">corems.mass_spectrum.calc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration" href="#corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration">FreqDomain_Calibration</a></code></h4>
<ul class="">
<li><code><a title="corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration.ledford_calibration" href="#corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration.ledford_calibration">ledford_calibration</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration.linear" href="#corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration.linear">linear</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration.quadratic" href="#corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration.quadratic">quadratic</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration.recal_mass_spec" href="#corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration.recal_mass_spec">recal_mass_spec</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration.step_fit" href="#corems.mass_spectrum.calc.CalibrationCalc.FreqDomain_Calibration.step_fit">step_fit</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>