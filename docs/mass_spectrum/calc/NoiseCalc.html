<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.mass_spectrum.calc.NoiseCalc API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.mass_spectrum.calc.NoiseCalc</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import time

from numpy import where, average, std, isnan, inf, hstack, median, argmax, percentile
from corems import chunks
import warnings

#from matplotlib import pyplot
__author__ = &#34;Yuri E. Corilo&#34;
__date__ = &#34;Jun 27, 2019&#34;

class NoiseThresholdCalc:

    def get_noise_threshold(self) -&gt; ( (float, float), (float,float) ):
        &#39;&#39;&#39; return two tuples (min_mz, max_mz) , (noise_threshold, noise_threshold)&#39;&#39;&#39;
        
        if self.is_centroid:

            x = min(self.mz_exp), max((self.mz_exp))
            
            if self.settings.threshold_method == &#39;auto&#39;:
                
                abundance_threshold = self.baselise_noise + (self.settings.noise_threshold_std * self.baselise_noise_std)
                y = (abundance_threshold, abundance_threshold)

            elif self.settings.threshold_method == &#39;signal_noise&#39;:

                normalized_threshold = (self.max_abundance * self.settings.s2n_threshold )/self.max_signal_to_noise
                y = (normalized_threshold, normalized_threshold)
            
            elif self.settings.threshold_method == &#34;relative_abundance&#34;:

                normalized_threshold = (max(self.abundance)/100)*self.settings.relative_abundance_threshold
                y = (normalized_threshold, normalized_threshold)    
            
            else:
                    raise  Exception(&#34;%s method was not implemented, please refer to corems.mass_spectrum.calc.NoiseCalc Class&#34; % self.settings.threshold_method)
                
            return x, y    

        else:

            if self.baselise_noise and self.baselise_noise_std:
                
                x = (self.mz_exp_profile.min(), self.mz_exp_profile.max())
                y = (self.baselise_noise_std, self.baselise_noise_std)
                
                if self.settings.threshold_method == &#39;auto&#39;:
                
                    #print(self.settings.noise_threshold_std)
                    abundance_threshold = self.baselise_noise + (self.settings.noise_threshold_std * self.baselise_noise_std)
                    
                    y = (abundance_threshold, abundance_threshold)

                elif self.settings.threshold_method == &#39;signal_noise&#39;:

                    max_sn = self.abundance_profile.max()/self.baselise_noise_std

                    normalized_threshold = (self.abundance_profile.max() * self.settings.s2n_threshold )/max_sn
                    y = (normalized_threshold, normalized_threshold)

                elif self.settings.threshold_method == &#34;relative_abundance&#34;:

                    normalized_threshold = (self.abundance_profile.max()/100)*self.settings.relative_abundance_threshold
                    y = (normalized_threshold, normalized_threshold)
                    

                else:
                    raise  Exception(&#34;%s method was not implemented, \
                        please refer to corems.mass_spectrum.calc.NoiseCalc Class&#34; % self.settings.threshold_method)
                
                return x, y
            
            else:
                
                warnings.warn(
                    &#34;Noise Baseline and Noise std not specified,\
                    defaulting to 0,0 run process_mass_spec() ?&#34;
                )    
                return (0,0) , (0,0)

    def cut_mz_domain_noise(self, auto):
        
        min_mz_whole_ms = self.mz_exp_profile.min()
        max_mz_whole_ms = self.mz_exp_profile.max()

        if auto:
            
            # this calculation is taking too long (about 2 seconds)
            number_average_molecular_weight = self.weight_average_molecular_weight(
                profile=True)
           
            # +-200 is a guess for testing only, it needs adjustment for each type of analysis
            # need to check min mz here or it will break
            min_mz_noise = number_average_molecular_weight - 100
            # need to check max mz here or it will break
            max_mz_noise = number_average_molecular_weight + 100

        else:

            min_mz_noise = self.settings.min_noise_mz
            max_mz_noise = self.settings.max_noise_mz

        if min_mz_noise &lt; min_mz_whole_ms:
            min_mz_noise = min_mz_whole_ms

        if max_mz_noise &gt; max_mz_whole_ms:
            max_mz_noise = max_mz_whole_ms

        #print(min_mz_noise, max_mz_noise)
        low_mz_index = (where(self.mz_exp_profile &gt;= min_mz_noise)[0][0])
        #print(self.mz_exp_profile[low_mz_index])
        # low_mz_index = (argmax(self.mz_exp_profile &lt;= min_mz_noise))
        
        high_mz_index = (where(self.mz_exp_profile &lt;= max_mz_noise)[-1][-1])
        
        #high_mz_index = (argmax(self.mz_exp_profile &lt;= max_mz_noise))
        
        if high_mz_index &gt; low_mz_index:
            # pyplot.plot(self.mz_exp_profile[low_mz_index:high_mz_index], self.abundance_profile[low_mz_index:high_mz_index])
            # pyplot.show()
            return self.mz_exp_profile[high_mz_index:low_mz_index], self.abundance_profile[low_mz_index:high_mz_index]
        else:
            # pyplot.plot(self.mz_exp_profile[high_mz_index:low_mz_index], self.abundance_profile[high_mz_index:low_mz_index])
            # pyplot.show()
            return self.mz_exp_profile[high_mz_index:low_mz_index], self.abundance_profile[high_mz_index:low_mz_index]


    def from_posterior(self, param, samples):

        import pymc3 as pm
        import numpy as np
        import theano.tensor as tt
        from theano import as_op
        from scipy.stats import gaussian_kde
        
        smin, smax = np.min(samples), np.max(samples)
        width = smax - smin
        x = np.linspace(smin, smax, 100)
        y = gaussian_kde(samples)(x)
        
        # what was never sampled should have a small probability but not 0,
        # so we&#39;ll extend the domain and use linear approximation of density on it
        x = np.concatenate([[x[0] - 3 * width], x, [x[-1] + 3 * width]])
        y = np.concatenate([[0], y, [0]])
        
        return pm.distributions.Interpolated(param, x, y)

    def error_model_from_trace(self, trace, ymincentroid):
         
        import pymc3 as pm
        #from pymc3 import traceplot, plot_posterior
        
        with pm.Model() as model2:
            
            sd = self.from_posterior(&#39;sd&#39;, trace[&#39;sd&#39;])
            y = pm.HalfNormal(&#39;y&#39;, sd=sd, observed=ymincentroid)
            start = pm.find_MAP()
            step = pm.NUTS() # Hamiltonian MCMC with No U-Turn Sampler
            trace = pm.sample(1000, step, start, random_seed=123, progressbar=True, tune=1000)
            pm.summary(trace)
            #plot_posterior(trace)
            #traceplot(trace)    
            return pm.summary(trace)[&#39;mean&#39;].values[0] 

    def simple_model_error_dist(self,  ymincentroid):
        
        import pymc3 as pm
        # from pymc3 import traceplot, plot_posterior
        #import seaborn as sns
        #f, ax = pyplot.subplots(figsize=(6, 6))
        #sns.distplot(ymincentroid)
        #sns.kdeplot(ymincentroid, ax=ax, shade=True, color=&#34;g&#34;)
        #sns.rugplot(ymincentroid, color=&#34;black&#34;, ax=ax)
        #ax.set(xlabel= &#34;Peak Minima Magnitude&#34;, ylabel= &#34;Density&#34;)
        #pyplot.show()

        with pm.Model() as model:
            
            #mu = pm.Uniform(&#39;mu&#39;, lower=-1, upper=1)
            lower = ymincentroid.min()
            upper = ymincentroid.max()
            
            sd = pm.Uniform(&#39;sd&#39;, lower=lower , upper=upper)
            
            y = pm.HalfNormal(&#39;y&#39;, sd=sd, observed=ymincentroid)
            
            start = pm.find_MAP()
            step = pm.NUTS() # Hamiltonian MCMC with No U-Turn Sampler
            trace = pm.sample(1000, step, start, random_seed=123, progressbar=True, tune=1000)
            
            return pm.summary(trace)[&#39;mean&#39;].values[0] 
            

    def get_noise_average(self, ymincentroid, auto=True, bayes=False):
        # assumes noise to be gaussian and estimate noise level by 
        # calculating the valley. If bayes is enable it will 
        # model the valley distributuion as half-Normal and estimate the std
        
        average_noise = median((ymincentroid))*2 if auto else median(ymincentroid)
        
        if bayes:
            
            s_deviation = self.simple_model_error_dist(ymincentroid)
        
        else:
            
            s_deviation = ymincentroid.std()*3 if auto else ymincentroid.std()
            
        return average_noise, s_deviation

    def get_abundance_minima_centroid(self, mz_cut, abun_cut):

        maximum = self.abundance_profile.max()
        threshold_min = (maximum * 1.00)

        y = -abun_cut

        dy = y[1:] - y[:-1]
        &#39;&#39;&#39;replaces NaN for Infinity&#39;&#39;&#39;
        indices_nan = where(isnan(y))[0]
        
        if indices_nan.size:

            y[indices_nan] = inf
            dy[where(isnan(dy))[0]] = inf

        
        indices = where((hstack((dy, 0)) &lt; 0) &amp; (hstack((0, dy)) &gt; 0))[0]
        
        if indices.size and threshold_min is not None:
            indices = indices[abun_cut[indices] &lt;= threshold_min]

        # pyplot.plot(mz_cut[indices], abun_cut[indices], linewidth=0, marker=&#39;o&#39;, color=&#39;red&#39;, markersize=2)
        # pyplot.show()

        # pyplot.hist(x=abun_cut[indices], bins=&#39;auto&#39;, color=&#39;#0504aa&#39;,
                            # alpha=0.7, rwidth=0.85)
        
        # cutoff = percentile(abun_cut[indices], 0.98)
        
        # print(cutoff)
        
        # pyplot.show()    
        return abun_cut[indices]


    def run_noise_threshold_calc(self, auto, bayes=False):
        
        if self.is_centroid:
            # calculates noise_baseline and noise_std
            # needed to run auto noise threshold mode
            # it is not used for signal to noise nor 
            # relative abudance methods
            abundances_chunks = chunks(self.abundance, 50)
            each_min_abund = [min(x) for x in abundances_chunks]

            return average(each_min_abund), std(each_min_abund)
        
        else:

            mz_cut, abundance_cut = self.cut_mz_domain_noise(auto)
            
            if auto:

                yminima = self.get_abundance_minima_centroid(mz_cut, abundance_cut)
                
                return self.get_noise_average(yminima, auto=auto, bayes=bayes)

            else:
                
                # pyplot.show()
                return self.get_noise_average(abundance_cut,auto=auto, bayes=bayes)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc"><code class="flex name class">
<span>class <span class="ident">NoiseThresholdCalc</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NoiseThresholdCalc:

    def get_noise_threshold(self) -&gt; ( (float, float), (float,float) ):
        &#39;&#39;&#39; return two tuples (min_mz, max_mz) , (noise_threshold, noise_threshold)&#39;&#39;&#39;
        
        if self.is_centroid:

            x = min(self.mz_exp), max((self.mz_exp))
            
            if self.settings.threshold_method == &#39;auto&#39;:
                
                abundance_threshold = self.baselise_noise + (self.settings.noise_threshold_std * self.baselise_noise_std)
                y = (abundance_threshold, abundance_threshold)

            elif self.settings.threshold_method == &#39;signal_noise&#39;:

                normalized_threshold = (self.max_abundance * self.settings.s2n_threshold )/self.max_signal_to_noise
                y = (normalized_threshold, normalized_threshold)
            
            elif self.settings.threshold_method == &#34;relative_abundance&#34;:

                normalized_threshold = (max(self.abundance)/100)*self.settings.relative_abundance_threshold
                y = (normalized_threshold, normalized_threshold)    
            
            else:
                    raise  Exception(&#34;%s method was not implemented, please refer to corems.mass_spectrum.calc.NoiseCalc Class&#34; % self.settings.threshold_method)
                
            return x, y    

        else:

            if self.baselise_noise and self.baselise_noise_std:
                
                x = (self.mz_exp_profile.min(), self.mz_exp_profile.max())
                y = (self.baselise_noise_std, self.baselise_noise_std)
                
                if self.settings.threshold_method == &#39;auto&#39;:
                
                    #print(self.settings.noise_threshold_std)
                    abundance_threshold = self.baselise_noise + (self.settings.noise_threshold_std * self.baselise_noise_std)
                    
                    y = (abundance_threshold, abundance_threshold)

                elif self.settings.threshold_method == &#39;signal_noise&#39;:

                    max_sn = self.abundance_profile.max()/self.baselise_noise_std

                    normalized_threshold = (self.abundance_profile.max() * self.settings.s2n_threshold )/max_sn
                    y = (normalized_threshold, normalized_threshold)

                elif self.settings.threshold_method == &#34;relative_abundance&#34;:

                    normalized_threshold = (self.abundance_profile.max()/100)*self.settings.relative_abundance_threshold
                    y = (normalized_threshold, normalized_threshold)
                    

                else:
                    raise  Exception(&#34;%s method was not implemented, \
                        please refer to corems.mass_spectrum.calc.NoiseCalc Class&#34; % self.settings.threshold_method)
                
                return x, y
            
            else:
                
                warnings.warn(
                    &#34;Noise Baseline and Noise std not specified,\
                    defaulting to 0,0 run process_mass_spec() ?&#34;
                )    
                return (0,0) , (0,0)

    def cut_mz_domain_noise(self, auto):
        
        min_mz_whole_ms = self.mz_exp_profile.min()
        max_mz_whole_ms = self.mz_exp_profile.max()

        if auto:
            
            # this calculation is taking too long (about 2 seconds)
            number_average_molecular_weight = self.weight_average_molecular_weight(
                profile=True)
           
            # +-200 is a guess for testing only, it needs adjustment for each type of analysis
            # need to check min mz here or it will break
            min_mz_noise = number_average_molecular_weight - 100
            # need to check max mz here or it will break
            max_mz_noise = number_average_molecular_weight + 100

        else:

            min_mz_noise = self.settings.min_noise_mz
            max_mz_noise = self.settings.max_noise_mz

        if min_mz_noise &lt; min_mz_whole_ms:
            min_mz_noise = min_mz_whole_ms

        if max_mz_noise &gt; max_mz_whole_ms:
            max_mz_noise = max_mz_whole_ms

        #print(min_mz_noise, max_mz_noise)
        low_mz_index = (where(self.mz_exp_profile &gt;= min_mz_noise)[0][0])
        #print(self.mz_exp_profile[low_mz_index])
        # low_mz_index = (argmax(self.mz_exp_profile &lt;= min_mz_noise))
        
        high_mz_index = (where(self.mz_exp_profile &lt;= max_mz_noise)[-1][-1])
        
        #high_mz_index = (argmax(self.mz_exp_profile &lt;= max_mz_noise))
        
        if high_mz_index &gt; low_mz_index:
            # pyplot.plot(self.mz_exp_profile[low_mz_index:high_mz_index], self.abundance_profile[low_mz_index:high_mz_index])
            # pyplot.show()
            return self.mz_exp_profile[high_mz_index:low_mz_index], self.abundance_profile[low_mz_index:high_mz_index]
        else:
            # pyplot.plot(self.mz_exp_profile[high_mz_index:low_mz_index], self.abundance_profile[high_mz_index:low_mz_index])
            # pyplot.show()
            return self.mz_exp_profile[high_mz_index:low_mz_index], self.abundance_profile[high_mz_index:low_mz_index]


    def from_posterior(self, param, samples):

        import pymc3 as pm
        import numpy as np
        import theano.tensor as tt
        from theano import as_op
        from scipy.stats import gaussian_kde
        
        smin, smax = np.min(samples), np.max(samples)
        width = smax - smin
        x = np.linspace(smin, smax, 100)
        y = gaussian_kde(samples)(x)
        
        # what was never sampled should have a small probability but not 0,
        # so we&#39;ll extend the domain and use linear approximation of density on it
        x = np.concatenate([[x[0] - 3 * width], x, [x[-1] + 3 * width]])
        y = np.concatenate([[0], y, [0]])
        
        return pm.distributions.Interpolated(param, x, y)

    def error_model_from_trace(self, trace, ymincentroid):
         
        import pymc3 as pm
        #from pymc3 import traceplot, plot_posterior
        
        with pm.Model() as model2:
            
            sd = self.from_posterior(&#39;sd&#39;, trace[&#39;sd&#39;])
            y = pm.HalfNormal(&#39;y&#39;, sd=sd, observed=ymincentroid)
            start = pm.find_MAP()
            step = pm.NUTS() # Hamiltonian MCMC with No U-Turn Sampler
            trace = pm.sample(1000, step, start, random_seed=123, progressbar=True, tune=1000)
            pm.summary(trace)
            #plot_posterior(trace)
            #traceplot(trace)    
            return pm.summary(trace)[&#39;mean&#39;].values[0] 

    def simple_model_error_dist(self,  ymincentroid):
        
        import pymc3 as pm
        # from pymc3 import traceplot, plot_posterior
        #import seaborn as sns
        #f, ax = pyplot.subplots(figsize=(6, 6))
        #sns.distplot(ymincentroid)
        #sns.kdeplot(ymincentroid, ax=ax, shade=True, color=&#34;g&#34;)
        #sns.rugplot(ymincentroid, color=&#34;black&#34;, ax=ax)
        #ax.set(xlabel= &#34;Peak Minima Magnitude&#34;, ylabel= &#34;Density&#34;)
        #pyplot.show()

        with pm.Model() as model:
            
            #mu = pm.Uniform(&#39;mu&#39;, lower=-1, upper=1)
            lower = ymincentroid.min()
            upper = ymincentroid.max()
            
            sd = pm.Uniform(&#39;sd&#39;, lower=lower , upper=upper)
            
            y = pm.HalfNormal(&#39;y&#39;, sd=sd, observed=ymincentroid)
            
            start = pm.find_MAP()
            step = pm.NUTS() # Hamiltonian MCMC with No U-Turn Sampler
            trace = pm.sample(1000, step, start, random_seed=123, progressbar=True, tune=1000)
            
            return pm.summary(trace)[&#39;mean&#39;].values[0] 
            

    def get_noise_average(self, ymincentroid, auto=True, bayes=False):
        # assumes noise to be gaussian and estimate noise level by 
        # calculating the valley. If bayes is enable it will 
        # model the valley distributuion as half-Normal and estimate the std
        
        average_noise = median((ymincentroid))*2 if auto else median(ymincentroid)
        
        if bayes:
            
            s_deviation = self.simple_model_error_dist(ymincentroid)
        
        else:
            
            s_deviation = ymincentroid.std()*3 if auto else ymincentroid.std()
            
        return average_noise, s_deviation

    def get_abundance_minima_centroid(self, mz_cut, abun_cut):

        maximum = self.abundance_profile.max()
        threshold_min = (maximum * 1.00)

        y = -abun_cut

        dy = y[1:] - y[:-1]
        &#39;&#39;&#39;replaces NaN for Infinity&#39;&#39;&#39;
        indices_nan = where(isnan(y))[0]
        
        if indices_nan.size:

            y[indices_nan] = inf
            dy[where(isnan(dy))[0]] = inf

        
        indices = where((hstack((dy, 0)) &lt; 0) &amp; (hstack((0, dy)) &gt; 0))[0]
        
        if indices.size and threshold_min is not None:
            indices = indices[abun_cut[indices] &lt;= threshold_min]

        # pyplot.plot(mz_cut[indices], abun_cut[indices], linewidth=0, marker=&#39;o&#39;, color=&#39;red&#39;, markersize=2)
        # pyplot.show()

        # pyplot.hist(x=abun_cut[indices], bins=&#39;auto&#39;, color=&#39;#0504aa&#39;,
                            # alpha=0.7, rwidth=0.85)
        
        # cutoff = percentile(abun_cut[indices], 0.98)
        
        # print(cutoff)
        
        # pyplot.show()    
        return abun_cut[indices]


    def run_noise_threshold_calc(self, auto, bayes=False):
        
        if self.is_centroid:
            # calculates noise_baseline and noise_std
            # needed to run auto noise threshold mode
            # it is not used for signal to noise nor 
            # relative abudance methods
            abundances_chunks = chunks(self.abundance, 50)
            each_min_abund = [min(x) for x in abundances_chunks]

            return average(each_min_abund), std(each_min_abund)
        
        else:

            mz_cut, abundance_cut = self.cut_mz_domain_noise(auto)
            
            if auto:

                yminima = self.get_abundance_minima_centroid(mz_cut, abundance_cut)
                
                return self.get_noise_average(yminima, auto=auto, bayes=bayes)

            else:
                
                # pyplot.show()
                return self.get_noise_average(abundance_cut,auto=auto, bayes=bayes)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc" href="MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc">MassSpecCalc</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.cut_mz_domain_noise"><code class="name flex">
<span>def <span class="ident">cut_mz_domain_noise</span></span>(<span>self, auto)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut_mz_domain_noise(self, auto):
    
    min_mz_whole_ms = self.mz_exp_profile.min()
    max_mz_whole_ms = self.mz_exp_profile.max()

    if auto:
        
        # this calculation is taking too long (about 2 seconds)
        number_average_molecular_weight = self.weight_average_molecular_weight(
            profile=True)
       
        # +-200 is a guess for testing only, it needs adjustment for each type of analysis
        # need to check min mz here or it will break
        min_mz_noise = number_average_molecular_weight - 100
        # need to check max mz here or it will break
        max_mz_noise = number_average_molecular_weight + 100

    else:

        min_mz_noise = self.settings.min_noise_mz
        max_mz_noise = self.settings.max_noise_mz

    if min_mz_noise &lt; min_mz_whole_ms:
        min_mz_noise = min_mz_whole_ms

    if max_mz_noise &gt; max_mz_whole_ms:
        max_mz_noise = max_mz_whole_ms

    #print(min_mz_noise, max_mz_noise)
    low_mz_index = (where(self.mz_exp_profile &gt;= min_mz_noise)[0][0])
    #print(self.mz_exp_profile[low_mz_index])
    # low_mz_index = (argmax(self.mz_exp_profile &lt;= min_mz_noise))
    
    high_mz_index = (where(self.mz_exp_profile &lt;= max_mz_noise)[-1][-1])
    
    #high_mz_index = (argmax(self.mz_exp_profile &lt;= max_mz_noise))
    
    if high_mz_index &gt; low_mz_index:
        # pyplot.plot(self.mz_exp_profile[low_mz_index:high_mz_index], self.abundance_profile[low_mz_index:high_mz_index])
        # pyplot.show()
        return self.mz_exp_profile[high_mz_index:low_mz_index], self.abundance_profile[low_mz_index:high_mz_index]
    else:
        # pyplot.plot(self.mz_exp_profile[high_mz_index:low_mz_index], self.abundance_profile[high_mz_index:low_mz_index])
        # pyplot.show()
        return self.mz_exp_profile[high_mz_index:low_mz_index], self.abundance_profile[high_mz_index:low_mz_index]</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.error_model_from_trace"><code class="name flex">
<span>def <span class="ident">error_model_from_trace</span></span>(<span>self, trace, ymincentroid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_model_from_trace(self, trace, ymincentroid):
     
    import pymc3 as pm
    #from pymc3 import traceplot, plot_posterior
    
    with pm.Model() as model2:
        
        sd = self.from_posterior(&#39;sd&#39;, trace[&#39;sd&#39;])
        y = pm.HalfNormal(&#39;y&#39;, sd=sd, observed=ymincentroid)
        start = pm.find_MAP()
        step = pm.NUTS() # Hamiltonian MCMC with No U-Turn Sampler
        trace = pm.sample(1000, step, start, random_seed=123, progressbar=True, tune=1000)
        pm.summary(trace)
        #plot_posterior(trace)
        #traceplot(trace)    
        return pm.summary(trace)[&#39;mean&#39;].values[0] </code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.from_posterior"><code class="name flex">
<span>def <span class="ident">from_posterior</span></span>(<span>self, param, samples)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_posterior(self, param, samples):

    import pymc3 as pm
    import numpy as np
    import theano.tensor as tt
    from theano import as_op
    from scipy.stats import gaussian_kde
    
    smin, smax = np.min(samples), np.max(samples)
    width = smax - smin
    x = np.linspace(smin, smax, 100)
    y = gaussian_kde(samples)(x)
    
    # what was never sampled should have a small probability but not 0,
    # so we&#39;ll extend the domain and use linear approximation of density on it
    x = np.concatenate([[x[0] - 3 * width], x, [x[-1] + 3 * width]])
    y = np.concatenate([[0], y, [0]])
    
    return pm.distributions.Interpolated(param, x, y)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.get_abundance_minima_centroid"><code class="name flex">
<span>def <span class="ident">get_abundance_minima_centroid</span></span>(<span>self, mz_cut, abun_cut)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_abundance_minima_centroid(self, mz_cut, abun_cut):

    maximum = self.abundance_profile.max()
    threshold_min = (maximum * 1.00)

    y = -abun_cut

    dy = y[1:] - y[:-1]
    &#39;&#39;&#39;replaces NaN for Infinity&#39;&#39;&#39;
    indices_nan = where(isnan(y))[0]
    
    if indices_nan.size:

        y[indices_nan] = inf
        dy[where(isnan(dy))[0]] = inf

    
    indices = where((hstack((dy, 0)) &lt; 0) &amp; (hstack((0, dy)) &gt; 0))[0]
    
    if indices.size and threshold_min is not None:
        indices = indices[abun_cut[indices] &lt;= threshold_min]

    # pyplot.plot(mz_cut[indices], abun_cut[indices], linewidth=0, marker=&#39;o&#39;, color=&#39;red&#39;, markersize=2)
    # pyplot.show()

    # pyplot.hist(x=abun_cut[indices], bins=&#39;auto&#39;, color=&#39;#0504aa&#39;,
                        # alpha=0.7, rwidth=0.85)
    
    # cutoff = percentile(abun_cut[indices], 0.98)
    
    # print(cutoff)
    
    # pyplot.show()    
    return abun_cut[indices]</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.get_noise_average"><code class="name flex">
<span>def <span class="ident">get_noise_average</span></span>(<span>self, ymincentroid, auto=True, bayes=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_noise_average(self, ymincentroid, auto=True, bayes=False):
    # assumes noise to be gaussian and estimate noise level by 
    # calculating the valley. If bayes is enable it will 
    # model the valley distributuion as half-Normal and estimate the std
    
    average_noise = median((ymincentroid))*2 if auto else median(ymincentroid)
    
    if bayes:
        
        s_deviation = self.simple_model_error_dist(ymincentroid)
    
    else:
        
        s_deviation = ymincentroid.std()*3 if auto else ymincentroid.std()
        
    return average_noise, s_deviation</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.get_noise_threshold"><code class="name flex">
<span>def <span class="ident">get_noise_threshold</span></span>(<span>self) ‑> ((<class 'float'>, <class 'float'>), (<class 'float'>, <class 'float'>))</span>
</code></dt>
<dd>
<div class="desc"><p>return two tuples (min_mz, max_mz) , (noise_threshold, noise_threshold)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_noise_threshold(self) -&gt; ( (float, float), (float,float) ):
    &#39;&#39;&#39; return two tuples (min_mz, max_mz) , (noise_threshold, noise_threshold)&#39;&#39;&#39;
    
    if self.is_centroid:

        x = min(self.mz_exp), max((self.mz_exp))
        
        if self.settings.threshold_method == &#39;auto&#39;:
            
            abundance_threshold = self.baselise_noise + (self.settings.noise_threshold_std * self.baselise_noise_std)
            y = (abundance_threshold, abundance_threshold)

        elif self.settings.threshold_method == &#39;signal_noise&#39;:

            normalized_threshold = (self.max_abundance * self.settings.s2n_threshold )/self.max_signal_to_noise
            y = (normalized_threshold, normalized_threshold)
        
        elif self.settings.threshold_method == &#34;relative_abundance&#34;:

            normalized_threshold = (max(self.abundance)/100)*self.settings.relative_abundance_threshold
            y = (normalized_threshold, normalized_threshold)    
        
        else:
                raise  Exception(&#34;%s method was not implemented, please refer to corems.mass_spectrum.calc.NoiseCalc Class&#34; % self.settings.threshold_method)
            
        return x, y    

    else:

        if self.baselise_noise and self.baselise_noise_std:
            
            x = (self.mz_exp_profile.min(), self.mz_exp_profile.max())
            y = (self.baselise_noise_std, self.baselise_noise_std)
            
            if self.settings.threshold_method == &#39;auto&#39;:
            
                #print(self.settings.noise_threshold_std)
                abundance_threshold = self.baselise_noise + (self.settings.noise_threshold_std * self.baselise_noise_std)
                
                y = (abundance_threshold, abundance_threshold)

            elif self.settings.threshold_method == &#39;signal_noise&#39;:

                max_sn = self.abundance_profile.max()/self.baselise_noise_std

                normalized_threshold = (self.abundance_profile.max() * self.settings.s2n_threshold )/max_sn
                y = (normalized_threshold, normalized_threshold)

            elif self.settings.threshold_method == &#34;relative_abundance&#34;:

                normalized_threshold = (self.abundance_profile.max()/100)*self.settings.relative_abundance_threshold
                y = (normalized_threshold, normalized_threshold)
                

            else:
                raise  Exception(&#34;%s method was not implemented, \
                    please refer to corems.mass_spectrum.calc.NoiseCalc Class&#34; % self.settings.threshold_method)
            
            return x, y
        
        else:
            
            warnings.warn(
                &#34;Noise Baseline and Noise std not specified,\
                defaulting to 0,0 run process_mass_spec() ?&#34;
            )    
            return (0,0) , (0,0)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.run_noise_threshold_calc"><code class="name flex">
<span>def <span class="ident">run_noise_threshold_calc</span></span>(<span>self, auto, bayes=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_noise_threshold_calc(self, auto, bayes=False):
    
    if self.is_centroid:
        # calculates noise_baseline and noise_std
        # needed to run auto noise threshold mode
        # it is not used for signal to noise nor 
        # relative abudance methods
        abundances_chunks = chunks(self.abundance, 50)
        each_min_abund = [min(x) for x in abundances_chunks]

        return average(each_min_abund), std(each_min_abund)
    
    else:

        mz_cut, abundance_cut = self.cut_mz_domain_noise(auto)
        
        if auto:

            yminima = self.get_abundance_minima_centroid(mz_cut, abundance_cut)
            
            return self.get_noise_average(yminima, auto=auto, bayes=bayes)

        else:
            
            # pyplot.show()
            return self.get_noise_average(abundance_cut,auto=auto, bayes=bayes)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.simple_model_error_dist"><code class="name flex">
<span>def <span class="ident">simple_model_error_dist</span></span>(<span>self, ymincentroid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simple_model_error_dist(self,  ymincentroid):
    
    import pymc3 as pm
    # from pymc3 import traceplot, plot_posterior
    #import seaborn as sns
    #f, ax = pyplot.subplots(figsize=(6, 6))
    #sns.distplot(ymincentroid)
    #sns.kdeplot(ymincentroid, ax=ax, shade=True, color=&#34;g&#34;)
    #sns.rugplot(ymincentroid, color=&#34;black&#34;, ax=ax)
    #ax.set(xlabel= &#34;Peak Minima Magnitude&#34;, ylabel= &#34;Density&#34;)
    #pyplot.show()

    with pm.Model() as model:
        
        #mu = pm.Uniform(&#39;mu&#39;, lower=-1, upper=1)
        lower = ymincentroid.min()
        upper = ymincentroid.max()
        
        sd = pm.Uniform(&#39;sd&#39;, lower=lower , upper=upper)
        
        y = pm.HalfNormal(&#39;y&#39;, sd=sd, observed=ymincentroid)
        
        start = pm.find_MAP()
        step = pm.NUTS() # Hamiltonian MCMC with No U-Turn Sampler
        trace = pm.sample(1000, step, start, random_seed=123, progressbar=True, tune=1000)
        
        return pm.summary(trace)[&#39;mean&#39;].values[0] </code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.mass_spectrum.calc" href="index.html">corems.mass_spectrum.calc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc" href="#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc">NoiseThresholdCalc</a></code></h4>
<ul class="">
<li><code><a title="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.cut_mz_domain_noise" href="#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.cut_mz_domain_noise">cut_mz_domain_noise</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.error_model_from_trace" href="#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.error_model_from_trace">error_model_from_trace</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.from_posterior" href="#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.from_posterior">from_posterior</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.get_abundance_minima_centroid" href="#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.get_abundance_minima_centroid">get_abundance_minima_centroid</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.get_noise_average" href="#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.get_noise_average">get_noise_average</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.get_noise_threshold" href="#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.get_noise_threshold">get_noise_threshold</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.run_noise_threshold_calc" href="#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.run_noise_threshold_calc">run_noise_threshold_calc</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.simple_model_error_dist" href="#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.simple_model_error_dist">simple_model_error_dist</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>