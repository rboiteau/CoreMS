<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.mass_spectrum.factory.MassSpectrumClasses API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.mass_spectrum.factory.MassSpectrumClasses</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from pathlib import Path
from copy import deepcopy


#from matplotlib import rcParamsDefault, rcParams
from numpy import array, power, float64, where

from corems.mass_spectrum.calc.MassSpectrumCalc import MassSpecCalc
from corems.mass_spectrum.calc.KendrickGroup import KendrickGrouping
from corems.encapsulation.constant import Labels
from corems.ms_peak.factory.MSPeakClasses import ICRMassPeak as MSPeak
from corems.encapsulation.factory.parameters import MSParameters
from corems.encapsulation.input.parameter_from_json import load_and_set_parameters_ms

__author__ = &#34;Yuri E. Corilo&#34;
__date__ = &#34;Jun 12, 2019&#34;

def overrides(interface_class):
    def overrider(method):
        assert method.__name__ in dir(interface_class)
        return method
    return overrider

class MassSpecBase(MassSpecCalc, KendrickGrouping):
    &#39;&#39;&#39;
    - A iterative mass spectrum base class, stores the profile data and instrument settings
    - Iteration over a list of MSPeaks classes stored at the _mspeaks attributes
    - _mspeaks is populated under the hood by calling process_mass_spec method
    - iteration is null if _mspeaks is empty

    Parameters
    ----------
    mz_exp : list(float)
        list containing the imported experiemental m/z 
        (default is to store profile mode data, but it depends on the input type)
    abundance: list(float)
        list containing the imported abundance 
        (default is to store profile mode data, but it depends on the input type)
    d_params : dict{&#39;str&#39;: float,int and str}
        The keyword arguments are used for ...

    Attributes
    ----------
    _mz_exp : list(float)
        This is where we store mz_exp,
    _abundance : list(float)     
        This is where we store _abundance,
    _mspeaks : list(MSPeak)
        store MSpeaks objects identified by a peak picking algorithm

    Relevant Methods
    ----------
    process_mass_spec()
        find or set the noise threshold base on the setting encapsulated at settings.input.ProcessingSetting.MassSpectrumSetting
        - run the peak peaking algorithm and use the method addMSPeaks() to populate _mspeaks attribute

    see also: MassSpecCentroid(), MassSpecfromFreq(), MassSpecProfile()
    &#39;&#39;&#39;
    def __init__(self, mz_exp, abundance, d_params, **kwargs):

        self._abundance = array(abundance, dtype=float64)
        self._mz_exp = array(mz_exp, dtype=float64)

        # objects created after process_mass_spec() function
        self._mspeaks = list()
        self._dict_nominal_masses_indexes = dict()
        self._baselise_noise = 0.001
        self._baselise_noise_std = 0.001
        self._dynamic_range = None
        # set to None: initialization occurs inside subclass MassSpecfromFreq
        self._transient_settings = None
        self._frequency_domain = None
        self._mz_cal_profile = None
        self.is_calibrated = False

        self._set_parameters_objects(d_params)
        self._init_settings()

        self.is_centroid = False
        self.has_frequency = False

        self.calibration_order = None
        self.calibration_points = None
        self.calibration_RMS = None

    def _init_settings(self):

        self._parameters = MSParameters()

    def __len__(self):

        return len(self.mspeaks)

    def __getitem__(self, position):

        return self.mspeaks[position]

    def set_indexes(self, list_indexes):
        &#39;&#39;&#39; set the mass spectrum to interate over only the selected MSpeaks indexes&#39;&#39;&#39;
        self.mspeaks = [self._mspeaks[i] for i in list_indexes]

        for i, mspeak in  enumerate(self.mspeaks): mspeak.index = i

        self._set_nominal_masses_start_final_indexes()

    def reset_indexes(self):
        &#39;&#39;&#39; reset the mass spectrum to interate over all MSpeaks obj&#39;&#39;&#39;
        self.mspeaks = self._mspeaks

        for i, mspeak in  enumerate(self.mspeaks): mspeak.index = i

        self._set_nominal_masses_start_final_indexes()

    def add_mspeak(self, ion_charge, mz_exp,
                    abundance,
                    resolving_power,
                    signal_to_noise,
                    massspec_indexes,
                    exp_freq=None,
                    ms_parent=None
                ):

        mspeak = MSPeak(
                ion_charge,
                mz_exp,
                abundance,
                resolving_power,
                signal_to_noise,
                massspec_indexes,
                len(self._mspeaks),
                exp_freq=exp_freq,
                ms_parent=ms_parent,
        )

        self._mspeaks.append(mspeak)

    def _set_parameters_objects(self, d_params):

        self._calibration_terms = (
            d_params.get(&#34;Aterm&#34;),
            d_params.get(&#34;Bterm&#34;),
            d_params.get(&#34;Cterm&#34;),
        )

        self.label = d_params.get(Labels.label)

        self.analyzer = d_params.get(&#39;analyzer&#39;)

        self.instrument_label = d_params.get(&#39;instrument_label&#39;)

        self.polarity = int(d_params.get(&#34;polarity&#34;))

        self.scan_number = d_params.get(&#34;scan_number&#34;)

        self.rt = d_params.get(&#34;rt&#34;)

        self.mobility_rt = d_params.get(&#34;mobility_rt&#34;)

        self.mobility_scan = d_params.get(&#34;mobility_scan&#34;)

        self._filename = d_params.get(&#34;filename_path&#34;)

        self._dir_location = d_params.get(&#34;dir_location&#34;)

        self._baselise_noise = d_params.get(&#34;baselise_noise&#34;)

        self._baselise_noise_std = d_params.get(&#34;baselise_noise_std&#34;)

        if d_params.get(&#39;sample_name&#39;) != &#39;Unknown&#39;:

            self.sample_name = d_params.get(&#39;sample_name&#39;)
            if not self.sample_name:
                self.sample_name = self.filename.stem
        else:

            self.sample_name = self.filename.stem

    def reset_cal_therms(self, Aterm, Bterm, C, fas= 0):

        self._calibration_terms = (Aterm, Bterm, C)

        self._mz_exp = self._f_to_mz()
        self._abundance = self._abundance
        self.find_peaks()
        self.reset_indexes()
        # self.reset_indexes()

    def clear_molecular_formulas(self):

        self.check_mspeaks()
        return array([mspeak.clear_molecular_formulas() for mspeak in self.mspeaks])

    def process_mass_spec(self, keep_profile=True, auto_noise=True, noise_bayes_est=False):
        
        # if runned mannually make sure to rerun filter_by_noise_threshold     
        # calculates noise threshold 
        # do peak picking( create mspeak_objs) 
        # reset mspeak_obj the indexes
         
        self.cal_noise_threshold(auto=auto_noise, bayes=noise_bayes_est)

        self.find_peaks()
        self.reset_indexes()

        if self.mspeaks:
            self._dynamic_range = self.max_abundance / self.min_abundance
        else:
            self._dynamic_range = 0
        if not keep_profile:

            self._abundance *= 0
            self._mz_exp *= 0
            

    def cal_noise_threshold(self, auto=True, bayes=False):

        if self.label == Labels.simulated_profile:

            self._baselise_noise, self._baselise_noise_std = 0.1, 1

        else:

            self._baselise_noise, self._baselise_noise_std = self.run_noise_threshold_calc(auto, bayes=bayes)
        
    @property
    def parameters(self):
        return self._parameters

    @parameters.setter
    def parameters(self, instance_MSParameters):
        self._parameters = instance_MSParameters

    def set_parameter_from_json(self, parameters_path):
        load_and_set_parameters_ms(self, parameters_path=parameters_path)    

    @property
    def mspeaks_settings(self): return self.parameters.ms_peak

    @mspeaks_settings.setter
    def mspeaks_settings(self, instance_MassSpecPeakSetting):

            self.parameters.ms_peak = instance_MassSpecPeakSetting

    @property
    def settings(self): return self.parameters.mass_spectrum

    @settings.setter
    def settings(self, instance_MassSpectrumSetting):

        self.parameters.mass_spectrum =  instance_MassSpectrumSetting

    @property
    def molecular_search_settings(self):  return self.parameters.molecular_search

    @molecular_search_settings.setter
    def molecular_search_settings(self, instance_MolecularFormulaSearchSettings):

        self.parameters.molecular_search =  instance_MolecularFormulaSearchSettings

    @property
    def freq_exp_profile(self):
        return self._frequency_domain

    @property
    def mz_cal_profile(self):

        return self._mz_cal_profile

    @mz_cal_profile.setter
    def mz_cal_profile(self, mz_cal_list):

        if len(mz_cal_list) == len(self.mz_exp_profile):
            self._mz_cal_profile = mz_cal_list
        else:
            raise Exception( &#34;calibrated array (%i) is not of the same size of the data (%i)&#34; % (len(mz_cal_list),  len(self.mz_exp_profile)))    

    @property
    def mz_cal(self):
        return array([mspeak.mz_cal for mspeak in self.mspeaks])

    @mz_cal.setter
    def mz_cal(self, mz_cal_list):

            if  len(mz_cal_list) == len(self.mspeaks):
                self.is_calibrated = True
                for index, mz_cal in enumerate(mz_cal_list):
                    self.mspeaks[index].mz_cal = mz_cal
            else: 
                raise Exception( &#34;calibrated array (%i) is not of the same size of the data (%i)&#34; % (len(mz_cal_list),  len(self._mspeaks)))    

    @property
    def mz_exp(self):

        self.check_mspeaks()

        if self.is_calibrated:

            return array([mspeak.mz_cal for mspeak in self.mspeaks])

        else:

            return array([mspeak.mz_exp for mspeak in self.mspeaks])

    @property
    def mz_exp_profile(self): return self._mz_exp

    @mz_exp_profile.setter
    def mz_exp_profile(self, _mz_exp ): self._mz_exp = _mz_exp

    @property
    def abundance_profile(self): return self._abundance

    @abundance_profile.setter
    def abundance_profile(self, _abundance): return self._abundance

    @property
    def abundance(self):
        self.check_mspeaks()
        return array([mspeak.abundance for mspeak in self.mspeaks])

    def freq_exp(self):
        self.check_mspeaks()
        return array([mspeak.freq_exp for mspeak in self.mspeaks])

    @property
    def resolving_power(self):
        self.check_mspeaks()
        return array([mspeak.resolving_power for mspeak in self.mspeaks])

    @property
    def signal_to_noise(self):
        self.check_mspeaks()
        return array([mspeak.signal_to_noise for mspeak in self.mspeaks])

    @property
    def nominal_mz(self):

        if self._dict_nominal_masses_indexes:

            return sorted(list(self._dict_nominal_masses_indexes.keys()))

        else:

            raise ValueError(&#34;Nominal indexes not yet set&#34;)    

    def get_mz_and_abundance_peaks_tuples(self):

        self.check_mspeaks()
        return [(mspeak.mz_exp, mspeak.abundance) for mspeak in self.mspeaks]

    @property
    def kmd(self):
        self.check_mspeaks()
        return array([mspeak.kmd for mspeak in self.mspeaks])

    @property
    def kendrick_mass(self):
        self.check_mspeaks()
        return array([mspeak.kendrick_mass for mspeak in self.mspeaks])

    @property
    def max_mz_exp(self):
        return max([mspeak.mz_exp for mspeak in self.mspeaks])

    @property
    def min_mz_exp(self):
        return min([mspeak.mz_exp for mspeak in self.mspeaks])

    @property
    def max_abundance(self):
        
        return max([mspeak.abundance for mspeak in self.mspeaks])

    @property
    def max_signal_to_noise(self):
        return max([mspeak.signal_to_noise for mspeak in self.mspeaks])

    @property
    def most_abundant_mspeak(self):
        return max(self.mspeaks, key=lambda m: m.abundance)

    @property
    def min_abundance(self):
        return min([mspeak.abundance for mspeak in self.mspeaks])

    # takes too much cpu time 
    @property
    def dynamic_range(self):
        return self._dynamic_range

    @property
    def baselise_noise(self):
        if self._baselise_noise:
            return self._baselise_noise
        else:     
            return None

    @property
    def baselise_noise_std(self):
        if self._baselise_noise_std:
            return self._baselise_noise_std
        else:     
            return None

    @property
    def Aterm(self):
        return self._calibration_terms[0]

    @property
    def Bterm(self):
        return self._calibration_terms[1]

    @property
    def Cterm(self):
        return self._calibration_terms[2]


    @property
    def filename(self):
        return Path(self._filename)

    @property
    def dir_location(self):
        return self._dir_location

    def sort_by_mz(self):
        return sorted(self, key=lambda m: m.mz_exp)

    def sort_by_abundance(self, reverse=False):
        return sorted(self, key=lambda m: m.abundance, reverse=reverse)

    @property
    def tic(self):

        return sum(self.abundance_profile)

    def check_mspeaks_warning(self):
        import warnings
        if self.mspeaks:
            pass
        else:
            warnings.warn(
                &#34;mspeaks list is empty, continuing without filtering data&#34;
            )

    def check_mspeaks(self):
        if self.mspeaks:
            pass
        else:
            raise Exception(
                &#34;mspeaks list is empty, please run process_mass_spec() first&#34;
            )

    def remove_assignment_by_index(self, indexes):
        for i in indexes: self.mspeaks[i].clear_molecular_formulas()

    def filter_by_index(self, list_indexes):

        self.mspeaks = [self.mspeaks[i] for i in range(len(self.mspeaks)) if i not in list_indexes]

        for i, mspeak in  enumerate(self.mspeaks): mspeak.index = i

        self._set_nominal_masses_start_final_indexes()

    def filter_by_mz(self, min_mz, max_mz):

        self.check_mspeaks_warning()
        indexes = [index for index, mspeak in enumerate(self.mspeaks) if min_mz &lt;= mspeak.mz_exp &lt;= max_mz]
        self.filter_by_index(indexes)

    def filter_by_s2n(self, min_s2n, max_s2n=False):

        self.check_mspeaks_warning()
        if not max_s2n:
            max_s2n = self.max_signal_to_noise

        self.check_mspeaks_warning()
        indexes = [index for index, mspeak in enumerate(self.mspeaks) if min_s2n &lt;= mspeak.signal_to_noise &lt;= max_s2n ]
        self.filter_by_index(indexes)

    def filter_by_abundance(self, min_abund, max_abund=False):

        self.check_mspeaks_warning()
        if not max_abund:
            max_abund = self.max_abundance
        indexes = [index for index, mspeak in enumerate(self.mspeaks) if min_abund &lt;= mspeak.abundance &lt;= max_abund]
        self.filter_by_index(indexes)

    def filter_by_max_resolving_power(self, B, T):

        rpe = lambda m, z: (1.274e7 * z * B * T)/(m*z)

        self.check_mspeaks_warning()

        indexes_to_remove = [index for index, mspeak in enumerate(self.mspeaks) if  mspeak.resolving_power &gt;= rpe(mspeak.mz_exp,mspeak.ion_charge)]
        self.filter_by_index(indexes_to_remove)

    def filter_by_min_resolving_power(self, B, T):

        rpe = lambda m, z: (1.274e7 * z * B * T)/(m*z)

        self.check_mspeaks_warning()

        indexes_to_remove = [index for index, mspeak in enumerate(self.mspeaks) if  mspeak.resolving_power &lt;= rpe(mspeak.mz_exp,mspeak.ion_charge)]
        self.filter_by_index(indexes_to_remove)

    def filter_by_noise_threshold(self):
        
        threshold = self.get_noise_threshold()[1][0]
        
        self.check_mspeaks_warning()
        
        indexes_to_remove = [index for index, mspeak in enumerate(self.mspeaks) if  mspeak.abundance &lt;= threshold]
        self.filter_by_index(indexes_to_remove)

    
    def find_peaks(self):
        &#34;&#34;&#34;needs to clear previous results from peak_picking&#34;&#34;&#34;
        self._mspeaks = list()
        &#34;&#34;&#34;then do peak picking&#34;&#34;&#34;

        self.do_peak_picking()
        # print(&#34;A total of %i peaks were found&#34; % len(self._mspeaks))

    def change_kendrick_base_all_mspeaks(self, kendrick_dict_base):
        &#34;&#34;&#34;kendrick_dict_base = {&#34;C&#34;: 1, &#34;H&#34;: 2} or {{&#34;C&#34;: 1, &#34;H&#34;: 1, &#34;O&#34;:1} etc &#34;&#34;&#34;

        self.parameters.ms_peak.kendrick_base = kendrick_dict_base

        for mspeak in self.mspeaks:

            mspeak.change_kendrick_base(kendrick_dict_base)

    def get_nominal_mz_first_last_indexes(self, nominal_mass):

        if self._dict_nominal_masses_indexes:

            if nominal_mass in self._dict_nominal_masses_indexes.keys():

                return (self._dict_nominal_masses_indexes.get(nominal_mass)[0], self._dict_nominal_masses_indexes.get(nominal_mass)[1]+1)

            else:
                # import warnings
                # uncomment warn to distribution
                # warnings.warn(&#34;Nominal mass not found in _dict_nominal_masses_indexes, returning (0, 0) for nominal mass %i&#34;%nominal_mass)
                return (0, 0)
        else:
            raise Exception(&#34;run process_mass_spec() function before trying to access the data&#34;)

    def get_masses_count_by_nominal_mass(self):

        dict_nominal_masses_count = {}

        all_nominal_masses = list(set([i.nominal_mz_exp for i in self.mspeaks]))

        for nominal_mass in all_nominal_masses:
            if nominal_mass not in dict_nominal_masses_count:
                dict_nominal_masses_count[nominal_mass] = len(list(self.get_nominal_mass_indexes(nominal_mass)))

        return dict_nominal_masses_count

    def datapoints_count_by_nominal_mz(self, mz_overlay=0.1):

        dict_nominal_masses_count ={}

        all_nominal_masses = list(set([i.nominal_mz_exp for i in self.mspeaks]))

        for nominal_mass in all_nominal_masses:

            if nominal_mass not in dict_nominal_masses_count:

                min_mz = nominal_mass - mz_overlay

                max_mz = nominal_mass + 1 + mz_overlay

                indexes = indexes = where((self.mz_exp_profile &gt; min_mz) &amp; (self.mz_exp_profile &lt; max_mz)) 

                dict_nominal_masses_count[nominal_mass] = indexes[0].size

        return dict_nominal_masses_count

    def get_nominal_mass_indexes(self, nominal_mass, overlay=0.1):

        min_mz_to_look = nominal_mass - overlay
        max_mz_to_look = nominal_mass + 1 + overlay

        return (i for i in range(len(self.mspeaks)) if min_mz_to_look &lt;= self.mspeaks[i].mz_exp &lt;= max_mz_to_look)

        # indexes = (i for i in range(len(self.mspeaks)) if min_mz_to_look &lt;= self.mspeaks[i].mz_exp &lt;= max_mz_to_look)
        # return indexes

    def _set_nominal_masses_start_final_indexes(self):

        &#39;&#39;&#39;return ms peaks objs indexes(start and end) on the mass spectrum for all nominal masses&#39;&#39;&#39;
        dict_nominal_masses_indexes ={}

        all_nominal_masses = set(i.nominal_mz_exp for i in self.mspeaks)

        for nominal_mass in all_nominal_masses:

            indexes = self.get_nominal_mass_indexes(nominal_mass)

            defaultvalue = None
            first = last = next(indexes, defaultvalue)
            for last in indexes:
                pass

            dict_nominal_masses_indexes[nominal_mass] = (first, last)

        self._dict_nominal_masses_indexes = dict_nominal_masses_indexes

    def plot_centroid(self, ax=None, c=&#39;g&#39;):

        import matplotlib.pyplot as plt
        if self._mspeaks:

            if ax is None:
                ax = plt.gca()

            markerline_a, stemlines_a, baseline_a = ax.stem(self.mz_exp, self.abundance, linefmt=&#39;-&#39;, markerfmt=&#34; &#34;, use_line_collection=True)

            plt.setp(markerline_a, &#39;color&#39;, c, &#39;linewidth&#39;, 2)
            plt.setp(stemlines_a, &#39;color&#39;, c, &#39;linewidth&#39;, 2)
            plt.setp(baseline_a, &#39;color&#39;, c, &#39;linewidth&#39;, 2)

            ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
            ax.set_ylabel(&#39;Abundance&#39;, fontsize=12)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

            ax.axes.spines[&#39;top&#39;].set_visible(False)
            ax.axes.spines[&#39;right&#39;].set_visible(False)

            ax.get_yaxis().set_visible(False)
            ax.spines[&#39;left&#39;].set_visible(False)

        else:

            raise Exception(&#34;No centroid data found, please run process_mass_spec&#34;)

        return ax


    def plot_profile_and_noise_threshold(self, ax=None): 

        import matplotlib.pyplot as plt
        if self.baselise_noise_std and self.baselise_noise_std:

            # x = (self.mz_exp_profile.min(), self.mz_exp_profile.max())
            baseline = (self.baselise_noise, self.baselise_noise)

            # std = self.parameters.mass_spectrum.noise_threshold_std
            # threshold = self.baselise_noise_std + (std * self.baselise_noise_std)
            x, y = self.get_noise_threshold()    
            
            if ax is None:
                ax = plt.gca()
            
            ax.plot(self.mz_exp_profile, self.abundance_profile, color=&#34;green&#34;)
            ax.plot(x, (baseline, baseline), color=&#34;yellow&#34;)
            ax.plot(x, y, color=&#34;red&#34;)

            ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
            ax.set_ylabel(&#39;Abundance&#39;, fontsize=12)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

            ax.axes.spines[&#39;top&#39;].set_visible(False)
            ax.axes.spines[&#39;right&#39;].set_visible(False)

            ax.get_yaxis().set_visible(False)
            ax.spines[&#39;left&#39;].set_visible(False)

        else:

            raise Exception(&#34;Calculate noise threshold first&#34;)

        return ax

    def plot_mz_domain_profile(self, color=&#39;green&#39;, ax=None): #pragma: no cover

        import matplotlib.pyplot as plt

        if ax is None:
            ax = plt.gca()
        ax.plot(self.mz_exp_profile, self.abundance_profile, color=color)
        ax.set(xlabel=&#39;m/z&#39;, ylabel=&#39;abundance&#39;)

        return ax

    def to_excel(self, out_file_path):

        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS = HighResMassSpecExport(out_file_path, self)
        exportMS.to_excel()

    def to_hdf(self, out_file_path):
        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS = HighResMassSpecExport(out_file_path, self)
        exportMS.to_hdf()

    def to_csv(self, out_file_path):
        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS = HighResMassSpecExport(out_file_path, self)
        exportMS.to_csv()

    def to_pandas(self, out_file_path):
        # pickle dataframe (pkl extension)
        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS = HighResMassSpecExport(out_file_path, self)
        exportMS.to_pandas()

    def to_dataframe(self,):
        # returns pandas dataframe

        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS = HighResMassSpecExport(self.filename, self)
        return exportMS.get_pandas_df()

    def to_json(self):
        # returns pandas dataframe

        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS = HighResMassSpecExport(self.filename, self)
        return exportMS.to_json()

    def parameters_json(self):

        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS = HighResMassSpecExport(self.filename, self)
        return exportMS.parameters_to_json()

class MassSpecProfile(MassSpecBase):
    &#39;&#39;&#39;
    - A iterative mass spectrum class when the entry point is on profile format
    - Stores the profile data and instrument settings
    - Iteration over a list of MSPeaks classes stored at the _mspeaks attributes
    - _mspeaks is populated under the hood by calling process_mass_spec method
    - iteration is null if _mspeaks is empty

    Parameters
    ----------
    dataframe : pandas Dataframe(Series(floats))
        contains columns [m/z, Abundance, Resolving Power, S/N] 
    d_params : dict{&#39;str&#39;: float, int or str}

    Attributes
    ----------
    _mz_exp : list(float)
        This is where we store mz_exp,
    _abundance : list(float)     
        This is where we store _abundance,
    _mspeaks : list(MSPeak)
        store MSpeaks objects identified by a peak picking algorithm

    Relevant Methods
    ----------
    process_mass_spec()
        find or set the noise threshold base on the setting encapsulated at settings.input.ProcessingSetting.MassSpectrumSetting
        - run the peak peaking algorithm and use the method addMSPeaks() to populate _mspeaks attribute

    see also: MassSpecBase(), MassSpecfromFreq(), MassSpecProfile()
    &#39;&#39;&#39;

    def __init__(self, data_dict, d_params, auto_process=True, auto_noise=True, noise_bayes_est=False):
        &#34;&#34;&#34;
        method docs
        &#34;&#34;&#34;
        # print(data_dict.keys())
        super().__init__(data_dict.get(Labels.mz), data_dict.get(Labels.abundance), d_params)
       
        if auto_process:
            self.process_mass_spec(auto_noise=auto_noise, noise_bayes_est=noise_bayes_est)

class MassSpecfromFreq(MassSpecBase):
    &#39;&#39;&#39;
    - A iterative mass spectrum class when data entry is on frequency(Hz) domain
    - Transform to m/z based on the settings stored at d_params
    - Stores the profile data and instrument settings
    - Iteration over a list of MSPeaks classes stored at the _mspeaks attributes
    - _mspeaks is populated under the hood by calling process_mass_spec method
    - iteration is null if _mspeaks is empty

    Parameters
    ----------
    frequency_domain : list(float)
        all datapoints in frequency domain in Hz
    magnitude :  frequency_domain : list(float)
        all datapoints in for magnitude of each frequency datapoint

    Attributes
    ----------
    _mz_exp : list(float)
        This is where we store mz_exp,
    _frequency_domain : list(float)
        This is where we store _frequency_domain,
    _abundance : list(float)     
        This is where we store _abundance,
    _mspeaks : list(MSPeak)
        store MSpeaks objects identified by a peak picking algorithm     
    label : str
        store label (Bruker, Midas Transient, see Labels class ). It across distinct processing points
    
    Relevant Methods
    ----------
    _set_mz_domain()
        calculates the m_z based on the setting of d_params

    process_mass_spec()
        find or set the noise threshold base on the setting encapsulated at settings.input.ProcessingSetting.MassSpectrumSetting
        - run the peak peaking algorithm and use the method addMSPeaks() to populate _mspeaks attribute
    
    see also: MassSpecBase(), MassSpecfromFreq(), MassSpecProfile()
    &#39;&#39;&#39;

    def __init__(self, frequency_domain, magnitude, d_params, 
                auto_process=True, keep_profile=True, auto_noise=False, noise_bayes_est=False):
        &#34;&#34;&#34;
        method docs
        &#34;&#34;&#34;
        super().__init__(None, magnitude, d_params)

        self._frequency_domain = frequency_domain
        self.has_frequency = True
        self._set_mz_domain()

        
        &#34;&#34;&#34; use this call to automatically process data as the object is created, Setting need to be changed before initiating the class to be in effect&#34;&#34;&#34;
        
        if auto_process:
            self.process_mass_spec(keep_profile=keep_profile, auto_noise=auto_noise, noise_bayes_est=noise_bayes_est)


    def _set_mz_domain(self):

        if self.label == Labels.bruker_frequency:

            self._mz_exp = self._f_to_mz_bruker()

        else:

            self._mz_exp = self._f_to_mz()

    @property
    def transient_settings(self): return self.parameters.transient

    @transient_settings.setter
    def transient_settings(self, instance_TransientSetting):
     
        self.parameters.transient = instance_TransientSetting  


class MassSpecCentroid(MassSpecBase):

    &#39;&#39;&#39;
    - A iterative mass spectrum class when data entry is centroid mode
    - Stores the centroid data and instrument settings
    - Simulate profile data based on Gaussian or Lorentzian peak shape
    - Iteration over a list of MSPeaks classes stored at the _mspeaks attributes
    - _mspeaks is populated under the hood by calling process_mass_spec method
    - iteration is null if _mspeaks is empty

    Parameters
    ----------
    data_dict : dict {string: numpy array float64 )
        contains keys [m/z, Abundance, Resolving Power, S/N] 
    d_params : dict{&#39;str&#39;: float, int or str}
        
    Attributes
    ----------
    _mz_exp : list(float)
        This is where we store mz_exp,
    _abundance : list(float)     
        This is where we store _abundance,
    _mspeaks : list(MSPeak)
        store MSpeaks objects identified by a peak picking algorithm  

    Attributes
    ----------
    _mz_exp : list(float)
        This is where we store mz_exp,
    _frequency_domain : list(float)
        This is where we store _frequency_domain,
    _abundance : list(float)     
        This is where we store _abundance,
    _mspeaks : list(MSPeak)
        store MSpeaks objects identified by a peak picking algorithm     
    label : str
        store label (Bruker, Midas Transient, see Labels class)
    
    Relevant Methods
    ----------
    _set_mz_domain()
        calculates the m_z based on the setting of d_params

    process_mass_spec()
        - overrides the base class function
        - Populates _mspeaks list with MSpeaks class using the centroid date

    see also: MassSpecBase(), MassSpecfromFreq(), MassSpecProfile()
    &#39;&#39;&#39;

    def __init__(self, data_dict, d_params):

        &#34;&#34;&#34;needs to simulate peak shape and pass as mz_exp and magnitude.&#34;&#34;&#34;

        super().__init__([], [], d_params)

        self._set_parameters_objects(d_params)
        
        if self.label == Labels.thermo_centroid:
            self._baselise_noise = d_params.get(&#34;baselise_noise&#34;)
            self._baselise_noise_std = d_params.get(&#34;baselise_noise_std&#34;)

        self.is_centroid = True

        self.process_mass_spec(data_dict)

    def __simulate_profile__data__(self, exp_mz_centroid, magnitude_centroid):
        &#39;&#39;&#39;needs theoretical resolving power calculation and define peak shape
        this is a quick fix to trick a line plot be able to plot as sticks&#39;&#39;&#39;

        x, y = [], []
        for i in range(len(exp_mz_centroid)):
            x.append(exp_mz_centroid[i] - 0.0000001)
            x.append(exp_mz_centroid[i])
            x.append(exp_mz_centroid[i] + 0.0000001)
            y.append(0)
            y.append(magnitude_centroid[i])
            y.append(0)
        return x, y

    @property
    def mz_exp_profile(self):

        mz_list = []
        for mz in self.mz_exp:
            mz_list.append(mz - 0.0000001)
            mz_list.append(mz)
            mz_list.append(mz + 0.0000001)
        return mz_list
    
    @mz_exp_profile.setter
    def mz_exp_profile(self, _mz_exp ): self._mz_exp = _mz_exp

    @property
    def abundance_profile(self):
        ab_list = []
        for ab in self.abundance:
            ab_list.append(0)
            ab_list.append(ab)
            ab_list.append(0)
        return ab_list

    @abundance_profile.setter
    def abundance_profile(self, abundance ): self._abundance = abundance

    @property
    def tic(self):

        return sum(self.abundance)

    def process_mass_spec(self, data_dict, auto_noise=True, noise_bayes_est=False):
        import tqdm
        # overwrite process_mass_spec 
        # mspeak objs are usually added inside the PeaKPicking class 
        # for profile and freq based data
        

        s2n = True
        ion_charge = self.polarity
        #l_exp_mz_centroid = data_dict.get(Labels.mz)
        #l_intes_centr = data_dict.get(Labels.abundance)
        #l_peak_resolving_power = data_dict.get(Labels.rp)
        l_s2n = data_dict.get(Labels.s2n)
        
        if not l_s2n: s2n = False
        
        print(&#34;Loading mass spectrum object&#34;)
        
        for index, mz in enumerate(data_dict.get(Labels.mz)):
            
            # centroid peak does not have start and end peak index pos
            massspec_indexes = (index, index, index)
            
            if s2n:
                
                self.add_mspeak(
                    ion_charge,
                    mz,
                    data_dict.get(Labels.abundance)[index],
                    data_dict.get(Labels.rp)[index],
                    l_s2n[index],
                    massspec_indexes,
                    ms_parent=self
                )

            else:

                self.add_mspeak(
                    ion_charge,
                    mz,
                    data_dict.get(Labels.abundance)[index],
                    data_dict.get(Labels.rp)[index],
                    -999,
                    massspec_indexes,
                    ms_parent=self
                )

        self.mspeaks = self._mspeaks
        self._dynamic_range = self.max_abundance / self.min_abundance
        self._set_nominal_masses_start_final_indexes()
        
        if self.label != Labels.thermo_centroid:
            self._baselise_noise, self._baselise_noise_std = self.run_noise_threshold_calc(auto=auto_noise, bayes=noise_bayes_est)
            
class MassSpecCentroidLowRes(MassSpecCentroid,):
    
    &#39;&#39;&#39;Does not store MSPeak Objs, will iterate over mz, abundance pairs instead&#39;&#39;&#39;
    
    def __init__(self, data_dict, d_params):
    
        self._set_parameters_objects(d_params)
        self._mz_exp = array(data_dict.get(Labels.mz))
        self._abundance = array(data_dict.get(Labels.abundance))
        self._processed_tic = None
    
    def __len__(self):
        
        return len(self.mz_exp)
        
    def __getitem__(self, position):
        
        return (self.mz_exp[position], self.abundance[position])

    @property
    def mz_exp(self):
        
        return self._mz_exp 

    @property
    def abundance(self):

        return self._abundance

    @property
    def processed_tic(self):
    
        return sum(self._processed_tic)
    
    @property
    def tic(self):
    
        if self._processed_tic:
            return self._processed_tic
        else:
            return sum(self.abundance)
    
    @property
    def mz_abun_tuples(self):

        r = lambda x: ( int(round(x[0],0), int(round(x[1],0))) )

        return [r(i) for i in self]
    
    @property
    def mz_abun_dict(self):
        
        r = lambda x: int(round(x,0))
            
        return { r(i[0]):r(i[1]) for i in self}
    
    &#39;&#39;&#39;
    def to_excel(self, out_file_path):
    
    
    exportMS= HighResMassSpecExport(out_file_path, self)
    exportMS.to_excel()


    def to_hdf(self, out_file_path):
        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS= HighResMassSpecExport(out_file_path, self)
        exportMS.to_hdf()

    def to_csv(self, out_file_path):
        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS= HighResMassSpecExport(out_file_path, self)
        exportMS.to_csv()
        
    def to_pandas(self, out_file_path):
        #pickle dataframe (pkl extension)
        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS= HighResMassSpecExport(out_file_path, self)
        exportMS.to_pandas()

    def to_dataframe(self,):
        #returns pandas dataframe
        
        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS= HighResMassSpecExport(self.filename, self)
        return exportMS.get_pandas_df()
       &#39;&#39;&#39; </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.overrides"><code class="name flex">
<span>def <span class="ident">overrides</span></span>(<span>interface_class)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overrides(interface_class):
    def overrider(method):
        assert method.__name__ in dir(interface_class)
        return method
    return overrider</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase"><code class="flex name class">
<span>class <span class="ident">MassSpecBase</span></span>
<span>(</span><span>mz_exp, abundance, d_params, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>A iterative mass spectrum base class, stores the profile data and instrument settings</li>
<li>Iteration over a list of MSPeaks classes stored at the _mspeaks attributes</li>
<li>_mspeaks is populated under the hood by calling process_mass_spec method</li>
<li>iteration is null if _mspeaks is empty</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mz_exp</code></strong> :&ensp;<code>list(float)</code></dt>
<dd>list containing the imported experiemental m/z
(default is to store profile mode data, but it depends on the input type)</dd>
<dt><strong><code>abundance</code></strong> :&ensp;<code>list(float)</code></dt>
<dd>list containing the imported abundance
(default is to store profile mode data, but it depends on the input type)</dd>
<dt><strong><code>d_params</code></strong> :&ensp;<code>dict{'str': float,int and str}</code></dt>
<dd>The keyword arguments are used for &hellip;</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>_mz_exp</code></strong> :&ensp;<code>list(float)</code></dt>
<dd>This is where we store mz_exp,</dd>
<dt><strong><code>_abundance</code></strong> :&ensp;<code>list(float)
</code></dt>
<dd>This is where we store _abundance,</dd>
<dt><strong><code>_mspeaks</code></strong> :&ensp;<code>list(MSPeak)</code></dt>
<dd>store MSpeaks objects identified by a peak picking algorithm</dd>
</dl>
<h2 id="relevant-methods">Relevant Methods</h2>
<p>process_mass_spec()
find or set the noise threshold base on the setting encapsulated at settings.input.ProcessingSetting.MassSpectrumSetting
- run the peak peaking algorithm and use the method addMSPeaks() to populate _mspeaks attribute</p>
<p>see also: MassSpecCentroid(), MassSpecfromFreq(), MassSpecProfile()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MassSpecBase(MassSpecCalc, KendrickGrouping):
    &#39;&#39;&#39;
    - A iterative mass spectrum base class, stores the profile data and instrument settings
    - Iteration over a list of MSPeaks classes stored at the _mspeaks attributes
    - _mspeaks is populated under the hood by calling process_mass_spec method
    - iteration is null if _mspeaks is empty

    Parameters
    ----------
    mz_exp : list(float)
        list containing the imported experiemental m/z 
        (default is to store profile mode data, but it depends on the input type)
    abundance: list(float)
        list containing the imported abundance 
        (default is to store profile mode data, but it depends on the input type)
    d_params : dict{&#39;str&#39;: float,int and str}
        The keyword arguments are used for ...

    Attributes
    ----------
    _mz_exp : list(float)
        This is where we store mz_exp,
    _abundance : list(float)     
        This is where we store _abundance,
    _mspeaks : list(MSPeak)
        store MSpeaks objects identified by a peak picking algorithm

    Relevant Methods
    ----------
    process_mass_spec()
        find or set the noise threshold base on the setting encapsulated at settings.input.ProcessingSetting.MassSpectrumSetting
        - run the peak peaking algorithm and use the method addMSPeaks() to populate _mspeaks attribute

    see also: MassSpecCentroid(), MassSpecfromFreq(), MassSpecProfile()
    &#39;&#39;&#39;
    def __init__(self, mz_exp, abundance, d_params, **kwargs):

        self._abundance = array(abundance, dtype=float64)
        self._mz_exp = array(mz_exp, dtype=float64)

        # objects created after process_mass_spec() function
        self._mspeaks = list()
        self._dict_nominal_masses_indexes = dict()
        self._baselise_noise = 0.001
        self._baselise_noise_std = 0.001
        self._dynamic_range = None
        # set to None: initialization occurs inside subclass MassSpecfromFreq
        self._transient_settings = None
        self._frequency_domain = None
        self._mz_cal_profile = None
        self.is_calibrated = False

        self._set_parameters_objects(d_params)
        self._init_settings()

        self.is_centroid = False
        self.has_frequency = False

        self.calibration_order = None
        self.calibration_points = None
        self.calibration_RMS = None

    def _init_settings(self):

        self._parameters = MSParameters()

    def __len__(self):

        return len(self.mspeaks)

    def __getitem__(self, position):

        return self.mspeaks[position]

    def set_indexes(self, list_indexes):
        &#39;&#39;&#39; set the mass spectrum to interate over only the selected MSpeaks indexes&#39;&#39;&#39;
        self.mspeaks = [self._mspeaks[i] for i in list_indexes]

        for i, mspeak in  enumerate(self.mspeaks): mspeak.index = i

        self._set_nominal_masses_start_final_indexes()

    def reset_indexes(self):
        &#39;&#39;&#39; reset the mass spectrum to interate over all MSpeaks obj&#39;&#39;&#39;
        self.mspeaks = self._mspeaks

        for i, mspeak in  enumerate(self.mspeaks): mspeak.index = i

        self._set_nominal_masses_start_final_indexes()

    def add_mspeak(self, ion_charge, mz_exp,
                    abundance,
                    resolving_power,
                    signal_to_noise,
                    massspec_indexes,
                    exp_freq=None,
                    ms_parent=None
                ):

        mspeak = MSPeak(
                ion_charge,
                mz_exp,
                abundance,
                resolving_power,
                signal_to_noise,
                massspec_indexes,
                len(self._mspeaks),
                exp_freq=exp_freq,
                ms_parent=ms_parent,
        )

        self._mspeaks.append(mspeak)

    def _set_parameters_objects(self, d_params):

        self._calibration_terms = (
            d_params.get(&#34;Aterm&#34;),
            d_params.get(&#34;Bterm&#34;),
            d_params.get(&#34;Cterm&#34;),
        )

        self.label = d_params.get(Labels.label)

        self.analyzer = d_params.get(&#39;analyzer&#39;)

        self.instrument_label = d_params.get(&#39;instrument_label&#39;)

        self.polarity = int(d_params.get(&#34;polarity&#34;))

        self.scan_number = d_params.get(&#34;scan_number&#34;)

        self.rt = d_params.get(&#34;rt&#34;)

        self.mobility_rt = d_params.get(&#34;mobility_rt&#34;)

        self.mobility_scan = d_params.get(&#34;mobility_scan&#34;)

        self._filename = d_params.get(&#34;filename_path&#34;)

        self._dir_location = d_params.get(&#34;dir_location&#34;)

        self._baselise_noise = d_params.get(&#34;baselise_noise&#34;)

        self._baselise_noise_std = d_params.get(&#34;baselise_noise_std&#34;)

        if d_params.get(&#39;sample_name&#39;) != &#39;Unknown&#39;:

            self.sample_name = d_params.get(&#39;sample_name&#39;)
            if not self.sample_name:
                self.sample_name = self.filename.stem
        else:

            self.sample_name = self.filename.stem

    def reset_cal_therms(self, Aterm, Bterm, C, fas= 0):

        self._calibration_terms = (Aterm, Bterm, C)

        self._mz_exp = self._f_to_mz()
        self._abundance = self._abundance
        self.find_peaks()
        self.reset_indexes()
        # self.reset_indexes()

    def clear_molecular_formulas(self):

        self.check_mspeaks()
        return array([mspeak.clear_molecular_formulas() for mspeak in self.mspeaks])

    def process_mass_spec(self, keep_profile=True, auto_noise=True, noise_bayes_est=False):
        
        # if runned mannually make sure to rerun filter_by_noise_threshold     
        # calculates noise threshold 
        # do peak picking( create mspeak_objs) 
        # reset mspeak_obj the indexes
         
        self.cal_noise_threshold(auto=auto_noise, bayes=noise_bayes_est)

        self.find_peaks()
        self.reset_indexes()

        if self.mspeaks:
            self._dynamic_range = self.max_abundance / self.min_abundance
        else:
            self._dynamic_range = 0
        if not keep_profile:

            self._abundance *= 0
            self._mz_exp *= 0
            

    def cal_noise_threshold(self, auto=True, bayes=False):

        if self.label == Labels.simulated_profile:

            self._baselise_noise, self._baselise_noise_std = 0.1, 1

        else:

            self._baselise_noise, self._baselise_noise_std = self.run_noise_threshold_calc(auto, bayes=bayes)
        
    @property
    def parameters(self):
        return self._parameters

    @parameters.setter
    def parameters(self, instance_MSParameters):
        self._parameters = instance_MSParameters

    def set_parameter_from_json(self, parameters_path):
        load_and_set_parameters_ms(self, parameters_path=parameters_path)    

    @property
    def mspeaks_settings(self): return self.parameters.ms_peak

    @mspeaks_settings.setter
    def mspeaks_settings(self, instance_MassSpecPeakSetting):

            self.parameters.ms_peak = instance_MassSpecPeakSetting

    @property
    def settings(self): return self.parameters.mass_spectrum

    @settings.setter
    def settings(self, instance_MassSpectrumSetting):

        self.parameters.mass_spectrum =  instance_MassSpectrumSetting

    @property
    def molecular_search_settings(self):  return self.parameters.molecular_search

    @molecular_search_settings.setter
    def molecular_search_settings(self, instance_MolecularFormulaSearchSettings):

        self.parameters.molecular_search =  instance_MolecularFormulaSearchSettings

    @property
    def freq_exp_profile(self):
        return self._frequency_domain

    @property
    def mz_cal_profile(self):

        return self._mz_cal_profile

    @mz_cal_profile.setter
    def mz_cal_profile(self, mz_cal_list):

        if len(mz_cal_list) == len(self.mz_exp_profile):
            self._mz_cal_profile = mz_cal_list
        else:
            raise Exception( &#34;calibrated array (%i) is not of the same size of the data (%i)&#34; % (len(mz_cal_list),  len(self.mz_exp_profile)))    

    @property
    def mz_cal(self):
        return array([mspeak.mz_cal for mspeak in self.mspeaks])

    @mz_cal.setter
    def mz_cal(self, mz_cal_list):

            if  len(mz_cal_list) == len(self.mspeaks):
                self.is_calibrated = True
                for index, mz_cal in enumerate(mz_cal_list):
                    self.mspeaks[index].mz_cal = mz_cal
            else: 
                raise Exception( &#34;calibrated array (%i) is not of the same size of the data (%i)&#34; % (len(mz_cal_list),  len(self._mspeaks)))    

    @property
    def mz_exp(self):

        self.check_mspeaks()

        if self.is_calibrated:

            return array([mspeak.mz_cal for mspeak in self.mspeaks])

        else:

            return array([mspeak.mz_exp for mspeak in self.mspeaks])

    @property
    def mz_exp_profile(self): return self._mz_exp

    @mz_exp_profile.setter
    def mz_exp_profile(self, _mz_exp ): self._mz_exp = _mz_exp

    @property
    def abundance_profile(self): return self._abundance

    @abundance_profile.setter
    def abundance_profile(self, _abundance): return self._abundance

    @property
    def abundance(self):
        self.check_mspeaks()
        return array([mspeak.abundance for mspeak in self.mspeaks])

    def freq_exp(self):
        self.check_mspeaks()
        return array([mspeak.freq_exp for mspeak in self.mspeaks])

    @property
    def resolving_power(self):
        self.check_mspeaks()
        return array([mspeak.resolving_power for mspeak in self.mspeaks])

    @property
    def signal_to_noise(self):
        self.check_mspeaks()
        return array([mspeak.signal_to_noise for mspeak in self.mspeaks])

    @property
    def nominal_mz(self):

        if self._dict_nominal_masses_indexes:

            return sorted(list(self._dict_nominal_masses_indexes.keys()))

        else:

            raise ValueError(&#34;Nominal indexes not yet set&#34;)    

    def get_mz_and_abundance_peaks_tuples(self):

        self.check_mspeaks()
        return [(mspeak.mz_exp, mspeak.abundance) for mspeak in self.mspeaks]

    @property
    def kmd(self):
        self.check_mspeaks()
        return array([mspeak.kmd for mspeak in self.mspeaks])

    @property
    def kendrick_mass(self):
        self.check_mspeaks()
        return array([mspeak.kendrick_mass for mspeak in self.mspeaks])

    @property
    def max_mz_exp(self):
        return max([mspeak.mz_exp for mspeak in self.mspeaks])

    @property
    def min_mz_exp(self):
        return min([mspeak.mz_exp for mspeak in self.mspeaks])

    @property
    def max_abundance(self):
        
        return max([mspeak.abundance for mspeak in self.mspeaks])

    @property
    def max_signal_to_noise(self):
        return max([mspeak.signal_to_noise for mspeak in self.mspeaks])

    @property
    def most_abundant_mspeak(self):
        return max(self.mspeaks, key=lambda m: m.abundance)

    @property
    def min_abundance(self):
        return min([mspeak.abundance for mspeak in self.mspeaks])

    # takes too much cpu time 
    @property
    def dynamic_range(self):
        return self._dynamic_range

    @property
    def baselise_noise(self):
        if self._baselise_noise:
            return self._baselise_noise
        else:     
            return None

    @property
    def baselise_noise_std(self):
        if self._baselise_noise_std:
            return self._baselise_noise_std
        else:     
            return None

    @property
    def Aterm(self):
        return self._calibration_terms[0]

    @property
    def Bterm(self):
        return self._calibration_terms[1]

    @property
    def Cterm(self):
        return self._calibration_terms[2]


    @property
    def filename(self):
        return Path(self._filename)

    @property
    def dir_location(self):
        return self._dir_location

    def sort_by_mz(self):
        return sorted(self, key=lambda m: m.mz_exp)

    def sort_by_abundance(self, reverse=False):
        return sorted(self, key=lambda m: m.abundance, reverse=reverse)

    @property
    def tic(self):

        return sum(self.abundance_profile)

    def check_mspeaks_warning(self):
        import warnings
        if self.mspeaks:
            pass
        else:
            warnings.warn(
                &#34;mspeaks list is empty, continuing without filtering data&#34;
            )

    def check_mspeaks(self):
        if self.mspeaks:
            pass
        else:
            raise Exception(
                &#34;mspeaks list is empty, please run process_mass_spec() first&#34;
            )

    def remove_assignment_by_index(self, indexes):
        for i in indexes: self.mspeaks[i].clear_molecular_formulas()

    def filter_by_index(self, list_indexes):

        self.mspeaks = [self.mspeaks[i] for i in range(len(self.mspeaks)) if i not in list_indexes]

        for i, mspeak in  enumerate(self.mspeaks): mspeak.index = i

        self._set_nominal_masses_start_final_indexes()

    def filter_by_mz(self, min_mz, max_mz):

        self.check_mspeaks_warning()
        indexes = [index for index, mspeak in enumerate(self.mspeaks) if min_mz &lt;= mspeak.mz_exp &lt;= max_mz]
        self.filter_by_index(indexes)

    def filter_by_s2n(self, min_s2n, max_s2n=False):

        self.check_mspeaks_warning()
        if not max_s2n:
            max_s2n = self.max_signal_to_noise

        self.check_mspeaks_warning()
        indexes = [index for index, mspeak in enumerate(self.mspeaks) if min_s2n &lt;= mspeak.signal_to_noise &lt;= max_s2n ]
        self.filter_by_index(indexes)

    def filter_by_abundance(self, min_abund, max_abund=False):

        self.check_mspeaks_warning()
        if not max_abund:
            max_abund = self.max_abundance
        indexes = [index for index, mspeak in enumerate(self.mspeaks) if min_abund &lt;= mspeak.abundance &lt;= max_abund]
        self.filter_by_index(indexes)

    def filter_by_max_resolving_power(self, B, T):

        rpe = lambda m, z: (1.274e7 * z * B * T)/(m*z)

        self.check_mspeaks_warning()

        indexes_to_remove = [index for index, mspeak in enumerate(self.mspeaks) if  mspeak.resolving_power &gt;= rpe(mspeak.mz_exp,mspeak.ion_charge)]
        self.filter_by_index(indexes_to_remove)

    def filter_by_min_resolving_power(self, B, T):

        rpe = lambda m, z: (1.274e7 * z * B * T)/(m*z)

        self.check_mspeaks_warning()

        indexes_to_remove = [index for index, mspeak in enumerate(self.mspeaks) if  mspeak.resolving_power &lt;= rpe(mspeak.mz_exp,mspeak.ion_charge)]
        self.filter_by_index(indexes_to_remove)

    def filter_by_noise_threshold(self):
        
        threshold = self.get_noise_threshold()[1][0]
        
        self.check_mspeaks_warning()
        
        indexes_to_remove = [index for index, mspeak in enumerate(self.mspeaks) if  mspeak.abundance &lt;= threshold]
        self.filter_by_index(indexes_to_remove)

    
    def find_peaks(self):
        &#34;&#34;&#34;needs to clear previous results from peak_picking&#34;&#34;&#34;
        self._mspeaks = list()
        &#34;&#34;&#34;then do peak picking&#34;&#34;&#34;

        self.do_peak_picking()
        # print(&#34;A total of %i peaks were found&#34; % len(self._mspeaks))

    def change_kendrick_base_all_mspeaks(self, kendrick_dict_base):
        &#34;&#34;&#34;kendrick_dict_base = {&#34;C&#34;: 1, &#34;H&#34;: 2} or {{&#34;C&#34;: 1, &#34;H&#34;: 1, &#34;O&#34;:1} etc &#34;&#34;&#34;

        self.parameters.ms_peak.kendrick_base = kendrick_dict_base

        for mspeak in self.mspeaks:

            mspeak.change_kendrick_base(kendrick_dict_base)

    def get_nominal_mz_first_last_indexes(self, nominal_mass):

        if self._dict_nominal_masses_indexes:

            if nominal_mass in self._dict_nominal_masses_indexes.keys():

                return (self._dict_nominal_masses_indexes.get(nominal_mass)[0], self._dict_nominal_masses_indexes.get(nominal_mass)[1]+1)

            else:
                # import warnings
                # uncomment warn to distribution
                # warnings.warn(&#34;Nominal mass not found in _dict_nominal_masses_indexes, returning (0, 0) for nominal mass %i&#34;%nominal_mass)
                return (0, 0)
        else:
            raise Exception(&#34;run process_mass_spec() function before trying to access the data&#34;)

    def get_masses_count_by_nominal_mass(self):

        dict_nominal_masses_count = {}

        all_nominal_masses = list(set([i.nominal_mz_exp for i in self.mspeaks]))

        for nominal_mass in all_nominal_masses:
            if nominal_mass not in dict_nominal_masses_count:
                dict_nominal_masses_count[nominal_mass] = len(list(self.get_nominal_mass_indexes(nominal_mass)))

        return dict_nominal_masses_count

    def datapoints_count_by_nominal_mz(self, mz_overlay=0.1):

        dict_nominal_masses_count ={}

        all_nominal_masses = list(set([i.nominal_mz_exp for i in self.mspeaks]))

        for nominal_mass in all_nominal_masses:

            if nominal_mass not in dict_nominal_masses_count:

                min_mz = nominal_mass - mz_overlay

                max_mz = nominal_mass + 1 + mz_overlay

                indexes = indexes = where((self.mz_exp_profile &gt; min_mz) &amp; (self.mz_exp_profile &lt; max_mz)) 

                dict_nominal_masses_count[nominal_mass] = indexes[0].size

        return dict_nominal_masses_count

    def get_nominal_mass_indexes(self, nominal_mass, overlay=0.1):

        min_mz_to_look = nominal_mass - overlay
        max_mz_to_look = nominal_mass + 1 + overlay

        return (i for i in range(len(self.mspeaks)) if min_mz_to_look &lt;= self.mspeaks[i].mz_exp &lt;= max_mz_to_look)

        # indexes = (i for i in range(len(self.mspeaks)) if min_mz_to_look &lt;= self.mspeaks[i].mz_exp &lt;= max_mz_to_look)
        # return indexes

    def _set_nominal_masses_start_final_indexes(self):

        &#39;&#39;&#39;return ms peaks objs indexes(start and end) on the mass spectrum for all nominal masses&#39;&#39;&#39;
        dict_nominal_masses_indexes ={}

        all_nominal_masses = set(i.nominal_mz_exp for i in self.mspeaks)

        for nominal_mass in all_nominal_masses:

            indexes = self.get_nominal_mass_indexes(nominal_mass)

            defaultvalue = None
            first = last = next(indexes, defaultvalue)
            for last in indexes:
                pass

            dict_nominal_masses_indexes[nominal_mass] = (first, last)

        self._dict_nominal_masses_indexes = dict_nominal_masses_indexes

    def plot_centroid(self, ax=None, c=&#39;g&#39;):

        import matplotlib.pyplot as plt
        if self._mspeaks:

            if ax is None:
                ax = plt.gca()

            markerline_a, stemlines_a, baseline_a = ax.stem(self.mz_exp, self.abundance, linefmt=&#39;-&#39;, markerfmt=&#34; &#34;, use_line_collection=True)

            plt.setp(markerline_a, &#39;color&#39;, c, &#39;linewidth&#39;, 2)
            plt.setp(stemlines_a, &#39;color&#39;, c, &#39;linewidth&#39;, 2)
            plt.setp(baseline_a, &#39;color&#39;, c, &#39;linewidth&#39;, 2)

            ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
            ax.set_ylabel(&#39;Abundance&#39;, fontsize=12)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

            ax.axes.spines[&#39;top&#39;].set_visible(False)
            ax.axes.spines[&#39;right&#39;].set_visible(False)

            ax.get_yaxis().set_visible(False)
            ax.spines[&#39;left&#39;].set_visible(False)

        else:

            raise Exception(&#34;No centroid data found, please run process_mass_spec&#34;)

        return ax


    def plot_profile_and_noise_threshold(self, ax=None): 

        import matplotlib.pyplot as plt
        if self.baselise_noise_std and self.baselise_noise_std:

            # x = (self.mz_exp_profile.min(), self.mz_exp_profile.max())
            baseline = (self.baselise_noise, self.baselise_noise)

            # std = self.parameters.mass_spectrum.noise_threshold_std
            # threshold = self.baselise_noise_std + (std * self.baselise_noise_std)
            x, y = self.get_noise_threshold()    
            
            if ax is None:
                ax = plt.gca()
            
            ax.plot(self.mz_exp_profile, self.abundance_profile, color=&#34;green&#34;)
            ax.plot(x, (baseline, baseline), color=&#34;yellow&#34;)
            ax.plot(x, y, color=&#34;red&#34;)

            ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
            ax.set_ylabel(&#39;Abundance&#39;, fontsize=12)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

            ax.axes.spines[&#39;top&#39;].set_visible(False)
            ax.axes.spines[&#39;right&#39;].set_visible(False)

            ax.get_yaxis().set_visible(False)
            ax.spines[&#39;left&#39;].set_visible(False)

        else:

            raise Exception(&#34;Calculate noise threshold first&#34;)

        return ax

    def plot_mz_domain_profile(self, color=&#39;green&#39;, ax=None): #pragma: no cover

        import matplotlib.pyplot as plt

        if ax is None:
            ax = plt.gca()
        ax.plot(self.mz_exp_profile, self.abundance_profile, color=color)
        ax.set(xlabel=&#39;m/z&#39;, ylabel=&#39;abundance&#39;)

        return ax

    def to_excel(self, out_file_path):

        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS = HighResMassSpecExport(out_file_path, self)
        exportMS.to_excel()

    def to_hdf(self, out_file_path):
        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS = HighResMassSpecExport(out_file_path, self)
        exportMS.to_hdf()

    def to_csv(self, out_file_path):
        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS = HighResMassSpecExport(out_file_path, self)
        exportMS.to_csv()

    def to_pandas(self, out_file_path):
        # pickle dataframe (pkl extension)
        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS = HighResMassSpecExport(out_file_path, self)
        exportMS.to_pandas()

    def to_dataframe(self,):
        # returns pandas dataframe

        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS = HighResMassSpecExport(self.filename, self)
        return exportMS.get_pandas_df()

    def to_json(self):
        # returns pandas dataframe

        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS = HighResMassSpecExport(self.filename, self)
        return exportMS.to_json()

    def parameters_json(self):

        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS = HighResMassSpecExport(self.filename, self)
        return exportMS.parameters_to_json()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc">MassSpecCalc</a></li>
<li><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking" href="../calc/PeakPicking.html#corems.mass_spectrum.calc.PeakPicking.PeakPicking">PeakPicking</a></li>
<li><a title="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc" href="../calc/NoiseCalc.html#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc">NoiseThresholdCalc</a></li>
<li><a title="corems.mass_spectrum.calc.KendrickGroup.KendrickGrouping" href="../calc/KendrickGroup.html#corems.mass_spectrum.calc.KendrickGroup.KendrickGrouping">KendrickGrouping</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid">MassSpecCentroid</a></li>
<li><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecProfile" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecProfile">MassSpecProfile</a></li>
<li><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecfromFreq" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecfromFreq">MassSpecfromFreq</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.Aterm"><code class="name">var <span class="ident">Aterm</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Aterm(self):
    return self._calibration_terms[0]</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.Bterm"><code class="name">var <span class="ident">Bterm</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Bterm(self):
    return self._calibration_terms[1]</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.Cterm"><code class="name">var <span class="ident">Cterm</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Cterm(self):
    return self._calibration_terms[2]</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.abundance"><code class="name">var <span class="ident">abundance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def abundance(self):
    self.check_mspeaks()
    return array([mspeak.abundance for mspeak in self.mspeaks])</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.abundance_profile"><code class="name">var <span class="ident">abundance_profile</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def abundance_profile(self): return self._abundance</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.baselise_noise"><code class="name">var <span class="ident">baselise_noise</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def baselise_noise(self):
    if self._baselise_noise:
        return self._baselise_noise
    else:     
        return None</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.baselise_noise_std"><code class="name">var <span class="ident">baselise_noise_std</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def baselise_noise_std(self):
    if self._baselise_noise_std:
        return self._baselise_noise_std
    else:     
        return None</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.dir_location"><code class="name">var <span class="ident">dir_location</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dir_location(self):
    return self._dir_location</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.dynamic_range"><code class="name">var <span class="ident">dynamic_range</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dynamic_range(self):
    return self._dynamic_range</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filename"><code class="name">var <span class="ident">filename</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def filename(self):
    return Path(self._filename)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.freq_exp_profile"><code class="name">var <span class="ident">freq_exp_profile</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def freq_exp_profile(self):
    return self._frequency_domain</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.kendrick_mass"><code class="name">var <span class="ident">kendrick_mass</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kendrick_mass(self):
    self.check_mspeaks()
    return array([mspeak.kendrick_mass for mspeak in self.mspeaks])</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.kmd"><code class="name">var <span class="ident">kmd</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kmd(self):
    self.check_mspeaks()
    return array([mspeak.kmd for mspeak in self.mspeaks])</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.max_abundance"><code class="name">var <span class="ident">max_abundance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_abundance(self):
    
    return max([mspeak.abundance for mspeak in self.mspeaks])</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.max_mz_exp"><code class="name">var <span class="ident">max_mz_exp</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_mz_exp(self):
    return max([mspeak.mz_exp for mspeak in self.mspeaks])</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.max_signal_to_noise"><code class="name">var <span class="ident">max_signal_to_noise</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_signal_to_noise(self):
    return max([mspeak.signal_to_noise for mspeak in self.mspeaks])</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.min_abundance"><code class="name">var <span class="ident">min_abundance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def min_abundance(self):
    return min([mspeak.abundance for mspeak in self.mspeaks])</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.min_mz_exp"><code class="name">var <span class="ident">min_mz_exp</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def min_mz_exp(self):
    return min([mspeak.mz_exp for mspeak in self.mspeaks])</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.molecular_search_settings"><code class="name">var <span class="ident">molecular_search_settings</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def molecular_search_settings(self):  return self.parameters.molecular_search</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.most_abundant_mspeak"><code class="name">var <span class="ident">most_abundant_mspeak</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def most_abundant_mspeak(self):
    return max(self.mspeaks, key=lambda m: m.abundance)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.mspeaks_settings"><code class="name">var <span class="ident">mspeaks_settings</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mspeaks_settings(self): return self.parameters.ms_peak</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.mz_cal"><code class="name">var <span class="ident">mz_cal</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mz_cal(self):
    return array([mspeak.mz_cal for mspeak in self.mspeaks])</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.mz_cal_profile"><code class="name">var <span class="ident">mz_cal_profile</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mz_cal_profile(self):

    return self._mz_cal_profile</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.mz_exp"><code class="name">var <span class="ident">mz_exp</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mz_exp(self):

    self.check_mspeaks()

    if self.is_calibrated:

        return array([mspeak.mz_cal for mspeak in self.mspeaks])

    else:

        return array([mspeak.mz_exp for mspeak in self.mspeaks])</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.mz_exp_profile"><code class="name">var <span class="ident">mz_exp_profile</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mz_exp_profile(self): return self._mz_exp</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.nominal_mz"><code class="name">var <span class="ident">nominal_mz</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nominal_mz(self):

    if self._dict_nominal_masses_indexes:

        return sorted(list(self._dict_nominal_masses_indexes.keys()))

    else:

        raise ValueError(&#34;Nominal indexes not yet set&#34;)    </code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.parameters"><code class="name">var <span class="ident">parameters</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parameters(self):
    return self._parameters</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.resolving_power"><code class="name">var <span class="ident">resolving_power</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolving_power(self):
    self.check_mspeaks()
    return array([mspeak.resolving_power for mspeak in self.mspeaks])</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.settings"><code class="name">var <span class="ident">settings</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def settings(self): return self.parameters.mass_spectrum</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.signal_to_noise"><code class="name">var <span class="ident">signal_to_noise</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def signal_to_noise(self):
    self.check_mspeaks()
    return array([mspeak.signal_to_noise for mspeak in self.mspeaks])</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.tic"><code class="name">var <span class="ident">tic</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tic(self):

    return sum(self.abundance_profile)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.add_mspeak"><code class="name flex">
<span>def <span class="ident">add_mspeak</span></span>(<span>self, ion_charge, mz_exp, abundance, resolving_power, signal_to_noise, massspec_indexes, exp_freq=None, ms_parent=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_mspeak(self, ion_charge, mz_exp,
                abundance,
                resolving_power,
                signal_to_noise,
                massspec_indexes,
                exp_freq=None,
                ms_parent=None
            ):

    mspeak = MSPeak(
            ion_charge,
            mz_exp,
            abundance,
            resolving_power,
            signal_to_noise,
            massspec_indexes,
            len(self._mspeaks),
            exp_freq=exp_freq,
            ms_parent=ms_parent,
    )

    self._mspeaks.append(mspeak)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.cal_noise_threshold"><code class="name flex">
<span>def <span class="ident">cal_noise_threshold</span></span>(<span>self, auto=True, bayes=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cal_noise_threshold(self, auto=True, bayes=False):

    if self.label == Labels.simulated_profile:

        self._baselise_noise, self._baselise_noise_std = 0.1, 1

    else:

        self._baselise_noise, self._baselise_noise_std = self.run_noise_threshold_calc(auto, bayes=bayes)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.change_kendrick_base_all_mspeaks"><code class="name flex">
<span>def <span class="ident">change_kendrick_base_all_mspeaks</span></span>(<span>self, kendrick_dict_base)</span>
</code></dt>
<dd>
<div class="desc"><p>kendrick_dict_base = {"C": 1, "H": 2} or {{"C": 1, "H": 1, "O":1} etc</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_kendrick_base_all_mspeaks(self, kendrick_dict_base):
    &#34;&#34;&#34;kendrick_dict_base = {&#34;C&#34;: 1, &#34;H&#34;: 2} or {{&#34;C&#34;: 1, &#34;H&#34;: 1, &#34;O&#34;:1} etc &#34;&#34;&#34;

    self.parameters.ms_peak.kendrick_base = kendrick_dict_base

    for mspeak in self.mspeaks:

        mspeak.change_kendrick_base(kendrick_dict_base)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.check_mspeaks"><code class="name flex">
<span>def <span class="ident">check_mspeaks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_mspeaks(self):
    if self.mspeaks:
        pass
    else:
        raise Exception(
            &#34;mspeaks list is empty, please run process_mass_spec() first&#34;
        )</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.check_mspeaks_warning"><code class="name flex">
<span>def <span class="ident">check_mspeaks_warning</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_mspeaks_warning(self):
    import warnings
    if self.mspeaks:
        pass
    else:
        warnings.warn(
            &#34;mspeaks list is empty, continuing without filtering data&#34;
        )</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.clear_molecular_formulas"><code class="name flex">
<span>def <span class="ident">clear_molecular_formulas</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_molecular_formulas(self):

    self.check_mspeaks()
    return array([mspeak.clear_molecular_formulas() for mspeak in self.mspeaks])</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.datapoints_count_by_nominal_mz"><code class="name flex">
<span>def <span class="ident">datapoints_count_by_nominal_mz</span></span>(<span>self, mz_overlay=0.1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def datapoints_count_by_nominal_mz(self, mz_overlay=0.1):

    dict_nominal_masses_count ={}

    all_nominal_masses = list(set([i.nominal_mz_exp for i in self.mspeaks]))

    for nominal_mass in all_nominal_masses:

        if nominal_mass not in dict_nominal_masses_count:

            min_mz = nominal_mass - mz_overlay

            max_mz = nominal_mass + 1 + mz_overlay

            indexes = indexes = where((self.mz_exp_profile &gt; min_mz) &amp; (self.mz_exp_profile &lt; max_mz)) 

            dict_nominal_masses_count[nominal_mass] = indexes[0].size

    return dict_nominal_masses_count</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_abundance"><code class="name flex">
<span>def <span class="ident">filter_by_abundance</span></span>(<span>self, min_abund, max_abund=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_by_abundance(self, min_abund, max_abund=False):

    self.check_mspeaks_warning()
    if not max_abund:
        max_abund = self.max_abundance
    indexes = [index for index, mspeak in enumerate(self.mspeaks) if min_abund &lt;= mspeak.abundance &lt;= max_abund]
    self.filter_by_index(indexes)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_index"><code class="name flex">
<span>def <span class="ident">filter_by_index</span></span>(<span>self, list_indexes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_by_index(self, list_indexes):

    self.mspeaks = [self.mspeaks[i] for i in range(len(self.mspeaks)) if i not in list_indexes]

    for i, mspeak in  enumerate(self.mspeaks): mspeak.index = i

    self._set_nominal_masses_start_final_indexes()</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_max_resolving_power"><code class="name flex">
<span>def <span class="ident">filter_by_max_resolving_power</span></span>(<span>self, B, T)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_by_max_resolving_power(self, B, T):

    rpe = lambda m, z: (1.274e7 * z * B * T)/(m*z)

    self.check_mspeaks_warning()

    indexes_to_remove = [index for index, mspeak in enumerate(self.mspeaks) if  mspeak.resolving_power &gt;= rpe(mspeak.mz_exp,mspeak.ion_charge)]
    self.filter_by_index(indexes_to_remove)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_min_resolving_power"><code class="name flex">
<span>def <span class="ident">filter_by_min_resolving_power</span></span>(<span>self, B, T)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_by_min_resolving_power(self, B, T):

    rpe = lambda m, z: (1.274e7 * z * B * T)/(m*z)

    self.check_mspeaks_warning()

    indexes_to_remove = [index for index, mspeak in enumerate(self.mspeaks) if  mspeak.resolving_power &lt;= rpe(mspeak.mz_exp,mspeak.ion_charge)]
    self.filter_by_index(indexes_to_remove)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_mz"><code class="name flex">
<span>def <span class="ident">filter_by_mz</span></span>(<span>self, min_mz, max_mz)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_by_mz(self, min_mz, max_mz):

    self.check_mspeaks_warning()
    indexes = [index for index, mspeak in enumerate(self.mspeaks) if min_mz &lt;= mspeak.mz_exp &lt;= max_mz]
    self.filter_by_index(indexes)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_noise_threshold"><code class="name flex">
<span>def <span class="ident">filter_by_noise_threshold</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_by_noise_threshold(self):
    
    threshold = self.get_noise_threshold()[1][0]
    
    self.check_mspeaks_warning()
    
    indexes_to_remove = [index for index, mspeak in enumerate(self.mspeaks) if  mspeak.abundance &lt;= threshold]
    self.filter_by_index(indexes_to_remove)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_s2n"><code class="name flex">
<span>def <span class="ident">filter_by_s2n</span></span>(<span>self, min_s2n, max_s2n=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_by_s2n(self, min_s2n, max_s2n=False):

    self.check_mspeaks_warning()
    if not max_s2n:
        max_s2n = self.max_signal_to_noise

    self.check_mspeaks_warning()
    indexes = [index for index, mspeak in enumerate(self.mspeaks) if min_s2n &lt;= mspeak.signal_to_noise &lt;= max_s2n ]
    self.filter_by_index(indexes)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.find_peaks"><code class="name flex">
<span>def <span class="ident">find_peaks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>needs to clear previous results from peak_picking</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_peaks(self):
    &#34;&#34;&#34;needs to clear previous results from peak_picking&#34;&#34;&#34;
    self._mspeaks = list()
    &#34;&#34;&#34;then do peak picking&#34;&#34;&#34;

    self.do_peak_picking()</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.freq_exp"><code class="name flex">
<span>def <span class="ident">freq_exp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def freq_exp(self):
    self.check_mspeaks()
    return array([mspeak.freq_exp for mspeak in self.mspeaks])</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.get_masses_count_by_nominal_mass"><code class="name flex">
<span>def <span class="ident">get_masses_count_by_nominal_mass</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_masses_count_by_nominal_mass(self):

    dict_nominal_masses_count = {}

    all_nominal_masses = list(set([i.nominal_mz_exp for i in self.mspeaks]))

    for nominal_mass in all_nominal_masses:
        if nominal_mass not in dict_nominal_masses_count:
            dict_nominal_masses_count[nominal_mass] = len(list(self.get_nominal_mass_indexes(nominal_mass)))

    return dict_nominal_masses_count</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.get_mz_and_abundance_peaks_tuples"><code class="name flex">
<span>def <span class="ident">get_mz_and_abundance_peaks_tuples</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mz_and_abundance_peaks_tuples(self):

    self.check_mspeaks()
    return [(mspeak.mz_exp, mspeak.abundance) for mspeak in self.mspeaks]</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.get_nominal_mass_indexes"><code class="name flex">
<span>def <span class="ident">get_nominal_mass_indexes</span></span>(<span>self, nominal_mass, overlay=0.1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nominal_mass_indexes(self, nominal_mass, overlay=0.1):

    min_mz_to_look = nominal_mass - overlay
    max_mz_to_look = nominal_mass + 1 + overlay

    return (i for i in range(len(self.mspeaks)) if min_mz_to_look &lt;= self.mspeaks[i].mz_exp &lt;= max_mz_to_look)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.get_nominal_mz_first_last_indexes"><code class="name flex">
<span>def <span class="ident">get_nominal_mz_first_last_indexes</span></span>(<span>self, nominal_mass)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nominal_mz_first_last_indexes(self, nominal_mass):

    if self._dict_nominal_masses_indexes:

        if nominal_mass in self._dict_nominal_masses_indexes.keys():

            return (self._dict_nominal_masses_indexes.get(nominal_mass)[0], self._dict_nominal_masses_indexes.get(nominal_mass)[1]+1)

        else:
            # import warnings
            # uncomment warn to distribution
            # warnings.warn(&#34;Nominal mass not found in _dict_nominal_masses_indexes, returning (0, 0) for nominal mass %i&#34;%nominal_mass)
            return (0, 0)
    else:
        raise Exception(&#34;run process_mass_spec() function before trying to access the data&#34;)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.parameters_json"><code class="name flex">
<span>def <span class="ident">parameters_json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parameters_json(self):

    from corems.mass_spectrum.output.export import HighResMassSpecExport
    exportMS = HighResMassSpecExport(self.filename, self)
    return exportMS.parameters_to_json()</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.plot_centroid"><code class="name flex">
<span>def <span class="ident">plot_centroid</span></span>(<span>self, ax=None, c='g')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_centroid(self, ax=None, c=&#39;g&#39;):

    import matplotlib.pyplot as plt
    if self._mspeaks:

        if ax is None:
            ax = plt.gca()

        markerline_a, stemlines_a, baseline_a = ax.stem(self.mz_exp, self.abundance, linefmt=&#39;-&#39;, markerfmt=&#34; &#34;, use_line_collection=True)

        plt.setp(markerline_a, &#39;color&#39;, c, &#39;linewidth&#39;, 2)
        plt.setp(stemlines_a, &#39;color&#39;, c, &#39;linewidth&#39;, 2)
        plt.setp(baseline_a, &#39;color&#39;, c, &#39;linewidth&#39;, 2)

        ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
        ax.set_ylabel(&#39;Abundance&#39;, fontsize=12)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

        ax.axes.spines[&#39;top&#39;].set_visible(False)
        ax.axes.spines[&#39;right&#39;].set_visible(False)

        ax.get_yaxis().set_visible(False)
        ax.spines[&#39;left&#39;].set_visible(False)

    else:

        raise Exception(&#34;No centroid data found, please run process_mass_spec&#34;)

    return ax</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.plot_mz_domain_profile"><code class="name flex">
<span>def <span class="ident">plot_mz_domain_profile</span></span>(<span>self, color='green', ax=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_mz_domain_profile(self, color=&#39;green&#39;, ax=None): #pragma: no cover

    import matplotlib.pyplot as plt

    if ax is None:
        ax = plt.gca()
    ax.plot(self.mz_exp_profile, self.abundance_profile, color=color)
    ax.set(xlabel=&#39;m/z&#39;, ylabel=&#39;abundance&#39;)

    return ax</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.plot_profile_and_noise_threshold"><code class="name flex">
<span>def <span class="ident">plot_profile_and_noise_threshold</span></span>(<span>self, ax=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_profile_and_noise_threshold(self, ax=None): 

    import matplotlib.pyplot as plt
    if self.baselise_noise_std and self.baselise_noise_std:

        # x = (self.mz_exp_profile.min(), self.mz_exp_profile.max())
        baseline = (self.baselise_noise, self.baselise_noise)

        # std = self.parameters.mass_spectrum.noise_threshold_std
        # threshold = self.baselise_noise_std + (std * self.baselise_noise_std)
        x, y = self.get_noise_threshold()    
        
        if ax is None:
            ax = plt.gca()
        
        ax.plot(self.mz_exp_profile, self.abundance_profile, color=&#34;green&#34;)
        ax.plot(x, (baseline, baseline), color=&#34;yellow&#34;)
        ax.plot(x, y, color=&#34;red&#34;)

        ax.set_xlabel(&#34;$\t{m/z}$&#34;, fontsize=12)
        ax.set_ylabel(&#39;Abundance&#39;, fontsize=12)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=12)

        ax.axes.spines[&#39;top&#39;].set_visible(False)
        ax.axes.spines[&#39;right&#39;].set_visible(False)

        ax.get_yaxis().set_visible(False)
        ax.spines[&#39;left&#39;].set_visible(False)

    else:

        raise Exception(&#34;Calculate noise threshold first&#34;)

    return ax</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.process_mass_spec"><code class="name flex">
<span>def <span class="ident">process_mass_spec</span></span>(<span>self, keep_profile=True, auto_noise=True, noise_bayes_est=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_mass_spec(self, keep_profile=True, auto_noise=True, noise_bayes_est=False):
    
    # if runned mannually make sure to rerun filter_by_noise_threshold     
    # calculates noise threshold 
    # do peak picking( create mspeak_objs) 
    # reset mspeak_obj the indexes
     
    self.cal_noise_threshold(auto=auto_noise, bayes=noise_bayes_est)

    self.find_peaks()
    self.reset_indexes()

    if self.mspeaks:
        self._dynamic_range = self.max_abundance / self.min_abundance
    else:
        self._dynamic_range = 0
    if not keep_profile:

        self._abundance *= 0
        self._mz_exp *= 0</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.remove_assignment_by_index"><code class="name flex">
<span>def <span class="ident">remove_assignment_by_index</span></span>(<span>self, indexes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_assignment_by_index(self, indexes):
    for i in indexes: self.mspeaks[i].clear_molecular_formulas()</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.reset_cal_therms"><code class="name flex">
<span>def <span class="ident">reset_cal_therms</span></span>(<span>self, Aterm, Bterm, C, fas=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_cal_therms(self, Aterm, Bterm, C, fas= 0):

    self._calibration_terms = (Aterm, Bterm, C)

    self._mz_exp = self._f_to_mz()
    self._abundance = self._abundance
    self.find_peaks()
    self.reset_indexes()</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.reset_indexes"><code class="name flex">
<span>def <span class="ident">reset_indexes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>reset the mass spectrum to interate over all MSpeaks obj</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_indexes(self):
    &#39;&#39;&#39; reset the mass spectrum to interate over all MSpeaks obj&#39;&#39;&#39;
    self.mspeaks = self._mspeaks

    for i, mspeak in  enumerate(self.mspeaks): mspeak.index = i

    self._set_nominal_masses_start_final_indexes()</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.set_indexes"><code class="name flex">
<span>def <span class="ident">set_indexes</span></span>(<span>self, list_indexes)</span>
</code></dt>
<dd>
<div class="desc"><p>set the mass spectrum to interate over only the selected MSpeaks indexes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_indexes(self, list_indexes):
    &#39;&#39;&#39; set the mass spectrum to interate over only the selected MSpeaks indexes&#39;&#39;&#39;
    self.mspeaks = [self._mspeaks[i] for i in list_indexes]

    for i, mspeak in  enumerate(self.mspeaks): mspeak.index = i

    self._set_nominal_masses_start_final_indexes()</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.set_parameter_from_json"><code class="name flex">
<span>def <span class="ident">set_parameter_from_json</span></span>(<span>self, parameters_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_parameter_from_json(self, parameters_path):
    load_and_set_parameters_ms(self, parameters_path=parameters_path)    </code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.sort_by_abundance"><code class="name flex">
<span>def <span class="ident">sort_by_abundance</span></span>(<span>self, reverse=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_by_abundance(self, reverse=False):
    return sorted(self, key=lambda m: m.abundance, reverse=reverse)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.sort_by_mz"><code class="name flex">
<span>def <span class="ident">sort_by_mz</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_by_mz(self):
    return sorted(self, key=lambda m: m.mz_exp)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_csv"><code class="name flex">
<span>def <span class="ident">to_csv</span></span>(<span>self, out_file_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_csv(self, out_file_path):
    from corems.mass_spectrum.output.export import HighResMassSpecExport
    exportMS = HighResMassSpecExport(out_file_path, self)
    exportMS.to_csv()</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_dataframe"><code class="name flex">
<span>def <span class="ident">to_dataframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dataframe(self,):
    # returns pandas dataframe

    from corems.mass_spectrum.output.export import HighResMassSpecExport
    exportMS = HighResMassSpecExport(self.filename, self)
    return exportMS.get_pandas_df()</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_excel"><code class="name flex">
<span>def <span class="ident">to_excel</span></span>(<span>self, out_file_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_excel(self, out_file_path):

    from corems.mass_spectrum.output.export import HighResMassSpecExport
    exportMS = HighResMassSpecExport(out_file_path, self)
    exportMS.to_excel()</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_hdf"><code class="name flex">
<span>def <span class="ident">to_hdf</span></span>(<span>self, out_file_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_hdf(self, out_file_path):
    from corems.mass_spectrum.output.export import HighResMassSpecExport
    exportMS = HighResMassSpecExport(out_file_path, self)
    exportMS.to_hdf()</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self):
    # returns pandas dataframe

    from corems.mass_spectrum.output.export import HighResMassSpecExport
    exportMS = HighResMassSpecExport(self.filename, self)
    return exportMS.to_json()</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_pandas"><code class="name flex">
<span>def <span class="ident">to_pandas</span></span>(<span>self, out_file_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_pandas(self, out_file_path):
    # pickle dataframe (pkl extension)
    from corems.mass_spectrum.output.export import HighResMassSpecExport
    exportMS = HighResMassSpecExport(out_file_path, self)
    exportMS.to_pandas()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc">MassSpecCalc</a></b></code>:
<ul class="hlist">
<li><code><a title="corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.calculate_resolving_power" href="../calc/PeakPicking.html#corems.mass_spectrum.calc.PeakPicking.PeakPicking.calculate_resolving_power">calculate_resolving_power</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.get_noise_threshold" href="../calc/NoiseCalc.html#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.get_noise_threshold">get_noise_threshold</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.number_average_molecular_weight" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.number_average_molecular_weight">number_average_molecular_weight</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.resolving_power_calc" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.resolving_power_calc">resolving_power_calc</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.weight_average_molecular_weight" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.weight_average_molecular_weight">weight_average_molecular_weight</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid"><code class="flex name class">
<span>class <span class="ident">MassSpecCentroid</span></span>
<span>(</span><span>data_dict, d_params)</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>A iterative mass spectrum class when data entry is centroid mode</li>
<li>Stores the centroid data and instrument settings</li>
<li>Simulate profile data based on Gaussian or Lorentzian peak shape</li>
<li>Iteration over a list of MSPeaks classes stored at the _mspeaks attributes</li>
<li>_mspeaks is populated under the hood by calling process_mass_spec method</li>
<li>iteration is null if _mspeaks is empty</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_dict</code></strong> :&ensp;<code>dict {string: numpy array float64 )</code></dt>
<dd>contains keys [m/z, Abundance, Resolving Power, S/N]</dd>
<dt><strong><code>d_params</code></strong> :&ensp;<code>dict{'str': float, int</code> or <code>str}</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>_mz_exp</code></strong> :&ensp;<code>list(float)</code></dt>
<dd>This is where we store mz_exp,</dd>
<dt><strong><code>_abundance</code></strong> :&ensp;<code>list(float)
</code></dt>
<dd>This is where we store _abundance,</dd>
<dt><strong><code>_mspeaks</code></strong> :&ensp;<code>list(MSPeak)</code></dt>
<dd>store MSpeaks objects identified by a peak picking algorithm</dd>
</dl>
<h2 id="attributes_1">Attributes</h2>
<dl>
<dt><strong><code>_mz_exp</code></strong> :&ensp;<code>list(float)</code></dt>
<dd>This is where we store mz_exp,</dd>
<dt><strong><code>_frequency_domain</code></strong> :&ensp;<code>list(float)</code></dt>
<dd>This is where we store _frequency_domain,</dd>
<dt><strong><code>_abundance</code></strong> :&ensp;<code>list(float)
</code></dt>
<dd>This is where we store _abundance,</dd>
<dt><strong><code>_mspeaks</code></strong> :&ensp;<code>list(MSPeak)</code></dt>
<dd>store MSpeaks objects identified by a peak picking algorithm</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>store label (Bruker, Midas Transient, see Labels class)</dd>
</dl>
<h2 id="relevant-methods">Relevant Methods</h2>
<p>_set_mz_domain()
calculates the m_z based on the setting of d_params</p>
<p>process_mass_spec()
- overrides the base class function
- Populates _mspeaks list with MSpeaks class using the centroid date</p>
<p>see also: MassSpecBase(), MassSpecfromFreq(), MassSpecProfile()</p>
<p>needs to simulate peak shape and pass as mz_exp and magnitude.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MassSpecCentroid(MassSpecBase):

    &#39;&#39;&#39;
    - A iterative mass spectrum class when data entry is centroid mode
    - Stores the centroid data and instrument settings
    - Simulate profile data based on Gaussian or Lorentzian peak shape
    - Iteration over a list of MSPeaks classes stored at the _mspeaks attributes
    - _mspeaks is populated under the hood by calling process_mass_spec method
    - iteration is null if _mspeaks is empty

    Parameters
    ----------
    data_dict : dict {string: numpy array float64 )
        contains keys [m/z, Abundance, Resolving Power, S/N] 
    d_params : dict{&#39;str&#39;: float, int or str}
        
    Attributes
    ----------
    _mz_exp : list(float)
        This is where we store mz_exp,
    _abundance : list(float)     
        This is where we store _abundance,
    _mspeaks : list(MSPeak)
        store MSpeaks objects identified by a peak picking algorithm  

    Attributes
    ----------
    _mz_exp : list(float)
        This is where we store mz_exp,
    _frequency_domain : list(float)
        This is where we store _frequency_domain,
    _abundance : list(float)     
        This is where we store _abundance,
    _mspeaks : list(MSPeak)
        store MSpeaks objects identified by a peak picking algorithm     
    label : str
        store label (Bruker, Midas Transient, see Labels class)
    
    Relevant Methods
    ----------
    _set_mz_domain()
        calculates the m_z based on the setting of d_params

    process_mass_spec()
        - overrides the base class function
        - Populates _mspeaks list with MSpeaks class using the centroid date

    see also: MassSpecBase(), MassSpecfromFreq(), MassSpecProfile()
    &#39;&#39;&#39;

    def __init__(self, data_dict, d_params):

        &#34;&#34;&#34;needs to simulate peak shape and pass as mz_exp and magnitude.&#34;&#34;&#34;

        super().__init__([], [], d_params)

        self._set_parameters_objects(d_params)
        
        if self.label == Labels.thermo_centroid:
            self._baselise_noise = d_params.get(&#34;baselise_noise&#34;)
            self._baselise_noise_std = d_params.get(&#34;baselise_noise_std&#34;)

        self.is_centroid = True

        self.process_mass_spec(data_dict)

    def __simulate_profile__data__(self, exp_mz_centroid, magnitude_centroid):
        &#39;&#39;&#39;needs theoretical resolving power calculation and define peak shape
        this is a quick fix to trick a line plot be able to plot as sticks&#39;&#39;&#39;

        x, y = [], []
        for i in range(len(exp_mz_centroid)):
            x.append(exp_mz_centroid[i] - 0.0000001)
            x.append(exp_mz_centroid[i])
            x.append(exp_mz_centroid[i] + 0.0000001)
            y.append(0)
            y.append(magnitude_centroid[i])
            y.append(0)
        return x, y

    @property
    def mz_exp_profile(self):

        mz_list = []
        for mz in self.mz_exp:
            mz_list.append(mz - 0.0000001)
            mz_list.append(mz)
            mz_list.append(mz + 0.0000001)
        return mz_list
    
    @mz_exp_profile.setter
    def mz_exp_profile(self, _mz_exp ): self._mz_exp = _mz_exp

    @property
    def abundance_profile(self):
        ab_list = []
        for ab in self.abundance:
            ab_list.append(0)
            ab_list.append(ab)
            ab_list.append(0)
        return ab_list

    @abundance_profile.setter
    def abundance_profile(self, abundance ): self._abundance = abundance

    @property
    def tic(self):

        return sum(self.abundance)

    def process_mass_spec(self, data_dict, auto_noise=True, noise_bayes_est=False):
        import tqdm
        # overwrite process_mass_spec 
        # mspeak objs are usually added inside the PeaKPicking class 
        # for profile and freq based data
        

        s2n = True
        ion_charge = self.polarity
        #l_exp_mz_centroid = data_dict.get(Labels.mz)
        #l_intes_centr = data_dict.get(Labels.abundance)
        #l_peak_resolving_power = data_dict.get(Labels.rp)
        l_s2n = data_dict.get(Labels.s2n)
        
        if not l_s2n: s2n = False
        
        print(&#34;Loading mass spectrum object&#34;)
        
        for index, mz in enumerate(data_dict.get(Labels.mz)):
            
            # centroid peak does not have start and end peak index pos
            massspec_indexes = (index, index, index)
            
            if s2n:
                
                self.add_mspeak(
                    ion_charge,
                    mz,
                    data_dict.get(Labels.abundance)[index],
                    data_dict.get(Labels.rp)[index],
                    l_s2n[index],
                    massspec_indexes,
                    ms_parent=self
                )

            else:

                self.add_mspeak(
                    ion_charge,
                    mz,
                    data_dict.get(Labels.abundance)[index],
                    data_dict.get(Labels.rp)[index],
                    -999,
                    massspec_indexes,
                    ms_parent=self
                )

        self.mspeaks = self._mspeaks
        self._dynamic_range = self.max_abundance / self.min_abundance
        self._set_nominal_masses_start_final_indexes()
        
        if self.label != Labels.thermo_centroid:
            self._baselise_noise, self._baselise_noise_std = self.run_noise_threshold_calc(auto=auto_noise, bayes=noise_bayes_est)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase">MassSpecBase</a></li>
<li><a title="corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc">MassSpecCalc</a></li>
<li><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking" href="../calc/PeakPicking.html#corems.mass_spectrum.calc.PeakPicking.PeakPicking">PeakPicking</a></li>
<li><a title="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc" href="../calc/NoiseCalc.html#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc">NoiseThresholdCalc</a></li>
<li><a title="corems.mass_spectrum.calc.KendrickGroup.KendrickGrouping" href="../calc/KendrickGroup.html#corems.mass_spectrum.calc.KendrickGroup.KendrickGrouping">KendrickGrouping</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes">MassSpecCentroidLowRes</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.abundance_profile"><code class="name">var <span class="ident">abundance_profile</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def abundance_profile(self):
    ab_list = []
    for ab in self.abundance:
        ab_list.append(0)
        ab_list.append(ab)
        ab_list.append(0)
    return ab_list</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.mz_exp_profile"><code class="name">var <span class="ident">mz_exp_profile</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mz_exp_profile(self):

    mz_list = []
    for mz in self.mz_exp:
        mz_list.append(mz - 0.0000001)
        mz_list.append(mz)
        mz_list.append(mz + 0.0000001)
    return mz_list</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.tic"><code class="name">var <span class="ident">tic</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tic(self):

    return sum(self.abundance)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.process_mass_spec"><code class="name flex">
<span>def <span class="ident">process_mass_spec</span></span>(<span>self, data_dict, auto_noise=True, noise_bayes_est=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_mass_spec(self, data_dict, auto_noise=True, noise_bayes_est=False):
    import tqdm
    # overwrite process_mass_spec 
    # mspeak objs are usually added inside the PeaKPicking class 
    # for profile and freq based data
    

    s2n = True
    ion_charge = self.polarity
    #l_exp_mz_centroid = data_dict.get(Labels.mz)
    #l_intes_centr = data_dict.get(Labels.abundance)
    #l_peak_resolving_power = data_dict.get(Labels.rp)
    l_s2n = data_dict.get(Labels.s2n)
    
    if not l_s2n: s2n = False
    
    print(&#34;Loading mass spectrum object&#34;)
    
    for index, mz in enumerate(data_dict.get(Labels.mz)):
        
        # centroid peak does not have start and end peak index pos
        massspec_indexes = (index, index, index)
        
        if s2n:
            
            self.add_mspeak(
                ion_charge,
                mz,
                data_dict.get(Labels.abundance)[index],
                data_dict.get(Labels.rp)[index],
                l_s2n[index],
                massspec_indexes,
                ms_parent=self
            )

        else:

            self.add_mspeak(
                ion_charge,
                mz,
                data_dict.get(Labels.abundance)[index],
                data_dict.get(Labels.rp)[index],
                -999,
                massspec_indexes,
                ms_parent=self
            )

    self.mspeaks = self._mspeaks
    self._dynamic_range = self.max_abundance / self.min_abundance
    self._set_nominal_masses_start_final_indexes()
    
    if self.label != Labels.thermo_centroid:
        self._baselise_noise, self._baselise_noise_std = self.run_noise_threshold_calc(auto=auto_noise, bayes=noise_bayes_est)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase">MassSpecBase</a></b></code>:
<ul class="hlist">
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.calculate_resolving_power" href="../calc/PeakPicking.html#corems.mass_spectrum.calc.PeakPicking.PeakPicking.calculate_resolving_power">calculate_resolving_power</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.change_kendrick_base_all_mspeaks" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.change_kendrick_base_all_mspeaks">change_kendrick_base_all_mspeaks</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.find_peaks" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.find_peaks">find_peaks</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.get_noise_threshold" href="../calc/NoiseCalc.html#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.get_noise_threshold">get_noise_threshold</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.number_average_molecular_weight" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.number_average_molecular_weight">number_average_molecular_weight</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.reset_indexes" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.reset_indexes">reset_indexes</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.resolving_power_calc" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.resolving_power_calc">resolving_power_calc</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.set_indexes" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.set_indexes">set_indexes</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.weight_average_molecular_weight" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.weight_average_molecular_weight">weight_average_molecular_weight</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes"><code class="flex name class">
<span>class <span class="ident">MassSpecCentroidLowRes</span></span>
<span>(</span><span>data_dict, d_params)</span>
</code></dt>
<dd>
<div class="desc"><p>Does not store MSPeak Objs, will iterate over mz, abundance pairs instead</p>
<p>needs to simulate peak shape and pass as mz_exp and magnitude.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MassSpecCentroidLowRes(MassSpecCentroid,):
    
    &#39;&#39;&#39;Does not store MSPeak Objs, will iterate over mz, abundance pairs instead&#39;&#39;&#39;
    
    def __init__(self, data_dict, d_params):
    
        self._set_parameters_objects(d_params)
        self._mz_exp = array(data_dict.get(Labels.mz))
        self._abundance = array(data_dict.get(Labels.abundance))
        self._processed_tic = None
    
    def __len__(self):
        
        return len(self.mz_exp)
        
    def __getitem__(self, position):
        
        return (self.mz_exp[position], self.abundance[position])

    @property
    def mz_exp(self):
        
        return self._mz_exp 

    @property
    def abundance(self):

        return self._abundance

    @property
    def processed_tic(self):
    
        return sum(self._processed_tic)
    
    @property
    def tic(self):
    
        if self._processed_tic:
            return self._processed_tic
        else:
            return sum(self.abundance)
    
    @property
    def mz_abun_tuples(self):

        r = lambda x: ( int(round(x[0],0), int(round(x[1],0))) )

        return [r(i) for i in self]
    
    @property
    def mz_abun_dict(self):
        
        r = lambda x: int(round(x,0))
            
        return { r(i[0]):r(i[1]) for i in self}
    
    &#39;&#39;&#39;
    def to_excel(self, out_file_path):
    
    
    exportMS= HighResMassSpecExport(out_file_path, self)
    exportMS.to_excel()


    def to_hdf(self, out_file_path):
        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS= HighResMassSpecExport(out_file_path, self)
        exportMS.to_hdf()

    def to_csv(self, out_file_path):
        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS= HighResMassSpecExport(out_file_path, self)
        exportMS.to_csv()
        
    def to_pandas(self, out_file_path):
        #pickle dataframe (pkl extension)
        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS= HighResMassSpecExport(out_file_path, self)
        exportMS.to_pandas()

    def to_dataframe(self,):
        #returns pandas dataframe
        
        from corems.mass_spectrum.output.export import HighResMassSpecExport
        exportMS= HighResMassSpecExport(self.filename, self)
        return exportMS.get_pandas_df()
       &#39;&#39;&#39; </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid">MassSpecCentroid</a></li>
<li><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase">MassSpecBase</a></li>
<li><a title="corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc">MassSpecCalc</a></li>
<li><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking" href="../calc/PeakPicking.html#corems.mass_spectrum.calc.PeakPicking.PeakPicking">PeakPicking</a></li>
<li><a title="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc" href="../calc/NoiseCalc.html#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc">NoiseThresholdCalc</a></li>
<li><a title="corems.mass_spectrum.calc.KendrickGroup.KendrickGrouping" href="../calc/KendrickGroup.html#corems.mass_spectrum.calc.KendrickGroup.KendrickGrouping">KendrickGrouping</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.abundance"><code class="name">var <span class="ident">abundance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def abundance(self):

    return self._abundance</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.mz_abun_dict"><code class="name">var <span class="ident">mz_abun_dict</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mz_abun_dict(self):
    
    r = lambda x: int(round(x,0))
        
    return { r(i[0]):r(i[1]) for i in self}</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.mz_abun_tuples"><code class="name">var <span class="ident">mz_abun_tuples</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mz_abun_tuples(self):

    r = lambda x: ( int(round(x[0],0), int(round(x[1],0))) )

    return [r(i) for i in self]</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.mz_exp"><code class="name">var <span class="ident">mz_exp</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mz_exp(self):
    
    return self._mz_exp </code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.processed_tic"><code class="name">var <span class="ident">processed_tic</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def processed_tic(self):

    return sum(self._processed_tic)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.tic"><code class="name">var <span class="ident">tic</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tic(self):

    if self._processed_tic:
        return self._processed_tic
    else:
        return sum(self.abundance)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid">MassSpecCentroid</a></b></code>:
<ul class="hlist">
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.calculate_resolving_power" href="../calc/PeakPicking.html#corems.mass_spectrum.calc.PeakPicking.PeakPicking.calculate_resolving_power">calculate_resolving_power</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.change_kendrick_base_all_mspeaks" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.change_kendrick_base_all_mspeaks">change_kendrick_base_all_mspeaks</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.find_peaks" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.find_peaks">find_peaks</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.get_noise_threshold" href="../calc/NoiseCalc.html#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.get_noise_threshold">get_noise_threshold</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.number_average_molecular_weight" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.number_average_molecular_weight">number_average_molecular_weight</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.reset_indexes" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.reset_indexes">reset_indexes</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.resolving_power_calc" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.resolving_power_calc">resolving_power_calc</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.set_indexes" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.set_indexes">set_indexes</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.weight_average_molecular_weight" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.weight_average_molecular_weight">weight_average_molecular_weight</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecProfile"><code class="flex name class">
<span>class <span class="ident">MassSpecProfile</span></span>
<span>(</span><span>data_dict, d_params, auto_process=True, auto_noise=True, noise_bayes_est=False)</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>A iterative mass spectrum class when the entry point is on profile format</li>
<li>Stores the profile data and instrument settings</li>
<li>Iteration over a list of MSPeaks classes stored at the _mspeaks attributes</li>
<li>_mspeaks is populated under the hood by calling process_mass_spec method</li>
<li>iteration is null if _mspeaks is empty</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dataframe</code></strong> :&ensp;<code>pandas Dataframe(Series(floats))</code></dt>
<dd>contains columns [m/z, Abundance, Resolving Power, S/N]</dd>
<dt><strong><code>d_params</code></strong> :&ensp;<code>dict{'str': float, int</code> or <code>str}</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>_mz_exp</code></strong> :&ensp;<code>list(float)</code></dt>
<dd>This is where we store mz_exp,</dd>
<dt><strong><code>_abundance</code></strong> :&ensp;<code>list(float)
</code></dt>
<dd>This is where we store _abundance,</dd>
<dt><strong><code>_mspeaks</code></strong> :&ensp;<code>list(MSPeak)</code></dt>
<dd>store MSpeaks objects identified by a peak picking algorithm</dd>
</dl>
<h2 id="relevant-methods">Relevant Methods</h2>
<p>process_mass_spec()
find or set the noise threshold base on the setting encapsulated at settings.input.ProcessingSetting.MassSpectrumSetting
- run the peak peaking algorithm and use the method addMSPeaks() to populate _mspeaks attribute</p>
<p>see also: MassSpecBase(), MassSpecfromFreq(), MassSpecProfile()</p>
<p>method docs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MassSpecProfile(MassSpecBase):
    &#39;&#39;&#39;
    - A iterative mass spectrum class when the entry point is on profile format
    - Stores the profile data and instrument settings
    - Iteration over a list of MSPeaks classes stored at the _mspeaks attributes
    - _mspeaks is populated under the hood by calling process_mass_spec method
    - iteration is null if _mspeaks is empty

    Parameters
    ----------
    dataframe : pandas Dataframe(Series(floats))
        contains columns [m/z, Abundance, Resolving Power, S/N] 
    d_params : dict{&#39;str&#39;: float, int or str}

    Attributes
    ----------
    _mz_exp : list(float)
        This is where we store mz_exp,
    _abundance : list(float)     
        This is where we store _abundance,
    _mspeaks : list(MSPeak)
        store MSpeaks objects identified by a peak picking algorithm

    Relevant Methods
    ----------
    process_mass_spec()
        find or set the noise threshold base on the setting encapsulated at settings.input.ProcessingSetting.MassSpectrumSetting
        - run the peak peaking algorithm and use the method addMSPeaks() to populate _mspeaks attribute

    see also: MassSpecBase(), MassSpecfromFreq(), MassSpecProfile()
    &#39;&#39;&#39;

    def __init__(self, data_dict, d_params, auto_process=True, auto_noise=True, noise_bayes_est=False):
        &#34;&#34;&#34;
        method docs
        &#34;&#34;&#34;
        # print(data_dict.keys())
        super().__init__(data_dict.get(Labels.mz), data_dict.get(Labels.abundance), d_params)
       
        if auto_process:
            self.process_mass_spec(auto_noise=auto_noise, noise_bayes_est=noise_bayes_est)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase">MassSpecBase</a></li>
<li><a title="corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc">MassSpecCalc</a></li>
<li><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking" href="../calc/PeakPicking.html#corems.mass_spectrum.calc.PeakPicking.PeakPicking">PeakPicking</a></li>
<li><a title="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc" href="../calc/NoiseCalc.html#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc">NoiseThresholdCalc</a></li>
<li><a title="corems.mass_spectrum.calc.KendrickGroup.KendrickGrouping" href="../calc/KendrickGroup.html#corems.mass_spectrum.calc.KendrickGroup.KendrickGrouping">KendrickGrouping</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase">MassSpecBase</a></b></code>:
<ul class="hlist">
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.calculate_resolving_power" href="../calc/PeakPicking.html#corems.mass_spectrum.calc.PeakPicking.PeakPicking.calculate_resolving_power">calculate_resolving_power</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.change_kendrick_base_all_mspeaks" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.change_kendrick_base_all_mspeaks">change_kendrick_base_all_mspeaks</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.find_peaks" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.find_peaks">find_peaks</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.get_noise_threshold" href="../calc/NoiseCalc.html#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.get_noise_threshold">get_noise_threshold</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.number_average_molecular_weight" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.number_average_molecular_weight">number_average_molecular_weight</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.reset_indexes" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.reset_indexes">reset_indexes</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.resolving_power_calc" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.resolving_power_calc">resolving_power_calc</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.set_indexes" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.set_indexes">set_indexes</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.weight_average_molecular_weight" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.weight_average_molecular_weight">weight_average_molecular_weight</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecfromFreq"><code class="flex name class">
<span>class <span class="ident">MassSpecfromFreq</span></span>
<span>(</span><span>frequency_domain, magnitude, d_params, auto_process=True, keep_profile=True, auto_noise=False, noise_bayes_est=False)</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>A iterative mass spectrum class when data entry is on frequency(Hz) domain</li>
<li>Transform to m/z based on the settings stored at d_params</li>
<li>Stores the profile data and instrument settings</li>
<li>Iteration over a list of MSPeaks classes stored at the _mspeaks attributes</li>
<li>_mspeaks is populated under the hood by calling process_mass_spec method</li>
<li>iteration is null if _mspeaks is empty</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>frequency_domain</code></strong> :&ensp;<code>list(float)</code></dt>
<dd>all datapoints in frequency domain in Hz</dd>
<dt><strong><code>magnitude</code></strong> :&ensp;<code>frequency_domain : list(float)</code></dt>
<dd>all datapoints in for magnitude of each frequency datapoint</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>_mz_exp</code></strong> :&ensp;<code>list(float)</code></dt>
<dd>This is where we store mz_exp,</dd>
<dt><strong><code>_frequency_domain</code></strong> :&ensp;<code>list(float)</code></dt>
<dd>This is where we store _frequency_domain,</dd>
<dt><strong><code>_abundance</code></strong> :&ensp;<code>list(float)
</code></dt>
<dd>This is where we store _abundance,</dd>
<dt><strong><code>_mspeaks</code></strong> :&ensp;<code>list(MSPeak)</code></dt>
<dd>store MSpeaks objects identified by a peak picking algorithm</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>store label (Bruker, Midas Transient, see Labels class ). It across distinct processing points</dd>
</dl>
<h2 id="relevant-methods">Relevant Methods</h2>
<p>_set_mz_domain()
calculates the m_z based on the setting of d_params</p>
<p>process_mass_spec()
find or set the noise threshold base on the setting encapsulated at settings.input.ProcessingSetting.MassSpectrumSetting
- run the peak peaking algorithm and use the method addMSPeaks() to populate _mspeaks attribute</p>
<p>see also: MassSpecBase(), MassSpecfromFreq(), MassSpecProfile()</p>
<p>method docs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MassSpecfromFreq(MassSpecBase):
    &#39;&#39;&#39;
    - A iterative mass spectrum class when data entry is on frequency(Hz) domain
    - Transform to m/z based on the settings stored at d_params
    - Stores the profile data and instrument settings
    - Iteration over a list of MSPeaks classes stored at the _mspeaks attributes
    - _mspeaks is populated under the hood by calling process_mass_spec method
    - iteration is null if _mspeaks is empty

    Parameters
    ----------
    frequency_domain : list(float)
        all datapoints in frequency domain in Hz
    magnitude :  frequency_domain : list(float)
        all datapoints in for magnitude of each frequency datapoint

    Attributes
    ----------
    _mz_exp : list(float)
        This is where we store mz_exp,
    _frequency_domain : list(float)
        This is where we store _frequency_domain,
    _abundance : list(float)     
        This is where we store _abundance,
    _mspeaks : list(MSPeak)
        store MSpeaks objects identified by a peak picking algorithm     
    label : str
        store label (Bruker, Midas Transient, see Labels class ). It across distinct processing points
    
    Relevant Methods
    ----------
    _set_mz_domain()
        calculates the m_z based on the setting of d_params

    process_mass_spec()
        find or set the noise threshold base on the setting encapsulated at settings.input.ProcessingSetting.MassSpectrumSetting
        - run the peak peaking algorithm and use the method addMSPeaks() to populate _mspeaks attribute
    
    see also: MassSpecBase(), MassSpecfromFreq(), MassSpecProfile()
    &#39;&#39;&#39;

    def __init__(self, frequency_domain, magnitude, d_params, 
                auto_process=True, keep_profile=True, auto_noise=False, noise_bayes_est=False):
        &#34;&#34;&#34;
        method docs
        &#34;&#34;&#34;
        super().__init__(None, magnitude, d_params)

        self._frequency_domain = frequency_domain
        self.has_frequency = True
        self._set_mz_domain()

        
        &#34;&#34;&#34; use this call to automatically process data as the object is created, Setting need to be changed before initiating the class to be in effect&#34;&#34;&#34;
        
        if auto_process:
            self.process_mass_spec(keep_profile=keep_profile, auto_noise=auto_noise, noise_bayes_est=noise_bayes_est)


    def _set_mz_domain(self):

        if self.label == Labels.bruker_frequency:

            self._mz_exp = self._f_to_mz_bruker()

        else:

            self._mz_exp = self._f_to_mz()

    @property
    def transient_settings(self): return self.parameters.transient

    @transient_settings.setter
    def transient_settings(self, instance_TransientSetting):
     
        self.parameters.transient = instance_TransientSetting  </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase">MassSpecBase</a></li>
<li><a title="corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc">MassSpecCalc</a></li>
<li><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking" href="../calc/PeakPicking.html#corems.mass_spectrum.calc.PeakPicking.PeakPicking">PeakPicking</a></li>
<li><a title="corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc" href="../calc/NoiseCalc.html#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc">NoiseThresholdCalc</a></li>
<li><a title="corems.mass_spectrum.calc.KendrickGroup.KendrickGrouping" href="../calc/KendrickGroup.html#corems.mass_spectrum.calc.KendrickGroup.KendrickGrouping">KendrickGrouping</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecfromFreq.transient_settings"><code class="name">var <span class="ident">transient_settings</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def transient_settings(self): return self.parameters.transient</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase">MassSpecBase</a></b></code>:
<ul class="hlist">
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.calculate_resolving_power" href="../calc/PeakPicking.html#corems.mass_spectrum.calc.PeakPicking.PeakPicking.calculate_resolving_power">calculate_resolving_power</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.change_kendrick_base_all_mspeaks" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.change_kendrick_base_all_mspeaks">change_kendrick_base_all_mspeaks</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.find_peaks" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.find_peaks">find_peaks</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.get_noise_threshold" href="../calc/NoiseCalc.html#corems.mass_spectrum.calc.NoiseCalc.NoiseThresholdCalc.get_noise_threshold">get_noise_threshold</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.number_average_molecular_weight" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.number_average_molecular_weight">number_average_molecular_weight</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.reset_indexes" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.reset_indexes">reset_indexes</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.resolving_power_calc" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.resolving_power_calc">resolving_power_calc</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.set_indexes" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.set_indexes">set_indexes</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.weight_average_molecular_weight" href="../calc/MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc.weight_average_molecular_weight">weight_average_molecular_weight</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.mass_spectrum.factory" href="index.html">corems.mass_spectrum.factory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.overrides" href="#corems.mass_spectrum.factory.MassSpectrumClasses.overrides">overrides</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase">MassSpecBase</a></code></h4>
<ul class="">
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.Aterm" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.Aterm">Aterm</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.Bterm" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.Bterm">Bterm</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.Cterm" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.Cterm">Cterm</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.abundance" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.abundance">abundance</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.abundance_profile" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.abundance_profile">abundance_profile</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.add_mspeak" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.add_mspeak">add_mspeak</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.baselise_noise" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.baselise_noise">baselise_noise</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.baselise_noise_std" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.baselise_noise_std">baselise_noise_std</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.cal_noise_threshold" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.cal_noise_threshold">cal_noise_threshold</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.change_kendrick_base_all_mspeaks" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.change_kendrick_base_all_mspeaks">change_kendrick_base_all_mspeaks</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.check_mspeaks" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.check_mspeaks">check_mspeaks</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.check_mspeaks_warning" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.check_mspeaks_warning">check_mspeaks_warning</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.clear_molecular_formulas" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.clear_molecular_formulas">clear_molecular_formulas</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.datapoints_count_by_nominal_mz" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.datapoints_count_by_nominal_mz">datapoints_count_by_nominal_mz</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.dir_location" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.dir_location">dir_location</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.dynamic_range" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.dynamic_range">dynamic_range</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filename" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filename">filename</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_abundance" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_abundance">filter_by_abundance</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_index" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_index">filter_by_index</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_max_resolving_power" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_max_resolving_power">filter_by_max_resolving_power</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_min_resolving_power" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_min_resolving_power">filter_by_min_resolving_power</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_mz" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_mz">filter_by_mz</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_noise_threshold" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_noise_threshold">filter_by_noise_threshold</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_s2n" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.filter_by_s2n">filter_by_s2n</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.find_peaks" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.find_peaks">find_peaks</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.freq_exp" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.freq_exp">freq_exp</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.freq_exp_profile" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.freq_exp_profile">freq_exp_profile</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.get_masses_count_by_nominal_mass" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.get_masses_count_by_nominal_mass">get_masses_count_by_nominal_mass</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.get_mz_and_abundance_peaks_tuples" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.get_mz_and_abundance_peaks_tuples">get_mz_and_abundance_peaks_tuples</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.get_nominal_mass_indexes" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.get_nominal_mass_indexes">get_nominal_mass_indexes</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.get_nominal_mz_first_last_indexes" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.get_nominal_mz_first_last_indexes">get_nominal_mz_first_last_indexes</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.kendrick_mass" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.kendrick_mass">kendrick_mass</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.kmd" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.kmd">kmd</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.max_abundance" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.max_abundance">max_abundance</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.max_mz_exp" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.max_mz_exp">max_mz_exp</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.max_signal_to_noise" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.max_signal_to_noise">max_signal_to_noise</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.min_abundance" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.min_abundance">min_abundance</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.min_mz_exp" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.min_mz_exp">min_mz_exp</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.molecular_search_settings" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.molecular_search_settings">molecular_search_settings</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.most_abundant_mspeak" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.most_abundant_mspeak">most_abundant_mspeak</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.mspeaks_settings" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.mspeaks_settings">mspeaks_settings</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.mz_cal" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.mz_cal">mz_cal</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.mz_cal_profile" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.mz_cal_profile">mz_cal_profile</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.mz_exp" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.mz_exp">mz_exp</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.mz_exp_profile" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.mz_exp_profile">mz_exp_profile</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.nominal_mz" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.nominal_mz">nominal_mz</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.parameters" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.parameters">parameters</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.parameters_json" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.parameters_json">parameters_json</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.plot_centroid" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.plot_centroid">plot_centroid</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.plot_mz_domain_profile" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.plot_mz_domain_profile">plot_mz_domain_profile</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.plot_profile_and_noise_threshold" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.plot_profile_and_noise_threshold">plot_profile_and_noise_threshold</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.process_mass_spec" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.process_mass_spec">process_mass_spec</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.remove_assignment_by_index" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.remove_assignment_by_index">remove_assignment_by_index</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.reset_cal_therms" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.reset_cal_therms">reset_cal_therms</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.reset_indexes" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.reset_indexes">reset_indexes</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.resolving_power" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.resolving_power">resolving_power</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.set_indexes" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.set_indexes">set_indexes</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.set_parameter_from_json" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.set_parameter_from_json">set_parameter_from_json</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.settings" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.settings">settings</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.signal_to_noise" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.signal_to_noise">signal_to_noise</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.sort_by_abundance" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.sort_by_abundance">sort_by_abundance</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.sort_by_mz" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.sort_by_mz">sort_by_mz</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.tic" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.tic">tic</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_csv" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_csv">to_csv</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_dataframe" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_dataframe">to_dataframe</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_excel" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_excel">to_excel</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_hdf" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_hdf">to_hdf</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_json" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_json">to_json</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_pandas" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecBase.to_pandas">to_pandas</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid">MassSpecCentroid</a></code></h4>
<ul class="">
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.abundance_profile" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.abundance_profile">abundance_profile</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.mz_exp_profile" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.mz_exp_profile">mz_exp_profile</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.process_mass_spec" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.process_mass_spec">process_mass_spec</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.tic" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroid.tic">tic</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes">MassSpecCentroidLowRes</a></code></h4>
<ul class="two-column">
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.abundance" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.abundance">abundance</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.mz_abun_dict" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.mz_abun_dict">mz_abun_dict</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.mz_abun_tuples" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.mz_abun_tuples">mz_abun_tuples</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.mz_exp" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.mz_exp">mz_exp</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.processed_tic" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.processed_tic">processed_tic</a></code></li>
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.tic" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecCentroidLowRes.tic">tic</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecProfile" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecProfile">MassSpecProfile</a></code></h4>
</li>
<li>
<h4><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecfromFreq" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecfromFreq">MassSpecfromFreq</a></code></h4>
<ul class="">
<li><code><a title="corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecfromFreq.transient_settings" href="#corems.mass_spectrum.factory.MassSpectrumClasses.MassSpecfromFreq.transient_settings">transient_settings</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>